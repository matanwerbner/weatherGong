{"version":3,"sources":["webpack:///bundle.js","webpack:///webpack/bootstrap 62a364fa22f7bdb64881","webpack:///./app/index.js","webpack:///./app/components/index.js","webpack:///./app/components/tabs/index.js","webpack:///./app/components/tabs/dashboard/index.js","webpack:///./app/components/tabs/dashboard/dashboard.route.js","webpack:///./app/components/tabs/dashboard/dashboard.controller.js","webpack:///./app/storage/subscriptionIds.helper.js","webpack:///./app/components/tabs/dashboard/locationModal.html","webpack:///./app/components/tabs/dashboard/dashboard.html","webpack:///./app/components/tabs/dashboard/dashboard.scss?421f","webpack:///./app/components/tabs/dashboard/dashboard.scss","webpack:///./~/css-loader/lib/css-base.js","webpack:///./~/style-loader/addStyles.js","webpack:///./app/components/tabs/tabs.route.js","webpack:///./app/components/tabs/tabs.html","webpack:///./app/components/tabs/tabs.scss?ec1b","webpack:///./app/components/tabs/tabs.scss","webpack:///./app/store/index.js","webpack:///./app/store/consts.js","webpack:///./app/store/monkeys/subscriptionData.js","webpack:///./app/store/monkeys/loaders/subscriptionData.js","webpack:///./app/api/mockApi.js","webpack:///./app/config.js","webpack:///./app/api/mocks/locationsData.js","webpack:///./app/api/mocks/locations.js","webpack:///./~/baobab/dist/baobab.js","webpack:///./~/emmett/emmett.js","webpack:///./~/baobab/dist/cursor.js","webpack:///./~/baobab/dist/monkey.js","webpack:///./~/baobab/dist/type.js","webpack:///./~/baobab/dist/update.js","webpack:///./~/baobab/dist/helpers.js","webpack:///./~/baobab/dist/watcher.js","webpack:///./app/scss/index.scss?3a4b","webpack:///./app/scss/index.scss"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","_components","_components2","_index","angular","stateModule","run","$ionicPlatform","ready","window","cordova","plugins","Keyboard","hideKeyboardAccessoryBar","disableScroll","StatusBar","styleDefault","config","$stateProvider","$urlRouterProvider","otherwise","$ionicConfigProvider","tabs","position","Object","defineProperty","value","_tabs","_tabs2","name","_dashboard","_dashboard2","_dashboard3","_dashboard4","state","url","views","tab-dash","template","controller","_subscriptionIds","locationModalTemplate","scope","$timeout","$ionicModal","AppState","subscriptionSelector","select","locationSelector","currentData","get","on","e","forecastData","data","locations","getLocationsForModal","existingIds","getSubscriptionIdsFromStorage","filter","d","indexOf","modal","fromTemplate","animation","showAddLocation","show","closeModal","hide","removeLocation","idsSelector","existingIDs","set","l","removeFromSubscriptionIdsStorage","addLocation","location","push","addToSubscriptionIdsStorage","existingSubscriptionIds","localStorage","getItem","JSON","parse","setItem","stringify","content","locals","list","toString","result","i","this","length","item","join","mediaQuery","alreadyImportedModules","addStylesToDom","styles","options","domStyle","stylesInDom","refs","j","parts","addStyle","listToStyles","newStyles","css","media","sourceMap","part","insertStyleElement","styleElement","head","getHeadElement","lastStyleElementInsertedAtTop","styleElementsInsertedAtTop","insertAt","nextSibling","insertBefore","appendChild","firstChild","Error","removeStyleElement","parentNode","removeChild","idx","splice","createStyleElement","document","createElement","type","createLinkElement","linkElement","rel","update","remove","singleton","styleIndex","singletonCounter","singletonElement","applyToSingletonTag","bind","URL","createObjectURL","revokeObjectURL","Blob","btoa","updateLink","href","applyToTag","newObj","index","styleSheet","cssText","replaceText","cssNode","createTextNode","childNodes","setAttribute","unescape","encodeURIComponent","blob","oldSrc","memoize","fn","memo","apply","arguments","isOldIE","test","navigator","userAgent","toLowerCase","getElementsByTagName","newList","mayRemove","textStore","replacement","Boolean","abstract","undefined","_consts","_subscriptionData","_subscriptionData2","_mockApi","Baobab","tree","subscriptions","ids","default_subscriptions","subscribedLocations","immutable","fetchLocations","then","factory","$rootScope","setTimeout","$apply","monkey","cursors","map","loading","r","dataSelector","fetchLocationsData","forEach","_config","locationsData","Promise","resolve","apiUrl","time","wind","windDirection","temp","wave","waveDirection","_interopRequireWildcard","key","prototype","hasOwnProperty","_classCallCheck","instance","Constructor","TypeError","_inherits","subClass","superClass","create","constructor","enumerable","writable","configurable","setPrototypeOf","__proto__","hashPath","path","step","_type2","object","uniqid","_createClass","defineProperties","target","props","descriptor","protoProps","staticProps","_get","_x3","_x4","_x5","_again","property","receiver","Function","desc","getOwnPropertyDescriptor","getter","parent","getPrototypeOf","_emmett","_emmett2","_cursor","_cursor2","_monkey","_watcher","_watcher2","_type","_update2","_update3","_helpers","helpers","arrayFrom","coercePath","deepFreeze","getIn","makeError","deepClone","deepMerge","shallowClone","shallowMerge","DEFAULTS","autoCommit","asynchronous","lazyMonkeys","persistent","pure","validate","validationBehavior","_Emitter","initialData","opts","_this","array","_identity","_cursors","_future","_transaction","_affectedPathsIndex","_monkeys","_previousData","_data","root","release","bootstrap","_refreshMonkeys","validationError","error","node","operation","_this2","clean","Monkey","k","concat","walk","MonkeyDefinition","monkeyInstance","definition","monkeysNode","affectedPaths","_options","behavior","emit","hash","cursor","_this3","operationType","_getIn","solvedPath","exists","monkeyPath","realOperation","currentNode","affectedPath","commit","clearTimeout","keys","h","split","slice","transaction","previousData","paths","mapping","kill","serialize","_len","args","Array","_key","dynamicNode","Cursor","VERSION","o1","o2","o","isPlainObject","v","isArray","RegExp","forIn","symbols","getOwnPropertySymbols","a","__allowedOptions","once","__order","Emitter","_enabled","unbindAll","_handlers","_handlersAll","_handlersComplex","b","event","eArray","handlersList","bindingObject","order","pattern","li","off","events","n","listeners","handlers","complex","search","sort","handler","onces","disable","enable","version","checkPossibilityOfDynamicTraversal","method","makeSetter","typeChecker","INTRANSITIVE_SETTERS","fullPath","_archive","killed","recording","undoing","_dynamicPath","dynamicPath","_monkeyPath","_writeHandler","_ref","solveUpdate","_getComparedPaths","fireUpdate","self","eventData","archive","add","_updateHandler","_event$data","comparedPaths","bound","_lazyBind","before","additionalPaths","relatedPaths","primitive","isRoot","isLeaf","last","isNaN","up","_get2","monkeys","dropComputedData","projection","maxRecords","Infinity","Archive","steps","record","back","clear","Symbol","iterator","next","done","unset","pop","shift","splicer","monkeyType","monkeyDefinition","offset","hasDynamicPaths","some","pathInTree","relative","solveRelativePath","reduce","acc","depPaths","writeListener","concerned","recursiveListener","_ref2","_ref2$data","recursive","isRecursive","accumulatedPaths","relatedMonkey","deps","project","lazyGetter","def","cache","alreadyComputed","isLazyGetter","mutableLeaf","monkeyListener","anyOf","allowed","t","Date","Map","Set","string","number","ALLOWED_FOR_PATH","every","subpath","propertyKey","watcherMapping","VALID_OPERATIONS","_toConsumableArray","arr","arr2","from","err","expectedTarget","_operation$options","operationOptions","dummy","dummyPath","currentPath","s","unshift","freeze","global","newArray","culprit","decorator","cloneRegexp","re","source","flags","multiline","ignoreCase","sticky","unicode","cloner","deep","ArrayBuffer","getTime","compare","description","ok","freezer","isFrozen","NOT_FOUND_OBJECT","message","merger","objects","base","to","startIndex","nb","Math","max","_len2","elements","_key2","noop","size","records","isFreezeSupported","_x","_x2","Watcher","refresh","watchedPaths","getWatchedPaths","rawPaths","cp"],"mappings":"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","file":"bundle.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _components = __webpack_require__(1);\n\t\n\tvar _components2 = _interopRequireDefault(_components);\n\t\n\tvar _index = __webpack_require__(17);\n\t\n\t__webpack_require__(33);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tangular.module('app', ['ionic', _components2.default, _index.stateModule]).run(function ($ionicPlatform) {\n\t    $ionicPlatform.ready(function () {\n\t        // Hide the accessory bar by default (remove this to show the accessory bar above the keyboard\n\t        // for form inputs)\n\t        if (window.cordova && window.cordova.plugins && window.cordova.plugins.Keyboard) {\n\t            cordova.plugins.Keyboard.hideKeyboardAccessoryBar(true);\n\t            cordova.plugins.Keyboard.disableScroll(true);\n\t        }\n\t        if (window.StatusBar) {\n\t            // org.apache.cordova.statusbar required\n\t            StatusBar.styleDefault();\n\t        }\n\t    });\n\t}).config(function ($stateProvider, $urlRouterProvider) {\n\t    $urlRouterProvider.otherwise('/tab/dash');\n\t}).config(['$ionicConfigProvider', function ($ionicConfigProvider) {\n\t    $ionicConfigProvider.tabs.position('bottom'); // other values: top\n\t}]);\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _tabs = __webpack_require__(2);\n\t\n\tvar _tabs2 = _interopRequireDefault(_tabs);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = angular.module('app.components', [_tabs2.default]).name;\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _dashboard = __webpack_require__(3);\n\t\n\tvar _dashboard2 = _interopRequireDefault(_dashboard);\n\t\n\tvar _tabs = __webpack_require__(13);\n\t\n\tvar _tabs2 = _interopRequireDefault(_tabs);\n\t\n\t__webpack_require__(15);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = angular.module('app.components.tabs', [_dashboard2.default]).config(_tabs2.default).name;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _dashboard = __webpack_require__(4);\n\t\n\tvar _dashboard2 = _interopRequireDefault(_dashboard);\n\t\n\t__webpack_require__(9);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = angular.module('app.components.tabs.dashboard', []).config(_dashboard2.default).name;\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _dashboard = __webpack_require__(5);\n\t\n\tvar _dashboard2 = _interopRequireDefault(_dashboard);\n\t\n\tvar _dashboard3 = __webpack_require__(8);\n\t\n\tvar _dashboard4 = _interopRequireDefault(_dashboard3);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = function ($stateProvider, $urlRouterProvider) {\n\t    $stateProvider.state('tab.dash', {\n\t        url: '/dash',\n\t        views: {\n\t            'tab-dash': {\n\t                template: _dashboard4.default,\n\t                controller: _dashboard2.default\n\t            }\n\t        }\n\t    });\n\t};\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _subscriptionIds = __webpack_require__(6);\n\t\n\tvar locationModalTemplate = __webpack_require__(7);\n\t\n\texports.default = ['$scope', '$timeout', '$ionicModal', 'AppState', function (scope, $timeout, $ionicModal, AppState) {\n\t    var subscriptionSelector = AppState.select('subscriptions', 'subscribedLocations');\n\t    var locationSelector = AppState.select('locations');\n\t    scope.currentData = subscriptionSelector.get();\n\t\n\t    subscriptionSelector.on('update', function (e) {\n\t        scope.currentData = scope.forecastData = e.data.currentData;\n\t    });\n\t\n\t    locationSelector.on('update', function (e) {\n\t        scope.locations = e.data.currentData;\n\t    });\n\t\n\t    scope.getLocationsForModal = function () {\n\t        if (!scope.locations) return [];\n\t        var existingIds = (0, _subscriptionIds.getSubscriptionIdsFromStorage)();\n\t        return scope.locations.filter(function (d) {\n\t            return existingIds.indexOf(d.id) == -1;\n\t        });\n\t    };\n\t\n\t    scope.modal = $ionicModal.fromTemplate(locationModalTemplate, {\n\t        scope: scope,\n\t        animation: 'none'\n\t    });\n\t\n\t    scope.showAddLocation = function () {\n\t        scope.modal.show();\n\t    };\n\t\n\t    scope.closeModal = function () {\n\t        scope.modal.hide();\n\t    };\n\t\n\t    scope.removeLocation = function (id) {\n\t        var idsSelector = AppState.select([\"subscriptions\", \"ids\"]);\n\t        var existingIDs = idsSelector.get();\n\t        idsSelector.set(existingIDs.filter(function (l) {\n\t            return l != id;\n\t        }));\n\t        (0, _subscriptionIds.removeFromSubscriptionIdsStorage)(id);\n\t    };\n\t\n\t    scope.addLocation = function (location) {\n\t        AppState.push([\"subscriptions\", \"ids\"], location.id);\n\t        (0, _subscriptionIds.addToSubscriptionIdsStorage)(location.id);\n\t        scope.modal.hide();\n\t    };\n\t}];\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\tvar addToSubscriptionIdsStorage = exports.addToSubscriptionIdsStorage = function addToSubscriptionIdsStorage(id) {\n\t    var existingSubscriptionIds = [];\n\t    if (window.localStorage.getItem(\"subscriptionIds\")) {\n\t        existingSubscriptionIds = JSON.parse(window.localStorage.getItem(\"subscriptionIds\"));\n\t    }\n\t    existingSubscriptionIds.push(id);\n\t    window.localStorage.setItem(\"subscriptionIds\", JSON.stringify(existingSubscriptionIds));\n\t};\n\t\n\tvar removeFromSubscriptionIdsStorage = exports.removeFromSubscriptionIdsStorage = function removeFromSubscriptionIdsStorage(id) {\n\t    var existingSubscriptionIds = [];\n\t    if (window.localStorage.getItem(\"subscriptionIds\")) {\n\t        existingSubscriptionIds = JSON.parse(window.localStorage.getItem(\"subscriptionIds\"));\n\t    }\n\t    existingSubscriptionIds = existingSubscriptionIds.filter(function (l) {\n\t        return l != id;\n\t    });\n\t\n\t    window.localStorage.setItem(\"subscriptionIds\", JSON.stringify(existingSubscriptionIds));\n\t};\n\t\n\tvar getSubscriptionIdsFromStorage = exports.getSubscriptionIdsFromStorage = function getSubscriptionIdsFromStorage() {\n\t    if (window.localStorage.getItem(\"subscriptionIds\")) {\n\t        return JSON.parse(window.localStorage.getItem(\"subscriptionIds\"));\n\t    }\n\t    return [];\n\t};\n\n/***/ },\n/* 7 */\n/***/ function(module, exports) {\n\n\tmodule.exports = \"<ion-modal-view> <ion-header-bar> <h1 class=title>הוספת ספוט</h1> <button class=\\\"button icon icon-left ion-ios-close-outline\\\" ng-click=closeModal()></button> </ion-header-bar> <ion-content> <ion-list> <ion-item ng-click=addLocation(loc) ng-repeat=\\\"loc in getLocationsForModal()\\\"> {{ loc.name }} </ion-item> </ion-list> </ion-content> </ion-modal-view>\";\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\tmodule.exports = \"<ion-view view-title=Dashboard> <ion-nav-title> WEATHER GONG </ion-nav-title> <ion-content class=padding id=dashboard-page-container> <div class=current-weather-container> <h3>מצב הים</h3> <div class=\\\"row header\\\"> <div class=\\\"col iconCol\\\"></div> <div class=col>ספוט</div> <div class=col>שעה</div> <div class=col>עוצמת רוח</div> <div class=\\\"col iconCol\\\">כיוון</div> <div class=col>שעה</div> <div class=col>גובה גל</div> <div class=\\\"col iconCol\\\">כיוון</div> <div class=\\\"col iconCol\\\"></div> </div> <div class=row ng-repeat=\\\"row in currentData\\\"> <div class=\\\"col iconCol\\\"> <button class=\\\"button icon ion-ios-minus-outline\\\" ng-click=removeLocation(row.id)></button> </div> <div class=col>{{ row.location }}</div> <div class=col>{{ row.time }}</div> <div class=col>{{ row.wind }}</div> <div class=\\\"col iconCol\\\"> <i class=\\\"icon arrow ion-arrow-up-c {{row.windDirection}}\\\"></i> </div> <div class=col>{{ row.temperature }}</div> <div class=col>{{ row.wave }}</div> <div class=\\\"col iconCol\\\"> <i class=\\\"icon arrow ion-arrow-up-c {{row.waveDirection}}\\\"></i> </div> <div class=\\\"col iconCol\\\"> <button class=\\\"icon arrow ion-ios-camera-outline\\\"/></div> </div> <div class=row> <div class=col> <button class=\\\"button icon ion-ios-plus-outline\\\" ng-click=showAddLocation()></button> </div> </div> </div> <div class=forecast-container> <h3>תחזית (מצב שיא)</h3> <div class=\\\"row header\\\"> <div class=\\\"col iconCol\\\"></div> <div class=col>ספוט</div> <div class=col>שעה</div> <div class=col>עוצמת רוח</div> <div class=\\\"col iconCol\\\">כיוון</div> <div class=col>שעה</div> <div class=col>גובה גל</div> <div class=\\\"col iconCol\\\">כיוון</div> </div> <div class=row ng-repeat=\\\"row in forecastData\\\"> <div class=\\\"col iconCol\\\"> <button class=\\\"button icon ion-ios-minus-outline\\\" ng-click=removeLocation(row.id)></button> </div> <div class=col>{{ row.location }}</div> <div class=col>{{ row.time }}</div> <div class=col>{{ row.wind }}</div> <div class=\\\"col iconCol\\\"> <i class=\\\"icon arrow ion-arrow-up-c {{row.windDirection}}\\\"></i> </div> <div class=col>{{ row.temperature }}</div> <div class=col>{{ row.wave }}</div> <div class=\\\"col iconCol\\\"> <i class=\\\"icon arrow ion-arrow-up-c {{row.waveDirection}}\\\"></i> </div> </div> <div class=row> <div class=col> <button class=\\\"button icon ion-ios-plus-outline\\\" ng-click=showAddLocation()></button> </div> </div> </div> </ion-content> </ion-view>\";\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// style-loader: Adds some css to the DOM by adding a <style> tag\n\t\n\t// load the styles\n\tvar content = __webpack_require__(10);\n\tif(typeof content === 'string') content = [[module.id, content, '']];\n\t// add the styles to the DOM\n\tvar update = __webpack_require__(12)(content, {});\n\tif(content.locals) module.exports = content.locals;\n\t// Hot Module Replacement\n\tif(false) {\n\t\t// When the styles change, update the <style> tags\n\t\tif(!content.locals) {\n\t\t\tmodule.hot.accept(\"!!./../../../../node_modules/css-loader/index.js!./../../../../node_modules/sass-loader/index.js!./dashboard.scss\", function() {\n\t\t\t\tvar newContent = require(\"!!./../../../../node_modules/css-loader/index.js!./../../../../node_modules/sass-loader/index.js!./dashboard.scss\");\n\t\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\t\tupdate(newContent);\n\t\t\t});\n\t\t}\n\t\t// When the module is disposed, remove the <style> tags\n\t\tmodule.hot.dispose(function() { update(); });\n\t}\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(11)();\n\t// imports\n\t\n\t\n\t// module\n\texports.push([module.id, \"#dashboard-page-container .scroll{direction:rtl}#dashboard-page-container .scroll>div{margin-bottom:30px;word-wrap:normal}#dashboard-page-container .scroll>div .col{text-align:right;font-size:11px;direction:ltr}#dashboard-page-container .scroll>div .col .button{background:transparent;min-height:auto;min-width:auto}#dashboard-page-container .scroll>div .col .button.icon:before{font-size:15px;line-height:20px}#dashboard-page-container .scroll>div .col button.icon{font-size:21px;line-height:0;background:none;padding:0;margin:0;outline:0;border:none}\", \"\"]);\n\t\n\t// exports\n\n\n/***/ },\n/* 11 */\n/***/ function(module, exports) {\n\n\t/*\r\n\t\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\t\tAuthor Tobias Koppers @sokra\r\n\t*/\r\n\t// css base code, injected by the css-loader\r\n\tmodule.exports = function() {\r\n\t\tvar list = [];\r\n\t\r\n\t\t// return the list of modules as css string\r\n\t\tlist.toString = function toString() {\r\n\t\t\tvar result = [];\r\n\t\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\t\tvar item = this[i];\r\n\t\t\t\tif(item[2]) {\r\n\t\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\r\n\t\t\t\t} else {\r\n\t\t\t\t\tresult.push(item[1]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn result.join(\"\");\r\n\t\t};\r\n\t\r\n\t\t// import a list of modules into the list\r\n\t\tlist.i = function(modules, mediaQuery) {\r\n\t\t\tif(typeof modules === \"string\")\r\n\t\t\t\tmodules = [[null, modules, \"\"]];\r\n\t\t\tvar alreadyImportedModules = {};\r\n\t\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\t\tvar id = this[i][0];\r\n\t\t\t\tif(typeof id === \"number\")\r\n\t\t\t\t\talreadyImportedModules[id] = true;\r\n\t\t\t}\r\n\t\t\tfor(i = 0; i < modules.length; i++) {\r\n\t\t\t\tvar item = modules[i];\r\n\t\t\t\t// skip already imported module\r\n\t\t\t\t// this implementation is not 100% perfect for weird media query combinations\r\n\t\t\t\t//  when a module is imported multiple times with different media queries.\r\n\t\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\r\n\t\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\r\n\t\t\t\t\tif(mediaQuery && !item[2]) {\r\n\t\t\t\t\t\titem[2] = mediaQuery;\r\n\t\t\t\t\t} else if(mediaQuery) {\r\n\t\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\r\n\t\t\t\t\t}\r\n\t\t\t\t\tlist.push(item);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t\treturn list;\r\n\t};\r\n\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*\r\n\t\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\t\tAuthor Tobias Koppers @sokra\r\n\t*/\r\n\tvar stylesInDom = {},\r\n\t\tmemoize = function(fn) {\r\n\t\t\tvar memo;\r\n\t\t\treturn function () {\r\n\t\t\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\r\n\t\t\t\treturn memo;\r\n\t\t\t};\r\n\t\t},\r\n\t\tisOldIE = memoize(function() {\r\n\t\t\treturn /msie [6-9]\\b/.test(window.navigator.userAgent.toLowerCase());\r\n\t\t}),\r\n\t\tgetHeadElement = memoize(function () {\r\n\t\t\treturn document.head || document.getElementsByTagName(\"head\")[0];\r\n\t\t}),\r\n\t\tsingletonElement = null,\r\n\t\tsingletonCounter = 0,\r\n\t\tstyleElementsInsertedAtTop = [];\r\n\t\r\n\tmodule.exports = function(list, options) {\r\n\t\tif(true) {\r\n\t\t\tif(typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\r\n\t\t}\r\n\t\r\n\t\toptions = options || {};\r\n\t\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\r\n\t\t// tags it will allow on a page\r\n\t\tif (typeof options.singleton === \"undefined\") options.singleton = isOldIE();\r\n\t\r\n\t\t// By default, add <style> tags to the bottom of <head>.\r\n\t\tif (typeof options.insertAt === \"undefined\") options.insertAt = \"bottom\";\r\n\t\r\n\t\tvar styles = listToStyles(list);\r\n\t\taddStylesToDom(styles, options);\r\n\t\r\n\t\treturn function update(newList) {\r\n\t\t\tvar mayRemove = [];\r\n\t\t\tfor(var i = 0; i < styles.length; i++) {\r\n\t\t\t\tvar item = styles[i];\r\n\t\t\t\tvar domStyle = stylesInDom[item.id];\r\n\t\t\t\tdomStyle.refs--;\r\n\t\t\t\tmayRemove.push(domStyle);\r\n\t\t\t}\r\n\t\t\tif(newList) {\r\n\t\t\t\tvar newStyles = listToStyles(newList);\r\n\t\t\t\taddStylesToDom(newStyles, options);\r\n\t\t\t}\r\n\t\t\tfor(var i = 0; i < mayRemove.length; i++) {\r\n\t\t\t\tvar domStyle = mayRemove[i];\r\n\t\t\t\tif(domStyle.refs === 0) {\r\n\t\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++)\r\n\t\t\t\t\t\tdomStyle.parts[j]();\r\n\t\t\t\t\tdelete stylesInDom[domStyle.id];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n\t\r\n\tfunction addStylesToDom(styles, options) {\r\n\t\tfor(var i = 0; i < styles.length; i++) {\r\n\t\t\tvar item = styles[i];\r\n\t\t\tvar domStyle = stylesInDom[item.id];\r\n\t\t\tif(domStyle) {\r\n\t\t\t\tdomStyle.refs++;\r\n\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\r\n\t\t\t\t\tdomStyle.parts[j](item.parts[j]);\r\n\t\t\t\t}\r\n\t\t\t\tfor(; j < item.parts.length; j++) {\r\n\t\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tvar parts = [];\r\n\t\t\t\tfor(var j = 0; j < item.parts.length; j++) {\r\n\t\t\t\t\tparts.push(addStyle(item.parts[j], options));\r\n\t\t\t\t}\r\n\t\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction listToStyles(list) {\r\n\t\tvar styles = [];\r\n\t\tvar newStyles = {};\r\n\t\tfor(var i = 0; i < list.length; i++) {\r\n\t\t\tvar item = list[i];\r\n\t\t\tvar id = item[0];\r\n\t\t\tvar css = item[1];\r\n\t\t\tvar media = item[2];\r\n\t\t\tvar sourceMap = item[3];\r\n\t\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\r\n\t\t\tif(!newStyles[id])\r\n\t\t\t\tstyles.push(newStyles[id] = {id: id, parts: [part]});\r\n\t\t\telse\r\n\t\t\t\tnewStyles[id].parts.push(part);\r\n\t\t}\r\n\t\treturn styles;\r\n\t}\r\n\t\r\n\tfunction insertStyleElement(options, styleElement) {\r\n\t\tvar head = getHeadElement();\r\n\t\tvar lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];\r\n\t\tif (options.insertAt === \"top\") {\r\n\t\t\tif(!lastStyleElementInsertedAtTop) {\r\n\t\t\t\thead.insertBefore(styleElement, head.firstChild);\r\n\t\t\t} else if(lastStyleElementInsertedAtTop.nextSibling) {\r\n\t\t\t\thead.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);\r\n\t\t\t} else {\r\n\t\t\t\thead.appendChild(styleElement);\r\n\t\t\t}\r\n\t\t\tstyleElementsInsertedAtTop.push(styleElement);\r\n\t\t} else if (options.insertAt === \"bottom\") {\r\n\t\t\thead.appendChild(styleElement);\r\n\t\t} else {\r\n\t\t\tthrow new Error(\"Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.\");\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction removeStyleElement(styleElement) {\r\n\t\tstyleElement.parentNode.removeChild(styleElement);\r\n\t\tvar idx = styleElementsInsertedAtTop.indexOf(styleElement);\r\n\t\tif(idx >= 0) {\r\n\t\t\tstyleElementsInsertedAtTop.splice(idx, 1);\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction createStyleElement(options) {\r\n\t\tvar styleElement = document.createElement(\"style\");\r\n\t\tstyleElement.type = \"text/css\";\r\n\t\tinsertStyleElement(options, styleElement);\r\n\t\treturn styleElement;\r\n\t}\r\n\t\r\n\tfunction createLinkElement(options) {\r\n\t\tvar linkElement = document.createElement(\"link\");\r\n\t\tlinkElement.rel = \"stylesheet\";\r\n\t\tinsertStyleElement(options, linkElement);\r\n\t\treturn linkElement;\r\n\t}\r\n\t\r\n\tfunction addStyle(obj, options) {\r\n\t\tvar styleElement, update, remove;\r\n\t\r\n\t\tif (options.singleton) {\r\n\t\t\tvar styleIndex = singletonCounter++;\r\n\t\t\tstyleElement = singletonElement || (singletonElement = createStyleElement(options));\r\n\t\t\tupdate = applyToSingletonTag.bind(null, styleElement, styleIndex, false);\r\n\t\t\tremove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);\r\n\t\t} else if(obj.sourceMap &&\r\n\t\t\ttypeof URL === \"function\" &&\r\n\t\t\ttypeof URL.createObjectURL === \"function\" &&\r\n\t\t\ttypeof URL.revokeObjectURL === \"function\" &&\r\n\t\t\ttypeof Blob === \"function\" &&\r\n\t\t\ttypeof btoa === \"function\") {\r\n\t\t\tstyleElement = createLinkElement(options);\r\n\t\t\tupdate = updateLink.bind(null, styleElement);\r\n\t\t\tremove = function() {\r\n\t\t\t\tremoveStyleElement(styleElement);\r\n\t\t\t\tif(styleElement.href)\r\n\t\t\t\t\tURL.revokeObjectURL(styleElement.href);\r\n\t\t\t};\r\n\t\t} else {\r\n\t\t\tstyleElement = createStyleElement(options);\r\n\t\t\tupdate = applyToTag.bind(null, styleElement);\r\n\t\t\tremove = function() {\r\n\t\t\t\tremoveStyleElement(styleElement);\r\n\t\t\t};\r\n\t\t}\r\n\t\r\n\t\tupdate(obj);\r\n\t\r\n\t\treturn function updateStyle(newObj) {\r\n\t\t\tif(newObj) {\r\n\t\t\t\tif(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)\r\n\t\t\t\t\treturn;\r\n\t\t\t\tupdate(obj = newObj);\r\n\t\t\t} else {\r\n\t\t\t\tremove();\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n\t\r\n\tvar replaceText = (function () {\r\n\t\tvar textStore = [];\r\n\t\r\n\t\treturn function (index, replacement) {\r\n\t\t\ttextStore[index] = replacement;\r\n\t\t\treturn textStore.filter(Boolean).join('\\n');\r\n\t\t};\r\n\t})();\r\n\t\r\n\tfunction applyToSingletonTag(styleElement, index, remove, obj) {\r\n\t\tvar css = remove ? \"\" : obj.css;\r\n\t\r\n\t\tif (styleElement.styleSheet) {\r\n\t\t\tstyleElement.styleSheet.cssText = replaceText(index, css);\r\n\t\t} else {\r\n\t\t\tvar cssNode = document.createTextNode(css);\r\n\t\t\tvar childNodes = styleElement.childNodes;\r\n\t\t\tif (childNodes[index]) styleElement.removeChild(childNodes[index]);\r\n\t\t\tif (childNodes.length) {\r\n\t\t\t\tstyleElement.insertBefore(cssNode, childNodes[index]);\r\n\t\t\t} else {\r\n\t\t\t\tstyleElement.appendChild(cssNode);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction applyToTag(styleElement, obj) {\r\n\t\tvar css = obj.css;\r\n\t\tvar media = obj.media;\r\n\t\r\n\t\tif(media) {\r\n\t\t\tstyleElement.setAttribute(\"media\", media)\r\n\t\t}\r\n\t\r\n\t\tif(styleElement.styleSheet) {\r\n\t\t\tstyleElement.styleSheet.cssText = css;\r\n\t\t} else {\r\n\t\t\twhile(styleElement.firstChild) {\r\n\t\t\t\tstyleElement.removeChild(styleElement.firstChild);\r\n\t\t\t}\r\n\t\t\tstyleElement.appendChild(document.createTextNode(css));\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction updateLink(linkElement, obj) {\r\n\t\tvar css = obj.css;\r\n\t\tvar sourceMap = obj.sourceMap;\r\n\t\r\n\t\tif(sourceMap) {\r\n\t\t\t// http://stackoverflow.com/a/26603875\r\n\t\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\r\n\t\t}\r\n\t\r\n\t\tvar blob = new Blob([css], { type: \"text/css\" });\r\n\t\r\n\t\tvar oldSrc = linkElement.href;\r\n\t\r\n\t\tlinkElement.href = URL.createObjectURL(blob);\r\n\t\r\n\t\tif(oldSrc)\r\n\t\t\tURL.revokeObjectURL(oldSrc);\r\n\t}\r\n\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\texports.default = function ($stateProvider, $urlRouterProvider) {\n\t    $stateProvider\n\t\n\t    // setup an abstract state for the tabs directive\n\t    .state('tab', {\n\t        url: '/tab',\n\t        abstract: true,\n\t        template: __webpack_require__(14)\n\t    });\n\t};\n\n/***/ },\n/* 14 */\n/***/ function(module, exports) {\n\n\tmodule.exports = \"<ion-tabs class=\\\"tabs-icon-top tabs-color-active-positive\\\"> <ion-tab title=תחזית href=#/tab/chats class=small> <ion-nav-view name=tab-chats></ion-nav-view> </ion-tab> <ion-tab title=דיווחים href=#/tab/reports class=small> <ion-nav-view name=tab-reports></ion-nav-view> </ion-tab> <ion-tab title=\\\"זמן אמת\\\" href=#/tab/account> <ion-nav-view name=tab-account></ion-nav-view> </ion-tab> <ion-tab title=\\\"ההתראות שלי\\\" href=#/tab/account> <ion-nav-view name=tab-account></ion-nav-view> </ion-tab> <ion-tab icon-off=ion-ios-home icon-on=ion-ios-home href=#/tab/dash> <ion-nav-view name=tab-dash></ion-nav-view> </ion-tab> </ion-tabs>\";\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// style-loader: Adds some css to the DOM by adding a <style> tag\n\t\n\t// load the styles\n\tvar content = __webpack_require__(16);\n\tif(typeof content === 'string') content = [[module.id, content, '']];\n\t// add the styles to the DOM\n\tvar update = __webpack_require__(12)(content, {});\n\tif(content.locals) module.exports = content.locals;\n\t// Hot Module Replacement\n\tif(false) {\n\t\t// When the styles change, update the <style> tags\n\t\tif(!content.locals) {\n\t\t\tmodule.hot.accept(\"!!./../../../node_modules/css-loader/index.js!./../../../node_modules/sass-loader/index.js!./tabs.scss\", function() {\n\t\t\t\tvar newContent = require(\"!!./../../../node_modules/css-loader/index.js!./../../../node_modules/sass-loader/index.js!./tabs.scss\");\n\t\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\t\tupdate(newContent);\n\t\t\t});\n\t\t}\n\t\t// When the module is disposed, remove the <style> tags\n\t\tmodule.hot.dispose(function() { update(); });\n\t}\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(11)();\n\t// imports\n\t\n\t\n\t// module\n\texports.push([module.id, \".tabs-icon-top>.tabs .tab-item{flex:1;font-size:11px;display:flex;align-items:center;justify-content:center}\", \"\"]);\n\t\n\t// exports\n\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.state = exports.stateModule = undefined;\n\t\n\tvar _consts = __webpack_require__(18);\n\t\n\tvar _subscriptionData = __webpack_require__(19);\n\t\n\tvar _subscriptionData2 = _interopRequireDefault(_subscriptionData);\n\t\n\tvar _mockApi = __webpack_require__(21);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar Baobab = __webpack_require__(25);\n\tvar tree = new Baobab({\n\t    locations: {},\n\t    subscriptions: {\n\t        ids: window.localStorage.getItem(\"subscriptionIds\") ? JSON.parse(window.localStorage.getItem(\"subscriptionIds\")) : _consts.default_subscriptions,\n\t        data: [],\n\t        subscribedLocations: _subscriptionData2.default\n\t    }\n\t}, {\n\t    immutable: false\n\t});\n\t\n\t(0, _mockApi.fetchLocations)().then(function (result) {\n\t    tree.set(\"locations\", result);\n\t});\n\t\n\tvar stateModule = exports.stateModule = angular.module('app.store', []).factory('AppState', ['$rootScope', function ($rootScope) {\n\t    tree.on('update', function () {\n\t        setTimeout(function () {\n\t            $rootScope.$apply();\n\t        }, 0);\n\t    });\n\t    return tree;\n\t}]).name;\n\t\n\tvar state = exports.state = tree;\n\n/***/ },\n/* 18 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\tvar default_subscriptions = exports.default_subscriptions = [];\n\n/***/ },\n/* 19 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _subscriptionData = __webpack_require__(20);\n\t\n\tvar _subscriptionData2 = _interopRequireDefault(_subscriptionData);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar Baobab = __webpack_require__(25);\n\tvar monkey = Baobab.monkey;\n\texports.default = monkey({\n\t    cursors: {\n\t        ids: ['subscriptions', 'ids'],\n\t        data: ['subscriptions', 'data']\n\t    },\n\t    get: function get(state) {\n\t        var result = state.ids.map(function (id) {\n\t            var data = state.data[id];\n\t            return data || { id: id, loading: true };\n\t        });\n\t        (0, _subscriptionData2.default)(result.filter(function (r) {\n\t            return r.loading;\n\t        }));\n\t        return result;\n\t    }\n\t});\n\n/***/ },\n/* 20 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _index = __webpack_require__(17);\n\t\n\tvar _mockApi = __webpack_require__(21);\n\t\n\texports.default = function (ids) {\n\t    if (ids.length == 0) return null;\n\t    var dataSelector = _index.state.select('subscriptions', 'data');\n\t    (0, _mockApi.fetchLocationsData)(ids).then(function (data) {\n\t        data.forEach(function (d) {\n\t            dataSelector.set(d.id, d);\n\t        });\n\t    });\n\t};\n\n/***/ },\n/* 21 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.fetchLocations = exports.fetchLocationsData = undefined;\n\t\n\tvar _config = __webpack_require__(22);\n\t\n\tvar _config2 = _interopRequireDefault(_config);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar locationsData = __webpack_require__(23);\n\tvar locations = __webpack_require__(24);\n\tvar fetchLocationsData = exports.fetchLocationsData = function fetchLocationsData(ids) {\n\t    return new Promise(function (resolve) {\n\t        resolve(locationsData);\n\t    });\n\t};\n\t\n\tvar fetchLocations = exports.fetchLocations = function fetchLocations() {\n\t    return new Promise(function (resolve) {\n\t        resolve(locations);\n\t    });\n\t};\n\n/***/ },\n/* 22 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.default = {\n\t    apiUrl: 'http://some.url.to.api'\n\t};\n\n/***/ },\n/* 23 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tmodule.exports = [{\n\t    \"id\": 1,\n\t    \"location\": \"tel-aviv\",\n\t    \"time\": \"08:00\",\n\t    \"wind\": \"8 Kts\",\n\t    \"windDirection\": \"ne\",\n\t    \"temp\": \"28°\",\n\t    \"wave\": \"0.5/7s\",\n\t    \"waveDirection\": \"nw\"\n\t}, {\n\t    \"id\": 2,\n\t    \"location\": \"haifa\",\n\t    \"time\": \"08:00\",\n\t    \"wind\": \"8 Kts\",\n\t    \"windDirection\": \"w\",\n\t    \"temp\": \"28°\",\n\t    \"wave\": \"0.5/7s\",\n\t    \"waveDirection\": \"e\"\n\t}, {\n\t    \"id\": 3,\n\t    \"location\": \"kineret\",\n\t    \"time\": \"08:00\",\n\t    \"wind\": \"8 Kts\",\n\t    \"windDirection\": \"se\",\n\t    \"temp\": \"28°\",\n\t    \"wave\": \"0.5 / 7sec\",\n\t    \"waveDirection\": \"sw\"\n\t}, {\n\t    \"id\": 4,\n\t    \"location\": \"bat-yam\",\n\t    \"time\": \"08:00\",\n\t    \"wind\": \"8 Kts\",\n\t    \"windDirection\": \"ne\",\n\t    \"temp\": \"28°\",\n\t    \"wave\": \"0.5 / 7sec\",\n\t    \"waveDirection\": \"nw\"\n\t}];\n\n/***/ },\n/* 24 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tmodule.exports = [{ \"id\": 1, \"name\": \"tel-aviv\" }, { \"id\": 2, \"name\": \"haifa\" }, { \"id\": 3, \"name\": \"kineret\" }, { \"id\": 4, \"name\": \"bat-yam\" }];\n\n/***/ },\n/* 25 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Baobab Data Structure\n\t * ======================\n\t *\n\t * A handy data tree with cursors.\n\t */\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\t\n\tvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\t\n\tvar _get = function get(_x3, _x4, _x5) { var _again = true; _function: while (_again) { var object = _x3, property = _x4, receiver = _x5; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x3 = parent; _x4 = property; _x5 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar _emmett = __webpack_require__(26);\n\t\n\tvar _emmett2 = _interopRequireDefault(_emmett);\n\t\n\tvar _cursor = __webpack_require__(27);\n\t\n\tvar _cursor2 = _interopRequireDefault(_cursor);\n\t\n\tvar _monkey = __webpack_require__(28);\n\t\n\tvar _watcher = __webpack_require__(32);\n\t\n\tvar _watcher2 = _interopRequireDefault(_watcher);\n\t\n\tvar _type = __webpack_require__(29);\n\t\n\tvar _type2 = _interopRequireDefault(_type);\n\t\n\tvar _update2 = __webpack_require__(30);\n\t\n\tvar _update3 = _interopRequireDefault(_update2);\n\t\n\tvar _helpers = __webpack_require__(31);\n\t\n\tvar helpers = _interopRequireWildcard(_helpers);\n\t\n\tvar arrayFrom = helpers.arrayFrom;\n\tvar coercePath = helpers.coercePath;\n\tvar deepFreeze = helpers.deepFreeze;\n\tvar getIn = helpers.getIn;\n\tvar makeError = helpers.makeError;\n\tvar deepClone = helpers.deepClone;\n\tvar deepMerge = helpers.deepMerge;\n\tvar shallowClone = helpers.shallowClone;\n\tvar shallowMerge = helpers.shallowMerge;\n\tvar uniqid = helpers.uniqid;\n\t\n\t/**\n\t * Baobab defaults\n\t */\n\tvar DEFAULTS = {\n\t\n\t  // Should the tree handle its transactions on its own?\n\t  autoCommit: true,\n\t\n\t  // Should the transactions be handled asynchronously?\n\t  asynchronous: true,\n\t\n\t  // Should the tree's data be immutable?\n\t  immutable: true,\n\t\n\t  // Should the monkeys be lazy?\n\t  lazyMonkeys: true,\n\t\n\t  // Should the tree be persistent?\n\t  persistent: true,\n\t\n\t  // Should the tree's update be pure?\n\t  pure: true,\n\t\n\t  // Validation specifications\n\t  validate: null,\n\t\n\t  // Validation behavior 'rollback' or 'notify'\n\t  validationBehavior: 'rollback'\n\t};\n\t\n\t/**\n\t * Function returning a string hash from a non-dynamic path expressed as an\n\t * array.\n\t *\n\t * @param  {array}  path - The path to hash.\n\t * @return {string} string - The resultant hash.\n\t */\n\tfunction hashPath(path) {\n\t  return 'λ' + path.map(function (step) {\n\t    if (_type2['default']['function'](step) || _type2['default'].object(step)) return '#' + uniqid() + '#';\n\t\n\t    return step;\n\t  }).join('λ');\n\t}\n\t\n\t/**\n\t * Baobab class\n\t *\n\t * @constructor\n\t * @param {object|array} [initialData={}]    - Initial data passed to the tree.\n\t * @param {object}       [opts]              - Optional options.\n\t * @param {boolean}      [opts.autoCommit]   - Should the tree auto-commit?\n\t * @param {boolean}      [opts.asynchronous] - Should the tree's transactions\n\t *                                             handled asynchronously?\n\t * @param {boolean}      [opts.immutable]    - Should the tree be immutable?\n\t * @param {boolean}      [opts.persistent]   - Should the tree be persistent?\n\t * @param {boolean}      [opts.pure]         - Should the tree be pure?\n\t * @param {function}     [opts.validate]     - Validation function.\n\t * @param {string}       [opts.validationBehaviour] - \"rollback\" or \"notify\".\n\t */\n\t\n\tvar Baobab = (function (_Emitter) {\n\t  _inherits(Baobab, _Emitter);\n\t\n\t  function Baobab(initialData, opts) {\n\t    var _this = this;\n\t\n\t    _classCallCheck(this, Baobab);\n\t\n\t    _get(Object.getPrototypeOf(Baobab.prototype), 'constructor', this).call(this);\n\t\n\t    // Setting initialData to an empty object if no data is provided by use\n\t    if (arguments.length < 1) initialData = {};\n\t\n\t    // Checking whether given initial data is valid\n\t    if (!_type2['default'].object(initialData) && !_type2['default'].array(initialData)) throw makeError('Baobab: invalid data.', { data: initialData });\n\t\n\t    // Merging given options with defaults\n\t    this.options = shallowMerge({}, DEFAULTS, opts);\n\t\n\t    // Disabling immutability & persistence if persistence if disabled\n\t    if (!this.options.persistent) {\n\t      this.options.immutable = false;\n\t      this.options.pure = false;\n\t    }\n\t\n\t    // Privates\n\t    this._identity = '[object Baobab]';\n\t    this._cursors = {};\n\t    this._future = null;\n\t    this._transaction = [];\n\t    this._affectedPathsIndex = {};\n\t    this._monkeys = {};\n\t    this._previousData = null;\n\t    this._data = initialData;\n\t\n\t    // Properties\n\t    this.root = new _cursor2['default'](this, [], 'λ');\n\t    delete this.root.release;\n\t\n\t    // Does the user want an immutable tree?\n\t    if (this.options.immutable) deepFreeze(this._data);\n\t\n\t    // Bootstrapping root cursor's getters and setters\n\t    var bootstrap = function bootstrap(name) {\n\t      _this[name] = function () {\n\t        var r = this.root[name].apply(this.root, arguments);\n\t        return r instanceof _cursor2['default'] ? this : r;\n\t      };\n\t    };\n\t\n\t    ['apply', 'clone', 'concat', 'deepClone', 'deepMerge', 'exists', 'get', 'push', 'merge', 'pop', 'project', 'serialize', 'set', 'shift', 'splice', 'unset', 'unshift'].forEach(bootstrap);\n\t\n\t    // Registering the initial monkeys\n\t    this._refreshMonkeys();\n\t\n\t    // Initial validation\n\t    var validationError = this.validate();\n\t\n\t    if (validationError) throw Error('Baobab: invalid data.', { error: validationError });\n\t  }\n\t\n\t  /**\n\t   * Monkey helper.\n\t   */\n\t\n\t  /**\n\t   * Internal method used to refresh the tree's monkey register on every\n\t   * update.\n\t   * Note 1) For the time being, placing monkeys beneath array nodes is not\n\t   * allowed for performance reasons.\n\t   *\n\t   * @param  {mixed}   node      - The starting node.\n\t   * @param  {array}   path      - The starting node's path.\n\t   * @param  {string}  operation - The operation that lead to a refreshment.\n\t   * @return {Baobab}            - The tree instance for chaining purposes.\n\t   */\n\t\n\t  _createClass(Baobab, [{\n\t    key: '_refreshMonkeys',\n\t    value: function _refreshMonkeys(node, path, operation) {\n\t      var _this2 = this;\n\t\n\t      var clean = function clean(data) {\n\t        var p = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];\n\t\n\t        if (data instanceof _monkey.Monkey) {\n\t          data.release();\n\t          (0, _update3['default'])(_this2._monkeys, p, { type: 'unset' }, {\n\t            immutable: false,\n\t            persistent: false,\n\t            pure: false\n\t          });\n\t\n\t          return;\n\t        }\n\t\n\t        if (_type2['default'].object(data)) {\n\t          for (var k in data) {\n\t            clean(data[k], p.concat(k));\n\t          }\n\t        }\n\t      };\n\t\n\t      var walk = function walk(data) {\n\t        var p = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];\n\t\n\t        // Should we sit a monkey in the tree?\n\t        if (data instanceof _monkey.MonkeyDefinition || data instanceof _monkey.Monkey) {\n\t          var monkeyInstance = new _monkey.Monkey(_this2, p, data instanceof _monkey.Monkey ? data.definition : data);\n\t\n\t          (0, _update3['default'])(_this2._monkeys, p, { type: 'set', value: monkeyInstance }, {\n\t            immutable: false,\n\t            persistent: false,\n\t            pure: false\n\t          });\n\t\n\t          return;\n\t        }\n\t\n\t        // Object iteration\n\t        if (_type2['default'].object(data)) {\n\t          for (var k in data) {\n\t            walk(data[k], p.concat(k));\n\t          }\n\t        }\n\t      };\n\t\n\t      // Walking the whole tree\n\t      if (!arguments.length) {\n\t        walk(this._data);\n\t      } else {\n\t        var monkeysNode = getIn(this._monkeys, path).data;\n\t\n\t        // Is this required that we clean some already existing monkeys?\n\t        if (monkeysNode) clean(monkeysNode, path);\n\t\n\t        // Let's walk the tree only from the updated point\n\t        if (operation !== 'unset') {\n\t          walk(node, path);\n\t        }\n\t      }\n\t\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Method used to validate the tree's data.\n\t     *\n\t     * @return {boolean} - Is the tree valid?\n\t     */\n\t  }, {\n\t    key: 'validate',\n\t    value: function validate(affectedPaths) {\n\t      var _options = this.options;\n\t      var validate = _options.validate;\n\t      var behavior = _options.validationBehavior;\n\t\n\t      if (typeof validate !== 'function') return null;\n\t\n\t      var error = validate.call(this, this._previousData, this._data, affectedPaths || [[]]);\n\t\n\t      if (error instanceof Error) {\n\t\n\t        if (behavior === 'rollback') {\n\t          this._data = this._previousData;\n\t          this._affectedPathsIndex = {};\n\t          this._transaction = [];\n\t          this._previousData = this._data;\n\t        }\n\t\n\t        this.emit('invalid', { error: error });\n\t\n\t        return error;\n\t      }\n\t\n\t      return null;\n\t    }\n\t\n\t    /**\n\t     * Method used to select data within the tree by creating a cursor. Cursors\n\t     * are kept as singletons by the tree for performance and hygiene reasons.\n\t     *\n\t     * Arity (1):\n\t     * @param {path}    path - Path to select in the tree.\n\t     *\n\t     * Arity (*):\n\t     * @param {...step} path - Path to select in the tree.\n\t     *\n\t     * @return {Cursor}      - The resultant cursor.\n\t     */\n\t  }, {\n\t    key: 'select',\n\t    value: function select(path) {\n\t\n\t      // If no path is given, we simply return the root\n\t      path = path || [];\n\t\n\t      // Variadic\n\t      if (arguments.length > 1) path = arrayFrom(arguments);\n\t\n\t      // Checking that given path is valid\n\t      if (!_type2['default'].path(path)) throw makeError('Baobab.select: invalid path.', { path: path });\n\t\n\t      // Casting to array\n\t      path = [].concat(path);\n\t\n\t      // Computing hash (done here because it would be too late to do it in the\n\t      // cursor's constructor since we need to hit the cursors' index first).\n\t      var hash = hashPath(path);\n\t\n\t      // Creating a new cursor or returning the already existing one for the\n\t      // requested path.\n\t      var cursor = this._cursors[hash];\n\t\n\t      if (!cursor) {\n\t        cursor = new _cursor2['default'](this, path, hash);\n\t        this._cursors[hash] = cursor;\n\t      }\n\t\n\t      // Emitting an event to notify that a part of the tree was selected\n\t      this.emit('select', { path: path, cursor: cursor });\n\t      return cursor;\n\t    }\n\t\n\t    /**\n\t     * Method used to update the tree. Updates are simply expressed by a path,\n\t     * dynamic or not, and an operation.\n\t     *\n\t     * This is where path solving should happen and not in the cursor.\n\t     *\n\t     * @param  {path}   path      - The path where we'll apply the operation.\n\t     * @param  {object} operation - The operation to apply.\n\t     * @return {mixed} - Return the result of the update.\n\t     */\n\t  }, {\n\t    key: 'update',\n\t    value: function update(path, operation) {\n\t      var _this3 = this;\n\t\n\t      // Coercing path\n\t      path = coercePath(path);\n\t\n\t      if (!_type2['default'].operationType(operation.type)) throw makeError('Baobab.update: unknown operation type \"' + operation.type + '\".', { operation: operation });\n\t\n\t      // Solving the given path\n\t\n\t      var _getIn = getIn(this._data, path);\n\t\n\t      var solvedPath = _getIn.solvedPath;\n\t      var exists = _getIn.exists;\n\t\n\t      // If we couldn't solve the path, we throw\n\t      if (!solvedPath) throw makeError('Baobab.update: could not solve the given path.', {\n\t        path: solvedPath\n\t      });\n\t\n\t      // Read-only path?\n\t      var monkeyPath = _type2['default'].monkeyPath(this._monkeys, solvedPath);\n\t      if (monkeyPath && solvedPath.length > monkeyPath.length) throw makeError('Baobab.update: attempting to update a read-only path.', {\n\t        path: solvedPath\n\t      });\n\t\n\t      // We don't unset irrelevant paths\n\t      if (operation.type === 'unset' && !exists) return;\n\t\n\t      // If we merge data, we need to acknowledge monkeys\n\t      var realOperation = operation;\n\t      if (/merge/i.test(operation.type)) {\n\t        var monkeysNode = getIn(this._monkeys, solvedPath).data;\n\t\n\t        if (_type2['default'].object(monkeysNode)) {\n\t\n\t          // Cloning the operation not to create weird behavior for the user\n\t          realOperation = shallowClone(realOperation);\n\t\n\t          // Fetching the existing node in the current data\n\t          var currentNode = getIn(this._data, solvedPath).data;\n\t\n\t          if (/deep/i.test(realOperation.type)) realOperation.value = deepMerge({}, deepMerge({}, currentNode, deepClone(monkeysNode)), realOperation.value);else realOperation.value = shallowMerge({}, deepMerge({}, currentNode, deepClone(monkeysNode)), realOperation.value);\n\t        }\n\t      }\n\t\n\t      // Stashing previous data if this is the frame's first update\n\t      if (!this._transaction.length) this._previousData = this._data;\n\t\n\t      // Applying the operation\n\t      var result = (0, _update3['default'])(this._data, solvedPath, realOperation, this.options);\n\t\n\t      var data = result.data;\n\t      var node = result.node;\n\t\n\t      // If because of purity, the update was moot, we stop here\n\t      if (!('data' in result)) return node;\n\t\n\t      // If the operation is push, the affected path is slightly different\n\t      var affectedPath = solvedPath.concat(operation.type === 'push' ? node.length - 1 : []);\n\t\n\t      var hash = hashPath(affectedPath);\n\t\n\t      // Updating data and transaction\n\t      this._data = data;\n\t      this._affectedPathsIndex[hash] = true;\n\t      this._transaction.push(shallowMerge({}, operation, { path: affectedPath }));\n\t\n\t      // Updating the monkeys\n\t      this._refreshMonkeys(node, solvedPath, operation.type);\n\t\n\t      // Emitting a `write` event\n\t      this.emit('write', { path: affectedPath });\n\t\n\t      // Should we let the user commit?\n\t      if (!this.options.autoCommit) return node;\n\t\n\t      // Should we update asynchronously?\n\t      if (!this.options.asynchronous) {\n\t        this.commit();\n\t        return node;\n\t      }\n\t\n\t      // Updating asynchronously\n\t      if (!this._future) this._future = setTimeout(function () {\n\t        return _this3.commit();\n\t      }, 0);\n\t\n\t      // Finally returning the affected node\n\t      return node;\n\t    }\n\t\n\t    /**\n\t     * Method committing the updates of the tree and firing the tree's events.\n\t     *\n\t     * @return {Baobab} - The tree instance for chaining purposes.\n\t     */\n\t  }, {\n\t    key: 'commit',\n\t    value: function commit() {\n\t\n\t      // Do not fire update if the transaction is empty\n\t      if (!this._transaction.length) return this;\n\t\n\t      // Clearing timeout if one was defined\n\t      if (this._future) this._future = clearTimeout(this._future);\n\t\n\t      var affectedPaths = Object.keys(this._affectedPathsIndex).map(function (h) {\n\t        return h !== 'λ' ? h.split('λ').slice(1) : [];\n\t      });\n\t\n\t      // Is the tree still valid?\n\t      var validationError = this.validate(affectedPaths);\n\t\n\t      if (validationError) return this;\n\t\n\t      // Caching to keep original references before we change them\n\t      var transaction = this._transaction,\n\t          previousData = this._previousData;\n\t\n\t      this._affectedPathsIndex = {};\n\t      this._transaction = [];\n\t      this._previousData = this._data;\n\t\n\t      // Emitting update event\n\t      this.emit('update', {\n\t        paths: affectedPaths,\n\t        currentData: this._data,\n\t        transaction: transaction,\n\t        previousData: previousData\n\t      });\n\t\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Method returning a monkey at the given path or else `null`.\n\t     *\n\t     * @param  {path}        path - Path of the monkey to retrieve.\n\t     * @return {Monkey|null}      - The Monkey instance of `null`.\n\t     */\n\t  }, {\n\t    key: 'getMonkey',\n\t    value: function getMonkey(path) {\n\t      path = coercePath(path);\n\t\n\t      var monkey = getIn(this._monkeys, [].concat(path)).data;\n\t\n\t      if (monkey instanceof _monkey.Monkey) return monkey;\n\t\n\t      return null;\n\t    }\n\t\n\t    /**\n\t     * Method used to watch a collection of paths within the tree. Very useful\n\t     * to bind UI components and such to the tree.\n\t     *\n\t     * @param  {object} mapping - Mapping of paths to listen.\n\t     * @return {Cursor}         - The created watcher.\n\t     */\n\t  }, {\n\t    key: 'watch',\n\t    value: function watch(mapping) {\n\t      return new _watcher2['default'](this, mapping);\n\t    }\n\t\n\t    /**\n\t     * Method releasing the tree and its attached data from memory.\n\t     */\n\t  }, {\n\t    key: 'release',\n\t    value: function release() {\n\t      var k = undefined;\n\t\n\t      this.emit('release');\n\t\n\t      delete this.root;\n\t\n\t      delete this._data;\n\t      delete this._previousData;\n\t      delete this._transaction;\n\t      delete this._affectedPathsIndex;\n\t      delete this._monkeys;\n\t\n\t      // Releasing cursors\n\t      for (k in this._cursors) this._cursors[k].release();\n\t      delete this._cursors;\n\t\n\t      // Killing event emitter\n\t      this.kill();\n\t    }\n\t\n\t    /**\n\t     * Overriding the `toJSON` method for convenient use with JSON.stringify.\n\t     *\n\t     * @return {mixed} - Data at cursor.\n\t     */\n\t  }, {\n\t    key: 'toJSON',\n\t    value: function toJSON() {\n\t      return this.serialize();\n\t    }\n\t\n\t    /**\n\t     * Overriding the `toString` method for debugging purposes.\n\t     *\n\t     * @return {string} - The baobab's identity.\n\t     */\n\t  }, {\n\t    key: 'toString',\n\t    value: function toString() {\n\t      return this._identity;\n\t    }\n\t  }]);\n\t\n\t  return Baobab;\n\t})(_emmett2['default']);\n\t\n\texports['default'] = Baobab;\n\tBaobab.monkey = function () {\n\t  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t    args[_key] = arguments[_key];\n\t  }\n\t\n\t  if (!args.length) throw new Error('Baobab.monkey: missing definition.');\n\t\n\t  if (args.length === 1 && typeof args[0] !== 'function') return new _monkey.MonkeyDefinition(args[0]);\n\t\n\t  return new _monkey.MonkeyDefinition(args);\n\t};\n\tBaobab.dynamicNode = Baobab.monkey;\n\t\n\t/**\n\t * Exposing some internals for convenience\n\t */\n\tBaobab.Cursor = _cursor2['default'];\n\tBaobab.MonkeyDefinition = _monkey.MonkeyDefinition;\n\tBaobab.Monkey = _monkey.Monkey;\n\tBaobab.type = _type2['default'];\n\tBaobab.helpers = helpers;\n\t\n\t/**\n\t * Version\n\t */\n\tBaobab.VERSION = '2.3.2';\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 26 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t(function() {\n\t  'use strict';\n\t\n\t  /**\n\t   * Here is the list of every allowed parameter when using Emitter#on:\n\t   * @type {Object}\n\t   */\n\t  var __allowedOptions = {\n\t    once: 'boolean',\n\t    scope: 'object'\n\t  };\n\t\n\t  /**\n\t   * Incremental id used to order event handlers.\n\t   */\n\t  var __order = 0;\n\t\n\t  /**\n\t   * A simple helper to shallowly merge two objects. The second one will \"win\"\n\t   * over the first one.\n\t   *\n\t   * @param  {object}  o1 First target object.\n\t   * @param  {object}  o2 Second target object.\n\t   * @return {object}     Returns the merged object.\n\t   */\n\t  function shallowMerge(o1, o2) {\n\t    var o = {},\n\t        k;\n\t\n\t    for (k in o1) o[k] = o1[k];\n\t    for (k in o2) o[k] = o2[k];\n\t\n\t    return o;\n\t  }\n\t\n\t  /**\n\t   * Is the given variable a plain JavaScript object?\n\t   *\n\t   * @param  {mixed}  v   Target.\n\t   * @return {boolean}    The boolean result.\n\t   */\n\t  function isPlainObject(v) {\n\t    return v &&\n\t           typeof v === 'object' &&\n\t           !Array.isArray(v) &&\n\t           !(v instanceof Function) &&\n\t           !(v instanceof RegExp);\n\t  }\n\t\n\t  /**\n\t   * Iterate over an object that may have ES6 Symbols.\n\t   *\n\t   * @param  {object}   object  Object on which to iterate.\n\t   * @param  {function} fn      Iterator function.\n\t   * @param  {object}   [scope] Optional scope.\n\t   */\n\t  function forIn(object, fn, scope) {\n\t    var symbols,\n\t        k,\n\t        i,\n\t        l;\n\t\n\t    for (k in object)\n\t      fn.call(scope || null, k, object[k]);\n\t\n\t    if (Object.getOwnPropertySymbols) {\n\t      symbols = Object.getOwnPropertySymbols(object);\n\t\n\t      for (i = 0, l = symbols.length; i < l; i++)\n\t        fn.call(scope || null, symbols[i], object[symbols[i]]);\n\t    }\n\t  }\n\t\n\t  /**\n\t   * The emitter's constructor. It initializes the handlers-per-events store and\n\t   * the global handlers store.\n\t   *\n\t   * Emitters are useful for non-DOM events communication. Read its methods\n\t   * documentation for more information about how it works.\n\t   *\n\t   * @return {Emitter}         The fresh new instance.\n\t   */\n\t  var Emitter = function() {\n\t    this._enabled = true;\n\t\n\t    // Dirty trick that will set the necessary properties to the emitter\n\t    this.unbindAll();\n\t  };\n\t\n\t  /**\n\t   * This method unbinds every handlers attached to every or any events. So,\n\t   * these functions will no more be executed when the related events are\n\t   * emitted. If the functions were not bound to the events, nothing will\n\t   * happen, and no error will be thrown.\n\t   *\n\t   * Usage:\n\t   * ******\n\t   * > myEmitter.unbindAll();\n\t   *\n\t   * @return {Emitter}      Returns this.\n\t   */\n\t  Emitter.prototype.unbindAll = function() {\n\t\n\t    this._handlers = {};\n\t    this._handlersAll = [];\n\t    this._handlersComplex = [];\n\t\n\t    return this;\n\t  };\n\t\n\t\n\t  /**\n\t   * This method binds one or more functions to the emitter, handled to one or a\n\t   * suite of events. So, these functions will be executed anytime one related\n\t   * event is emitted.\n\t   *\n\t   * It is also possible to bind a function to any emitted event by not\n\t   * specifying any event to bind the function to.\n\t   *\n\t   * Recognized options:\n\t   * *******************\n\t   *  - {?boolean} once   If true, the handlers will be unbound after the first\n\t   *                      execution. Default value: false.\n\t   *  - {?object}  scope  If a scope is given, then the listeners will be called\n\t   *                      with this scope as \"this\".\n\t   *\n\t   * Variant 1:\n\t   * **********\n\t   * > myEmitter.on('myEvent', function(e) { console.log(e); });\n\t   * > // Or:\n\t   * > myEmitter.on('myEvent', function(e) { console.log(e); }, { once: true });\n\t   *\n\t   * @param  {string}   event   The event to listen to.\n\t   * @param  {function} handler The function to bind.\n\t   * @param  {?object}  options Eventually some options.\n\t   * @return {Emitter}          Returns this.\n\t   *\n\t   * Variant 2:\n\t   * **********\n\t   * > myEmitter.on(\n\t   * >   ['myEvent1', 'myEvent2'],\n\t   * >   function(e) { console.log(e); }\n\t   * >);\n\t   * > // Or:\n\t   * > myEmitter.on(\n\t   * >   ['myEvent1', 'myEvent2'],\n\t   * >   function(e) { console.log(e); }\n\t   * >   { once: true }}\n\t   * >);\n\t   *\n\t   * @param  {array}    events  The events to listen to.\n\t   * @param  {function} handler The function to bind.\n\t   * @param  {?object}  options Eventually some options.\n\t   * @return {Emitter}          Returns this.\n\t   *\n\t   * Variant 3:\n\t   * **********\n\t   * > myEmitter.on({\n\t   * >   myEvent1: function(e) { console.log(e); },\n\t   * >   myEvent2: function(e) { console.log(e); }\n\t   * > });\n\t   * > // Or:\n\t   * > myEmitter.on({\n\t   * >   myEvent1: function(e) { console.log(e); },\n\t   * >   myEvent2: function(e) { console.log(e); }\n\t   * > }, { once: true });\n\t   *\n\t   * @param  {object}  bindings An object containing pairs event / function.\n\t   * @param  {?object}  options Eventually some options.\n\t   * @return {Emitter}          Returns this.\n\t   *\n\t   * Variant 4:\n\t   * **********\n\t   * > myEmitter.on(function(e) { console.log(e); });\n\t   * > // Or:\n\t   * > myEmitter.on(function(e) { console.log(e); }, { once: true});\n\t   *\n\t   * @param  {function} handler The function to bind to every events.\n\t   * @param  {?object}  options Eventually some options.\n\t   * @return {Emitter}          Returns this.\n\t   */\n\t  Emitter.prototype.on = function(a, b, c) {\n\t    var i,\n\t        l,\n\t        k,\n\t        event,\n\t        eArray,\n\t        handlersList,\n\t        bindingObject;\n\t\n\t    // Variant 3\n\t    if (isPlainObject(a)) {\n\t      forIn(a, function(name, fn) {\n\t        this.on(name, fn, b);\n\t      }, this);\n\t\n\t      return this;\n\t    }\n\t\n\t    // Variant 1, 2 and 4\n\t    if (typeof a === 'function') {\n\t      c = b;\n\t      b = a;\n\t      a = null;\n\t    }\n\t\n\t    eArray = [].concat(a);\n\t\n\t    for (i = 0, l = eArray.length; i < l; i++) {\n\t      event = eArray[i];\n\t\n\t      bindingObject = {\n\t        order: __order++,\n\t        fn: b\n\t      };\n\t\n\t      // Defining the list in which the handler should be inserted\n\t      if (typeof event === 'string' || typeof event === 'symbol') {\n\t        if (!this._handlers[event])\n\t          this._handlers[event] = [];\n\t        handlersList = this._handlers[event];\n\t        bindingObject.type = event;\n\t      }\n\t      else if (event instanceof RegExp) {\n\t        handlersList = this._handlersComplex;\n\t        bindingObject.pattern = event;\n\t      }\n\t      else if (event === null) {\n\t        handlersList = this._handlersAll;\n\t      }\n\t      else {\n\t        throw Error('Emitter.on: invalid event.');\n\t      }\n\t\n\t      // Appending needed properties\n\t      for (k in c || {})\n\t        if (__allowedOptions[k])\n\t          bindingObject[k] = c[k];\n\t\n\t      handlersList.push(bindingObject);\n\t    }\n\t\n\t    return this;\n\t  };\n\t\n\t\n\t  /**\n\t   * This method works exactly as the previous #on, but will add an options\n\t   * object if none is given, and set the option \"once\" to true.\n\t   *\n\t   * The polymorphism works exactly as with the #on method.\n\t   */\n\t  Emitter.prototype.once = function() {\n\t    var args = Array.prototype.slice.call(arguments),\n\t        li = args.length - 1;\n\t\n\t    if (isPlainObject(args[li]) && args.length > 1)\n\t      args[li] = shallowMerge(args[li], {once: true});\n\t    else\n\t      args.push({once: true});\n\t\n\t    return this.on.apply(this, args);\n\t  };\n\t\n\t\n\t  /**\n\t   * This method unbinds one or more functions from events of the emitter. So,\n\t   * these functions will no more be executed when the related events are\n\t   * emitted. If the functions were not bound to the events, nothing will\n\t   * happen, and no error will be thrown.\n\t   *\n\t   * Variant 1:\n\t   * **********\n\t   * > myEmitter.off('myEvent', myHandler);\n\t   *\n\t   * @param  {string}   event   The event to unbind the handler from.\n\t   * @param  {function} handler The function to unbind.\n\t   * @return {Emitter}          Returns this.\n\t   *\n\t   * Variant 2:\n\t   * **********\n\t   * > myEmitter.off(['myEvent1', 'myEvent2'], myHandler);\n\t   *\n\t   * @param  {array}    events  The events to unbind the handler from.\n\t   * @param  {function} handler The function to unbind.\n\t   * @return {Emitter}          Returns this.\n\t   *\n\t   * Variant 3:\n\t   * **********\n\t   * > myEmitter.off({\n\t   * >   myEvent1: myHandler1,\n\t   * >   myEvent2: myHandler2\n\t   * > });\n\t   *\n\t   * @param  {object} bindings An object containing pairs event / function.\n\t   * @return {Emitter}         Returns this.\n\t   *\n\t   * Variant 4:\n\t   * **********\n\t   * > myEmitter.off(myHandler);\n\t   *\n\t   * @param  {function} handler The function to unbind from every events.\n\t   * @return {Emitter}          Returns this.\n\t   *\n\t   * Variant 5:\n\t   * **********\n\t   * > myEmitter.off(event);\n\t   *\n\t   * @param  {string} event     The event we should unbind.\n\t   * @return {Emitter}          Returns this.\n\t   */\n\t  function filter(target, fn) {\n\t    target = target || [];\n\t\n\t    var a = [],\n\t        l,\n\t        i;\n\t\n\t    for (i = 0, l = target.length; i < l; i++)\n\t      if (target[i].fn !== fn)\n\t        a.push(target[i]);\n\t\n\t    return a;\n\t  }\n\t\n\t  Emitter.prototype.off = function(events, fn) {\n\t    var i,\n\t        n,\n\t        k,\n\t        event;\n\t\n\t    // Variant 4:\n\t    if (arguments.length === 1 && typeof events === 'function') {\n\t      fn = arguments[0];\n\t\n\t      // Handlers bound to events:\n\t      for (k in this._handlers) {\n\t        this._handlers[k] = filter(this._handlers[k], fn);\n\t\n\t        if (this._handlers[k].length === 0)\n\t          delete this._handlers[k];\n\t      }\n\t\n\t      // Generic Handlers\n\t      this._handlersAll = filter(this._handlersAll, fn);\n\t\n\t      // Complex handlers\n\t      this._handlersComplex = filter(this._handlersComplex, fn);\n\t    }\n\t\n\t    // Variant 5\n\t    else if (arguments.length === 1 &&\n\t             (typeof events === 'string' || typeof events === 'symbol')) {\n\t      delete this._handlers[events];\n\t    }\n\t\n\t    // Variant 1 and 2:\n\t    else if (arguments.length === 2) {\n\t      var eArray = [].concat(events);\n\t\n\t      for (i = 0, n = eArray.length; i < n; i++) {\n\t        event = eArray[i];\n\t\n\t        this._handlers[event] = filter(this._handlers[event], fn);\n\t\n\t        if ((this._handlers[event] || []).length === 0)\n\t          delete this._handlers[event];\n\t      }\n\t    }\n\t\n\t    // Variant 3\n\t    else if (isPlainObject(events)) {\n\t      forIn(events, this.off, this);\n\t    }\n\t\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * This method retrieve the listeners attached to a particular event.\n\t   *\n\t   * @param  {?string}    Name of the event.\n\t   * @return {array}      Array of handler functions.\n\t   */\n\t  Emitter.prototype.listeners = function(event) {\n\t    var handlers = this._handlersAll || [],\n\t        complex = false,\n\t        h,\n\t        i,\n\t        l;\n\t\n\t    if (!event)\n\t      throw Error('Emitter.listeners: no event provided.');\n\t\n\t    handlers = handlers.concat(this._handlers[event] || []);\n\t\n\t    for (i = 0, l = this._handlersComplex.length; i < l; i++) {\n\t      h = this._handlersComplex[i];\n\t\n\t      if (~event.search(h.pattern)) {\n\t        complex = true;\n\t        handlers.push(h);\n\t      }\n\t    }\n\t\n\t    // If we have any complex handlers, we need to sort\n\t    if (this._handlersAll.length || complex)\n\t      return handlers.sort(function(a, b) {\n\t        return a.order - b.order;\n\t      });\n\t    else\n\t      return handlers.slice(0);\n\t  };\n\t\n\t  /**\n\t   * This method emits the specified event(s), and executes every handlers bound\n\t   * to the event(s).\n\t   *\n\t   * Use cases:\n\t   * **********\n\t   * > myEmitter.emit('myEvent');\n\t   * > myEmitter.emit('myEvent', myData);\n\t   * > myEmitter.emit(['myEvent1', 'myEvent2']);\n\t   * > myEmitter.emit(['myEvent1', 'myEvent2'], myData);\n\t   * > myEmitter.emit({myEvent1: myData1, myEvent2: myData2});\n\t   *\n\t   * @param  {string|array} events The event(s) to emit.\n\t   * @param  {object?}      data   The data.\n\t   * @return {Emitter}             Returns this.\n\t   */\n\t  Emitter.prototype.emit = function(events, data) {\n\t\n\t    // Short exit if the emitter is disabled\n\t    if (!this._enabled)\n\t      return this;\n\t\n\t    // Object variant\n\t    if (isPlainObject(events)) {\n\t      forIn(events, this.emit, this);\n\t      return this;\n\t    }\n\t\n\t    var eArray = [].concat(events),\n\t        onces = [],\n\t        event,\n\t        parent,\n\t        handlers,\n\t        handler,\n\t        i,\n\t        j,\n\t        l,\n\t        m;\n\t\n\t    for (i = 0, l = eArray.length; i < l; i++) {\n\t      handlers = this.listeners(eArray[i]);\n\t\n\t      for (j = 0, m = handlers.length; j < m; j++) {\n\t        handler = handlers[j];\n\t        event = {\n\t          type: eArray[i],\n\t          target: this\n\t        };\n\t\n\t        if (arguments.length > 1)\n\t          event.data = data;\n\t\n\t        handler.fn.call('scope' in handler ? handler.scope : this, event);\n\t\n\t        if (handler.once)\n\t          onces.push(handler);\n\t      }\n\t\n\t      // Cleaning onces\n\t      for (j = onces.length - 1; j >= 0; j--) {\n\t        parent = onces[j].type ?\n\t          this._handlers[onces[j].type] :\n\t          onces[j].pattern ?\n\t            this._handlersComplex :\n\t            this._handlersAll;\n\t\n\t        parent.splice(parent.indexOf(onces[j]), 1);\n\t      }\n\t    }\n\t\n\t    return this;\n\t  };\n\t\n\t\n\t  /**\n\t   * This method will unbind all listeners and make it impossible to ever\n\t   * rebind any listener to any event.\n\t   */\n\t  Emitter.prototype.kill = function() {\n\t\n\t    this.unbindAll();\n\t    this._handlers = null;\n\t    this._handlersAll = null;\n\t    this._handlersComplex = null;\n\t    this._enabled = false;\n\t\n\t    // Nooping methods\n\t    this.unbindAll =\n\t    this.on =\n\t    this.once =\n\t    this.off =\n\t    this.emit =\n\t    this.listeners = Function.prototype;\n\t  };\n\t\n\t\n\t  /**\n\t   * This method disabled the emitter, which means its emit method will do\n\t   * nothing.\n\t   *\n\t   * @return {Emitter} Returns this.\n\t   */\n\t  Emitter.prototype.disable = function() {\n\t    this._enabled = false;\n\t\n\t    return this;\n\t  };\n\t\n\t\n\t  /**\n\t   * This method enables the emitter.\n\t   *\n\t   * @return {Emitter} Returns this.\n\t   */\n\t  Emitter.prototype.enable = function() {\n\t    this._enabled = true;\n\t\n\t    return this;\n\t  };\n\t\n\t\n\t  /**\n\t   * Version:\n\t   */\n\t  Emitter.version = '3.1.1';\n\t\n\t\n\t  // Export:\n\t  if (true) {\n\t    if (typeof module !== 'undefined' && module.exports)\n\t      exports = module.exports = Emitter;\n\t    exports.Emitter = Emitter;\n\t  } else if (typeof define === 'function' && define.amd)\n\t    define('emmett', [], function() {\n\t      return Emitter;\n\t    });\n\t  else\n\t    this.Emitter = Emitter;\n\t}).call(this);\n\n\n/***/ },\n/* 27 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Baobab Cursors\n\t * ===============\n\t *\n\t * Cursors created by selecting some data within a Baobab tree.\n\t */\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\t\n\tvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\t\n\tvar _get = function get(_x3, _x4, _x5) { var _again = true; _function: while (_again) { var object = _x3, property = _x4, receiver = _x5; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x3 = parent; _x4 = property; _x5 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar _emmett = __webpack_require__(26);\n\t\n\tvar _emmett2 = _interopRequireDefault(_emmett);\n\t\n\tvar _monkey = __webpack_require__(28);\n\t\n\tvar _type = __webpack_require__(29);\n\t\n\tvar _type2 = _interopRequireDefault(_type);\n\t\n\tvar _helpers = __webpack_require__(31);\n\t\n\t/**\n\t * Traversal helper function for dynamic cursors. Will throw a legible error\n\t * if traversal is not possible.\n\t *\n\t * @param {string} method     - The method name, to create a correct error msg.\n\t * @param {array}  solvedPath - The cursor's solved path.\n\t */\n\tfunction checkPossibilityOfDynamicTraversal(method, solvedPath) {\n\t  if (!solvedPath) throw (0, _helpers.makeError)('Baobab.Cursor.' + method + ': ' + ('cannot use ' + method + ' on an unresolved dynamic path.'), { path: solvedPath });\n\t}\n\t\n\t/**\n\t * Cursor class\n\t *\n\t * @constructor\n\t * @param {Baobab} tree   - The cursor's root.\n\t * @param {array}  path   - The cursor's path in the tree.\n\t * @param {string} hash   - The path's hash computed ahead by the tree.\n\t */\n\t\n\tvar Cursor = (function (_Emitter) {\n\t  _inherits(Cursor, _Emitter);\n\t\n\t  function Cursor(tree, path, hash) {\n\t    var _this = this;\n\t\n\t    _classCallCheck(this, Cursor);\n\t\n\t    _get(Object.getPrototypeOf(Cursor.prototype), 'constructor', this).call(this);\n\t\n\t    // If no path were to be provided, we fallback to an empty path (root)\n\t    path = path || [];\n\t\n\t    // Privates\n\t    this._identity = '[object Cursor]';\n\t    this._archive = null;\n\t\n\t    // Properties\n\t    this.tree = tree;\n\t    this.path = path;\n\t    this.hash = hash;\n\t\n\t    // State\n\t    this.state = {\n\t      killed: false,\n\t      recording: false,\n\t      undoing: false\n\t    };\n\t\n\t    // Checking whether the given path is dynamic or not\n\t    this._dynamicPath = _type2['default'].dynamicPath(this.path);\n\t\n\t    // Checking whether the given path will meet a monkey\n\t    this._monkeyPath = _type2['default'].monkeyPath(this.tree._monkeys, this.path);\n\t\n\t    if (!this._dynamicPath) this.solvedPath = this.path;else this.solvedPath = (0, _helpers.getIn)(this.tree._data, this.path).solvedPath;\n\t\n\t    /**\n\t     * Listener bound to the tree's writes so that cursors with dynamic paths\n\t     * may update their solved path correctly.\n\t     *\n\t     * @param {object} event - The event fired by the tree.\n\t     */\n\t    this._writeHandler = function (_ref) {\n\t      var data = _ref.data;\n\t\n\t      if (_this.state.killed || !(0, _helpers.solveUpdate)([data.path], _this._getComparedPaths())) return;\n\t\n\t      _this.solvedPath = (0, _helpers.getIn)(_this.tree._data, _this.path).solvedPath;\n\t    };\n\t\n\t    /**\n\t     * Function in charge of actually trigger the cursor's updates and\n\t     * deal with the archived records.\n\t     *\n\t     * @note: probably should wrap the current solvedPath in closure to avoid\n\t     * for tricky cases where it would fail.\n\t     *\n\t     * @param {mixed} previousData - the tree's previous data.\n\t     */\n\t    var fireUpdate = function fireUpdate(previousData) {\n\t      var self = _this;\n\t\n\t      var eventData = Object.defineProperties({}, {\n\t        previousData: {\n\t          get: function get() {\n\t            return (0, _helpers.getIn)(previousData, self.solvedPath).data;\n\t          },\n\t          configurable: true,\n\t          enumerable: true\n\t        },\n\t        currentData: {\n\t          get: function get() {\n\t            return self.get();\n\t          },\n\t          configurable: true,\n\t          enumerable: true\n\t        }\n\t      });\n\t\n\t      if (_this.state.recording && !_this.state.undoing) _this.archive.add(eventData.previousData);\n\t\n\t      _this.state.undoing = false;\n\t\n\t      return _this.emit('update', eventData);\n\t    };\n\t\n\t    /**\n\t     * Listener bound to the tree's updates and determining whether the\n\t     * cursor is affected and should react accordingly.\n\t     *\n\t     * Note that this listener is lazily bound to the tree to be sure\n\t     * one wouldn't leak listeners when only creating cursors for convenience\n\t     * and not to listen to updates specifically.\n\t     *\n\t     * @param {object} event - The event fired by the tree.\n\t     */\n\t    this._updateHandler = function (event) {\n\t      if (_this.state.killed) return;\n\t\n\t      var _event$data = event.data;\n\t      var paths = _event$data.paths;\n\t      var previousData = _event$data.previousData;\n\t      var update = fireUpdate.bind(_this, previousData);\n\t      var comparedPaths = _this._getComparedPaths();\n\t\n\t      if ((0, _helpers.solveUpdate)(paths, comparedPaths)) return update();\n\t    };\n\t\n\t    // Lazy binding\n\t    var bound = false;\n\t    this._lazyBind = function () {\n\t      if (bound) return;\n\t\n\t      bound = true;\n\t\n\t      if (_this._dynamicPath) _this.tree.on('write', _this._writeHandler);\n\t\n\t      return _this.tree.on('update', _this._updateHandler);\n\t    };\n\t\n\t    // If the path is dynamic, we actually need to listen to the tree\n\t    if (this._dynamicPath) {\n\t      this._lazyBind();\n\t    } else {\n\t\n\t      // Overriding the emitter `on` and `once` methods\n\t      this.on = (0, _helpers.before)(this._lazyBind, this.on.bind(this));\n\t      this.once = (0, _helpers.before)(this._lazyBind, this.once.bind(this));\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Method used to allow iterating over cursors containing list-type data.\n\t   *\n\t   * e.g. for(let i of cursor) { ... }\n\t   *\n\t   * @returns {object} -  Each item sequentially.\n\t   */\n\t\n\t  /**\n\t   * Internal helpers\n\t   * -----------------\n\t   */\n\t\n\t  /**\n\t   * Method returning the paths of the tree watched over by the cursor and that\n\t   * should be taken into account when solving a potential update.\n\t   *\n\t   * @return {array} - Array of paths to compare with a given update.\n\t   */\n\t\n\t  _createClass(Cursor, [{\n\t    key: '_getComparedPaths',\n\t    value: function _getComparedPaths() {\n\t\n\t      // Checking whether we should keep track of some dependencies\n\t      var additionalPaths = this._monkeyPath ? (0, _helpers.getIn)(this.tree._monkeys, this._monkeyPath).data.relatedPaths() : [];\n\t\n\t      return [this.solvedPath].concat(additionalPaths);\n\t    }\n\t\n\t    /**\n\t     * Predicates\n\t     * -----------\n\t     */\n\t\n\t    /**\n\t     * Method returning whether the cursor is at root level.\n\t     *\n\t     * @return {boolean} - Is the cursor the root?\n\t     */\n\t  }, {\n\t    key: 'isRoot',\n\t    value: function isRoot() {\n\t      return !this.path.length;\n\t    }\n\t\n\t    /**\n\t     * Method returning whether the cursor is at leaf level.\n\t     *\n\t     * @return {boolean} - Is the cursor a leaf?\n\t     */\n\t  }, {\n\t    key: 'isLeaf',\n\t    value: function isLeaf() {\n\t      return _type2['default'].primitive(this._get().data);\n\t    }\n\t\n\t    /**\n\t     * Method returning whether the cursor is at branch level.\n\t     *\n\t     * @return {boolean} - Is the cursor a branch?\n\t     */\n\t  }, {\n\t    key: 'isBranch',\n\t    value: function isBranch() {\n\t      return !this.isRoot() && !this.isLeaf();\n\t    }\n\t\n\t    /**\n\t     * Traversal Methods\n\t     * ------------------\n\t     */\n\t\n\t    /**\n\t     * Method returning the root cursor.\n\t     *\n\t     * @return {Baobab} - The root cursor.\n\t     */\n\t  }, {\n\t    key: 'root',\n\t    value: function root() {\n\t      return this.tree.select();\n\t    }\n\t\n\t    /**\n\t     * Method selecting a subpath as a new cursor.\n\t     *\n\t     * Arity (1):\n\t     * @param  {path} path    - The path to select.\n\t     *\n\t     * Arity (*):\n\t     * @param  {...step} path - The path to select.\n\t     *\n\t     * @return {Cursor}       - The created cursor.\n\t     */\n\t  }, {\n\t    key: 'select',\n\t    value: function select(path) {\n\t      if (arguments.length > 1) path = (0, _helpers.arrayFrom)(arguments);\n\t\n\t      return this.tree.select(this.path.concat(path));\n\t    }\n\t\n\t    /**\n\t     * Method returning the parent node of the cursor or else `null` if the\n\t     * cursor is already at root level.\n\t     *\n\t     * @return {Baobab} - The parent cursor.\n\t     */\n\t  }, {\n\t    key: 'up',\n\t    value: function up() {\n\t      if (!this.isRoot()) return this.tree.select(this.path.slice(0, -1));\n\t\n\t      return null;\n\t    }\n\t\n\t    /**\n\t     * Method returning the child node of the cursor.\n\t     *\n\t     * @return {Baobab} - The child cursor.\n\t     */\n\t  }, {\n\t    key: 'down',\n\t    value: function down() {\n\t      checkPossibilityOfDynamicTraversal('down', this.solvedPath);\n\t\n\t      if (!(this._get().data instanceof Array)) throw Error('Baobab.Cursor.down: cannot go down on a non-list type.');\n\t\n\t      return this.tree.select(this.solvedPath.concat(0));\n\t    }\n\t\n\t    /**\n\t     * Method returning the left sibling node of the cursor if this one is\n\t     * pointing at a list. Returns `null` if this cursor is already leftmost.\n\t     *\n\t     * @return {Baobab} - The left sibling cursor.\n\t     */\n\t  }, {\n\t    key: 'left',\n\t    value: function left() {\n\t      checkPossibilityOfDynamicTraversal('left', this.solvedPath);\n\t\n\t      var last = +this.solvedPath[this.solvedPath.length - 1];\n\t\n\t      if (isNaN(last)) throw Error('Baobab.Cursor.left: cannot go left on a non-list type.');\n\t\n\t      return last ? this.tree.select(this.solvedPath.slice(0, -1).concat(last - 1)) : null;\n\t    }\n\t\n\t    /**\n\t     * Method returning the right sibling node of the cursor if this one is\n\t     * pointing at a list. Returns `null` if this cursor is already rightmost.\n\t     *\n\t     * @return {Baobab} - The right sibling cursor.\n\t     */\n\t  }, {\n\t    key: 'right',\n\t    value: function right() {\n\t      checkPossibilityOfDynamicTraversal('right', this.solvedPath);\n\t\n\t      var last = +this.solvedPath[this.solvedPath.length - 1];\n\t\n\t      if (isNaN(last)) throw Error('Baobab.Cursor.right: cannot go right on a non-list type.');\n\t\n\t      if (last + 1 === this.up()._get().data.length) return null;\n\t\n\t      return this.tree.select(this.solvedPath.slice(0, -1).concat(last + 1));\n\t    }\n\t\n\t    /**\n\t     * Method returning the leftmost sibling node of the cursor if this one is\n\t     * pointing at a list.\n\t     *\n\t     * @return {Baobab} - The leftmost sibling cursor.\n\t     */\n\t  }, {\n\t    key: 'leftmost',\n\t    value: function leftmost() {\n\t      checkPossibilityOfDynamicTraversal('leftmost', this.solvedPath);\n\t\n\t      var last = +this.solvedPath[this.solvedPath.length - 1];\n\t\n\t      if (isNaN(last)) throw Error('Baobab.Cursor.leftmost: cannot go left on a non-list type.');\n\t\n\t      return this.tree.select(this.solvedPath.slice(0, -1).concat(0));\n\t    }\n\t\n\t    /**\n\t     * Method returning the rightmost sibling node of the cursor if this one is\n\t     * pointing at a list.\n\t     *\n\t     * @return {Baobab} - The rightmost sibling cursor.\n\t     */\n\t  }, {\n\t    key: 'rightmost',\n\t    value: function rightmost() {\n\t      checkPossibilityOfDynamicTraversal('rightmost', this.solvedPath);\n\t\n\t      var last = +this.solvedPath[this.solvedPath.length - 1];\n\t\n\t      if (isNaN(last)) throw Error('Baobab.Cursor.rightmost: cannot go right on a non-list type.');\n\t\n\t      var list = this.up()._get().data;\n\t\n\t      return this.tree.select(this.solvedPath.slice(0, -1).concat(list.length - 1));\n\t    }\n\t\n\t    /**\n\t     * Method mapping the children nodes of the cursor.\n\t     *\n\t     * @param  {function} fn      - The function to map.\n\t     * @param  {object}   [scope] - An optional scope.\n\t     * @return {array}            - The resultant array.\n\t     */\n\t  }, {\n\t    key: 'map',\n\t    value: function map(fn, scope) {\n\t      checkPossibilityOfDynamicTraversal('map', this.solvedPath);\n\t\n\t      var array = this._get().data,\n\t          l = arguments.length;\n\t\n\t      if (!_type2['default'].array(array)) throw Error('baobab.Cursor.map: cannot map a non-list type.');\n\t\n\t      return array.map(function (item, i) {\n\t        return fn.call(l > 1 ? scope : this, this.select(i), i, array);\n\t      }, this);\n\t    }\n\t\n\t    /**\n\t     * Getter Methods\n\t     * ---------------\n\t     */\n\t\n\t    /**\n\t     * Internal get method. Basically contains the main body of the `get` method\n\t     * without the event emitting. This is sometimes needed not to fire useless\n\t     * events.\n\t     *\n\t     * @param  {path}   [path=[]]       - Path to get in the tree.\n\t     * @return {object} info            - The resultant information.\n\t     * @return {mixed}  info.data       - Data at path.\n\t     * @return {array}  info.solvedPath - The path solved when getting.\n\t     */\n\t  }, {\n\t    key: '_get',\n\t    value: function _get() {\n\t      var path = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];\n\t\n\t      if (!_type2['default'].path(path)) throw (0, _helpers.makeError)('Baobab.Cursor.getters: invalid path.', { path: path });\n\t\n\t      if (!this.solvedPath) return { data: undefined, solvedPath: null, exists: false };\n\t\n\t      return (0, _helpers.getIn)(this.tree._data, this.solvedPath.concat(path));\n\t    }\n\t\n\t    /**\n\t     * Method used to check whether a certain path exists in the tree starting\n\t     * from the current cursor.\n\t     *\n\t     * Arity (1):\n\t     * @param  {path}   path           - Path to check in the tree.\n\t     *\n\t     * Arity (2):\n\t     * @param {..step}  path           - Path to check in the tree.\n\t     *\n\t     * @return {boolean}               - Does the given path exists?\n\t     */\n\t  }, {\n\t    key: 'exists',\n\t    value: function exists(path) {\n\t      path = (0, _helpers.coercePath)(path);\n\t\n\t      if (arguments.length > 1) path = (0, _helpers.arrayFrom)(arguments);\n\t\n\t      return this._get(path).exists;\n\t    }\n\t\n\t    /**\n\t     * Method used to get data from the tree. Will fire a `get` event from the\n\t     * tree so that the user may sometimes react upon it to fetch data, for\n\t     * instance.\n\t     *\n\t     * Arity (1):\n\t     * @param  {path}   path           - Path to get in the tree.\n\t     *\n\t     * Arity (2):\n\t     * @param  {..step} path           - Path to get in the tree.\n\t     *\n\t     * @return {mixed}                 - Data at path.\n\t     */\n\t  }, {\n\t    key: 'get',\n\t    value: function get(path) {\n\t      path = (0, _helpers.coercePath)(path);\n\t\n\t      if (arguments.length > 1) path = (0, _helpers.arrayFrom)(arguments);\n\t\n\t      var _get2 = this._get(path);\n\t\n\t      var data = _get2.data;\n\t      var solvedPath = _get2.solvedPath;\n\t\n\t      // Emitting the event\n\t      this.tree.emit('get', { data: data, solvedPath: solvedPath, path: this.path.concat(path) });\n\t\n\t      return data;\n\t    }\n\t\n\t    /**\n\t     * Method used to shallow clone data from the tree.\n\t     *\n\t     * Arity (1):\n\t     * @param  {path}   path           - Path to get in the tree.\n\t     *\n\t     * Arity (2):\n\t     * @param  {..step} path           - Path to get in the tree.\n\t     *\n\t     * @return {mixed}                 - Cloned data at path.\n\t     */\n\t  }, {\n\t    key: 'clone',\n\t    value: function clone() {\n\t      var data = this.get.apply(this, arguments);\n\t\n\t      return (0, _helpers.shallowClone)(data);\n\t    }\n\t\n\t    /**\n\t     * Method used to deep clone data from the tree.\n\t     *\n\t     * Arity (1):\n\t     * @param  {path}   path           - Path to get in the tree.\n\t     *\n\t     * Arity (2):\n\t     * @param  {..step} path           - Path to get in the tree.\n\t     *\n\t     * @return {mixed}                 - Cloned data at path.\n\t     */\n\t  }, {\n\t    key: 'deepClone',\n\t    value: function deepClone() {\n\t      var data = this.get.apply(this, arguments);\n\t\n\t      return (0, _helpers.deepClone)(data);\n\t    }\n\t\n\t    /**\n\t     * Method used to return raw data from the tree, by carefully avoiding\n\t     * computed one.\n\t     *\n\t     * @todo: should be more performant as the cloning should happen as well as\n\t     * when dropping computed data.\n\t     *\n\t     * Arity (1):\n\t     * @param  {path}   path           - Path to serialize in the tree.\n\t     *\n\t     * Arity (2):\n\t     * @param  {..step} path           - Path to serialize in the tree.\n\t     *\n\t     * @return {mixed}                 - The retrieved raw data.\n\t     */\n\t  }, {\n\t    key: 'serialize',\n\t    value: function serialize(path) {\n\t      path = (0, _helpers.coercePath)(path);\n\t\n\t      if (arguments.length > 1) path = (0, _helpers.arrayFrom)(arguments);\n\t\n\t      if (!_type2['default'].path(path)) throw (0, _helpers.makeError)('Baobab.Cursor.getters: invalid path.', { path: path });\n\t\n\t      if (!this.solvedPath) return undefined;\n\t\n\t      var fullPath = this.solvedPath.concat(path);\n\t\n\t      var data = (0, _helpers.deepClone)((0, _helpers.getIn)(this.tree._data, fullPath).data),\n\t          monkeys = (0, _helpers.getIn)(this.tree._monkeys, fullPath).data;\n\t\n\t      var dropComputedData = function dropComputedData(d, m) {\n\t        if (!_type2['default'].object(m) || !_type2['default'].object(d)) return;\n\t\n\t        for (var k in m) {\n\t          if (m[k] instanceof _monkey.Monkey) delete d[k];else dropComputedData(d[k], m[k]);\n\t        }\n\t      };\n\t\n\t      dropComputedData(data, monkeys);\n\t      return data;\n\t    }\n\t\n\t    /**\n\t     * Method used to project some of the data at cursor onto a map or a list.\n\t     *\n\t     * @param  {object|array} projection - The projection's formal definition.\n\t     * @return {object|array}            - The resultant map/list.\n\t     */\n\t  }, {\n\t    key: 'project',\n\t    value: function project(projection) {\n\t      if (_type2['default'].object(projection)) {\n\t        var data = {};\n\t\n\t        for (var k in projection) {\n\t          data[k] = this.get(projection[k]);\n\t        }return data;\n\t      } else if (_type2['default'].array(projection)) {\n\t        var data = [];\n\t\n\t        for (var i = 0, l = projection.length; i < l; i++) {\n\t          data.push(this.get(projection[i]));\n\t        }return data;\n\t      }\n\t\n\t      throw (0, _helpers.makeError)('Baobab.Cursor.project: wrong projection.', { projection: projection });\n\t    }\n\t\n\t    /**\n\t     * History Methods\n\t     * ----------------\n\t     */\n\t\n\t    /**\n\t     * Methods starting to record the cursor's successive states.\n\t     *\n\t     * @param  {integer} [maxRecords] - Maximum records to keep in memory. Note\n\t     *                                  that if no number is provided, the cursor\n\t     *                                  will keep everything.\n\t     * @return {Cursor}               - The cursor instance for chaining purposes.\n\t     */\n\t  }, {\n\t    key: 'startRecording',\n\t    value: function startRecording(maxRecords) {\n\t      maxRecords = maxRecords || Infinity;\n\t\n\t      if (maxRecords < 1) throw (0, _helpers.makeError)('Baobab.Cursor.startRecording: invalid max records.', {\n\t        value: maxRecords\n\t      });\n\t\n\t      this.state.recording = true;\n\t\n\t      if (this.archive) return this;\n\t\n\t      // Lazy binding\n\t      this._lazyBind();\n\t\n\t      this.archive = new _helpers.Archive(maxRecords);\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Methods stopping to record the cursor's successive states.\n\t     *\n\t     * @return {Cursor} - The cursor instance for chaining purposes.\n\t     */\n\t  }, {\n\t    key: 'stopRecording',\n\t    value: function stopRecording() {\n\t      this.state.recording = false;\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Methods undoing n steps of the cursor's recorded states.\n\t     *\n\t     * @param  {integer} [steps=1] - The number of steps to rollback.\n\t     * @return {Cursor}            - The cursor instance for chaining purposes.\n\t     */\n\t  }, {\n\t    key: 'undo',\n\t    value: function undo() {\n\t      var steps = arguments.length <= 0 || arguments[0] === undefined ? 1 : arguments[0];\n\t\n\t      if (!this.state.recording) throw new Error('Baobab.Cursor.undo: cursor is not recording.');\n\t\n\t      var record = this.archive.back(steps);\n\t\n\t      if (!record) throw Error('Baobab.Cursor.undo: cannot find a relevant record.');\n\t\n\t      this.state.undoing = true;\n\t      this.set(record);\n\t\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Methods returning whether the cursor has a recorded history.\n\t     *\n\t     * @return {boolean} - `true` if the cursor has a recorded history?\n\t     */\n\t  }, {\n\t    key: 'hasHistory',\n\t    value: function hasHistory() {\n\t      return !!(this.archive && this.archive.get().length);\n\t    }\n\t\n\t    /**\n\t     * Methods returning the cursor's history.\n\t     *\n\t     * @return {array} - The cursor's history.\n\t     */\n\t  }, {\n\t    key: 'getHistory',\n\t    value: function getHistory() {\n\t      return this.archive ? this.archive.get() : [];\n\t    }\n\t\n\t    /**\n\t     * Methods clearing the cursor's history.\n\t     *\n\t     * @return {Cursor} - The cursor instance for chaining purposes.\n\t     */\n\t  }, {\n\t    key: 'clearHistory',\n\t    value: function clearHistory() {\n\t      if (this.archive) this.archive.clear();\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Releasing\n\t     * ----------\n\t     */\n\t\n\t    /**\n\t     * Methods releasing the cursor from memory.\n\t     */\n\t  }, {\n\t    key: 'release',\n\t    value: function release() {\n\t\n\t      // Removing listeners on parent\n\t      if (this._dynamicPath) this.tree.off('write', this._writeHandler);\n\t\n\t      this.tree.off('update', this._updateHandler);\n\t\n\t      // Unsubscribe from the parent\n\t      if (this.hash) delete this.tree._cursors[this.hash];\n\t\n\t      // Dereferencing\n\t      delete this.tree;\n\t      delete this.path;\n\t      delete this.solvedPath;\n\t      delete this.archive;\n\t\n\t      // Killing emitter\n\t      this.kill();\n\t      this.state.killed = true;\n\t    }\n\t\n\t    /**\n\t     * Output\n\t     * -------\n\t     */\n\t\n\t    /**\n\t     * Overriding the `toJSON` method for convenient use with JSON.stringify.\n\t     *\n\t     * @return {mixed} - Data at cursor.\n\t     */\n\t  }, {\n\t    key: 'toJSON',\n\t    value: function toJSON() {\n\t      return this.serialize();\n\t    }\n\t\n\t    /**\n\t     * Overriding the `toString` method for debugging purposes.\n\t     *\n\t     * @return {string} - The cursor's identity.\n\t     */\n\t  }, {\n\t    key: 'toString',\n\t    value: function toString() {\n\t      return this._identity;\n\t    }\n\t  }]);\n\t\n\t  return Cursor;\n\t})(_emmett2['default']);\n\t\n\texports['default'] = Cursor;\n\tif (typeof Symbol === 'function' && typeof Symbol.iterator !== 'undefined') {\n\t  Cursor.prototype[Symbol.iterator] = function () {\n\t    var array = this._get().data;\n\t\n\t    if (!_type2['default'].array(array)) throw Error('baobab.Cursor.@@iterate: cannot iterate a non-list type.');\n\t\n\t    var i = 0;\n\t\n\t    var cursor = this,\n\t        length = array.length;\n\t\n\t    return {\n\t      next: function next() {\n\t        if (i < length) {\n\t          return {\n\t            value: cursor.select(i++)\n\t          };\n\t        }\n\t\n\t        return {\n\t          done: true\n\t        };\n\t      }\n\t    };\n\t  };\n\t}\n\t\n\t/**\n\t * Setter Methods\n\t * ---------------\n\t *\n\t * Those methods are dynamically assigned to the class for DRY reasons.\n\t */\n\t\n\t// Not using a Set so that ES5 consumers don't pay a bundle size price\n\tvar INTRANSITIVE_SETTERS = {\n\t  unset: true,\n\t  pop: true,\n\t  shift: true\n\t};\n\t\n\t/**\n\t * Function creating a setter method for the Cursor class.\n\t *\n\t * @param {string}   name          - the method's name.\n\t * @param {function} [typeChecker] - a function checking that the given value is\n\t *                                   valid for the given operation.\n\t */\n\tfunction makeSetter(name, typeChecker) {\n\t\n\t  /**\n\t   * Binding a setter method to the Cursor class and having the following\n\t   * definition.\n\t   *\n\t   * Note: this is not really possible to make those setters variadic because\n\t   * it would create an impossible polymorphism with path.\n\t   *\n\t   * @todo: perform value validation elsewhere so that tree.update can\n\t   * beneficiate from it.\n\t   *\n\t   * Arity (1):\n\t   * @param  {mixed} value - New value to set at cursor's path.\n\t   *\n\t   * Arity (2):\n\t   * @param  {path}  path  - Subpath to update starting from cursor's.\n\t   * @param  {mixed} value - New value to set.\n\t   *\n\t   * @return {mixed}       - Data at path.\n\t   */\n\t  Cursor.prototype[name] = function (path, value) {\n\t\n\t    // We should warn the user if he applies to many arguments to the function\n\t    if (arguments.length > 2) throw (0, _helpers.makeError)('Baobab.Cursor.' + name + ': too many arguments.');\n\t\n\t    // Handling arities\n\t    if (arguments.length === 1 && !INTRANSITIVE_SETTERS[name]) {\n\t      value = path;\n\t      path = [];\n\t    }\n\t\n\t    // Coerce path\n\t    path = (0, _helpers.coercePath)(path);\n\t\n\t    // Checking the path's validity\n\t    if (!_type2['default'].path(path)) throw (0, _helpers.makeError)('Baobab.Cursor.' + name + ': invalid path.', { path: path });\n\t\n\t    // Checking the value's validity\n\t    if (typeChecker && !typeChecker(value)) throw (0, _helpers.makeError)('Baobab.Cursor.' + name + ': invalid value.', { path: path, value: value });\n\t\n\t    // Checking the solvability of the cursor's dynamic path\n\t    if (!this.solvedPath) throw (0, _helpers.makeError)('Baobab.Cursor.' + name + ': the dynamic path of the cursor cannot be solved.', { path: this.path });\n\t\n\t    var fullPath = this.solvedPath.concat(path);\n\t\n\t    // Filing the update to the tree\n\t    return this.tree.update(fullPath, {\n\t      type: name,\n\t      value: value\n\t    });\n\t  };\n\t}\n\t\n\t/**\n\t * Making the necessary setters.\n\t */\n\tmakeSetter('set');\n\tmakeSetter('unset');\n\tmakeSetter('apply', _type2['default']['function']);\n\tmakeSetter('push');\n\tmakeSetter('concat', _type2['default'].array);\n\tmakeSetter('unshift');\n\tmakeSetter('pop');\n\tmakeSetter('shift');\n\tmakeSetter('splice', _type2['default'].splicer);\n\tmakeSetter('merge', _type2['default'].object);\n\tmakeSetter('deepMerge', _type2['default'].object);\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 28 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Baobab Monkeys\n\t * ===============\n\t *\n\t * Exposing both handy monkey definitions and the underlying working class.\n\t */\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\t\n\tvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\t\n\tvar _type = __webpack_require__(29);\n\t\n\tvar _type2 = _interopRequireDefault(_type);\n\t\n\tvar _update2 = __webpack_require__(30);\n\t\n\tvar _update3 = _interopRequireDefault(_update2);\n\t\n\tvar _helpers = __webpack_require__(31);\n\t\n\t/**\n\t * Monkey Definition class\n\t * Note: The only reason why this is a class is to be able to spot it within\n\t * otherwise ordinary data.\n\t *\n\t * @constructor\n\t * @param {array|object} definition - The formal definition of the monkey.\n\t */\n\t\n\tvar MonkeyDefinition = function MonkeyDefinition(definition) {\n\t  var _this = this;\n\t\n\t  _classCallCheck(this, MonkeyDefinition);\n\t\n\t  var monkeyType = _type2['default'].monkeyDefinition(definition);\n\t\n\t  if (!monkeyType) throw (0, _helpers.makeError)('Baobab.monkey: invalid definition.', { definition: definition });\n\t\n\t  this.type = monkeyType;\n\t\n\t  if (this.type === 'object') {\n\t    this.getter = definition.get;\n\t    this.projection = definition.cursors || {};\n\t    this.paths = Object.keys(this.projection).map(function (k) {\n\t      return _this.projection[k];\n\t    });\n\t    this.options = definition.options || {};\n\t  } else {\n\t    var offset = 1,\n\t        options = {};\n\t\n\t    if (_type2['default'].object(definition[definition.length - 1])) {\n\t      offset++;\n\t      options = definition[definition.length - 1];\n\t    }\n\t\n\t    this.getter = definition[definition.length - offset];\n\t    this.projection = definition.slice(0, -offset);\n\t    this.paths = this.projection;\n\t    this.options = options;\n\t  }\n\t\n\t  // Coercing paths for convenience\n\t  this.paths = this.paths.map(function (p) {\n\t    return [].concat(p);\n\t  });\n\t\n\t  // Does the definition contain dynamic paths\n\t  this.hasDynamicPaths = this.paths.some(_type2['default'].dynamicPath);\n\t}\n\t\n\t/**\n\t * Monkey core class\n\t *\n\t * @constructor\n\t * @param {Baobab}           tree       - The bound tree.\n\t * @param {MonkeyDefinition} definition - A definition instance.\n\t */\n\t;\n\t\n\texports.MonkeyDefinition = MonkeyDefinition;\n\t\n\tvar Monkey = (function () {\n\t  function Monkey(tree, pathInTree, definition) {\n\t    var _this2 = this;\n\t\n\t    _classCallCheck(this, Monkey);\n\t\n\t    // Properties\n\t    this.tree = tree;\n\t    this.path = pathInTree;\n\t    this.definition = definition;\n\t\n\t    // Adapting the definition's paths & projection to this monkey's case\n\t    var projection = definition.projection,\n\t        relative = _helpers.solveRelativePath.bind(null, pathInTree.slice(0, -1));\n\t\n\t    if (definition.type === 'object') {\n\t      this.projection = Object.keys(projection).reduce(function (acc, k) {\n\t        acc[k] = relative(projection[k]);\n\t        return acc;\n\t      }, {});\n\t      this.depPaths = Object.keys(this.projection).map(function (k) {\n\t        return _this2.projection[k];\n\t      });\n\t    } else {\n\t      this.projection = projection.map(relative);\n\t      this.depPaths = this.projection;\n\t    }\n\t\n\t    // Internal state\n\t    this.state = {\n\t      killed: false\n\t    };\n\t\n\t    /**\n\t     * Listener on the tree's `write` event.\n\t     *\n\t     * When the tree writes, this listener will check whether the updated paths\n\t     * are of any use to the monkey and, if so, will update the tree's node\n\t     * where the monkey sits.\n\t     */\n\t    this.writeListener = function (_ref) {\n\t      var path = _ref.data.path;\n\t\n\t      if (_this2.state.killed) return;\n\t\n\t      // Is the monkey affected by the current write event?\n\t      var concerned = (0, _helpers.solveUpdate)([path], _this2.relatedPaths());\n\t\n\t      if (concerned) _this2.update();\n\t    };\n\t\n\t    /**\n\t     * Listener on the tree's `monkey` event.\n\t     *\n\t     * When another monkey updates, this listener will check whether the\n\t     * updated paths are of any use to the monkey and, if so, will update the\n\t     * tree's node where the monkey sits.\n\t     */\n\t    this.recursiveListener = function (_ref2) {\n\t      var _ref2$data = _ref2.data;\n\t      var monkey = _ref2$data.monkey;\n\t      var path = _ref2$data.path;\n\t\n\t      if (_this2.state.killed) return;\n\t\n\t      // Breaking if this is the same monkey\n\t      if (_this2 === monkey) return;\n\t\n\t      // Is the monkey affected by the current monkey event?\n\t      var concerned = (0, _helpers.solveUpdate)([path], _this2.relatedPaths(false));\n\t\n\t      if (concerned) _this2.update();\n\t    };\n\t\n\t    // Binding listeners\n\t    this.tree.on('write', this.writeListener);\n\t    this.tree.on('_monkey', this.recursiveListener);\n\t\n\t    // Updating relevant node\n\t    this.update();\n\t  }\n\t\n\t  /**\n\t   * Method returning solved paths related to the monkey.\n\t   *\n\t   * @param  {boolean} recursive - Should we compute recursive paths?\n\t   * @return {array}             - An array of related paths.\n\t   */\n\t\n\t  _createClass(Monkey, [{\n\t    key: 'relatedPaths',\n\t    value: function relatedPaths() {\n\t      var _this3 = this;\n\t\n\t      var recursive = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];\n\t\n\t      var paths = undefined;\n\t\n\t      if (this.definition.hasDynamicPaths) paths = this.depPaths.map(function (p) {\n\t        return (0, _helpers.getIn)(_this3.tree._data, p).solvedPath;\n\t      });else paths = this.depPaths;\n\t\n\t      var isRecursive = recursive && this.depPaths.some(function (p) {\n\t        return !!_type2['default'].monkeyPath(_this3.tree._monkeys, p);\n\t      });\n\t\n\t      if (!isRecursive) return paths;\n\t\n\t      return paths.reduce(function (accumulatedPaths, path) {\n\t        var monkeyPath = _type2['default'].monkeyPath(_this3.tree._monkeys, path);\n\t\n\t        if (!monkeyPath) return accumulatedPaths.concat([path]);\n\t\n\t        // Solving recursive path\n\t        var relatedMonkey = (0, _helpers.getIn)(_this3.tree._monkeys, monkeyPath).data;\n\t\n\t        return accumulatedPaths.concat(relatedMonkey.relatedPaths());\n\t      }, []);\n\t    }\n\t\n\t    /**\n\t     * Method used to update the tree's internal data with a lazy getter holding\n\t     * the computed data.\n\t     *\n\t     * @return {Monkey} - Returns itself for chaining purposes.\n\t     */\n\t  }, {\n\t    key: 'update',\n\t    value: function update() {\n\t      var deps = this.tree.project(this.projection);\n\t\n\t      var lazyGetter = (function (tree, def, data) {\n\t        var cache = null,\n\t            alreadyComputed = false;\n\t\n\t        return function () {\n\t\n\t          if (!alreadyComputed) {\n\t            cache = def.getter.apply(tree, def.type === 'object' ? [data] : data);\n\t\n\t            if (tree.options.immutable && def.options.immutable !== false) (0, _helpers.deepFreeze)(cache);\n\t\n\t            alreadyComputed = true;\n\t          }\n\t\n\t          return cache;\n\t        };\n\t      })(this.tree, this.definition, deps);\n\t\n\t      lazyGetter.isLazyGetter = true;\n\t\n\t      // Should we write the lazy getter in the tree or solve it right now?\n\t      if (this.tree.options.lazyMonkeys) {\n\t        this.tree._data = (0, _update3['default'])(this.tree._data, this.path, {\n\t          type: 'monkey',\n\t          value: lazyGetter\n\t        }, this.tree.options).data;\n\t      } else {\n\t        var result = (0, _update3['default'])(this.tree._data, this.path, {\n\t          type: 'set',\n\t          value: lazyGetter(),\n\t          options: {\n\t            mutableLeaf: !this.definition.options.immutable\n\t          }\n\t        }, this.tree.options);\n\t\n\t        if ('data' in result) this.tree._data = result.data;\n\t      }\n\t\n\t      // Notifying the monkey's update so we can handle recursivity\n\t      this.tree.emit('_monkey', { monkey: this, path: this.path });\n\t\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Method releasing the monkey from memory.\n\t     */\n\t  }, {\n\t    key: 'release',\n\t    value: function release() {\n\t\n\t      // Unbinding events\n\t      this.tree.off('write', this.writeListener);\n\t      this.tree.off('_monkey', this.monkeyListener);\n\t      this.state.killed = true;\n\t\n\t      // Deleting properties\n\t      // NOTE: not deleting this.definition because some strange things happen\n\t      // in the _refreshMonkeys method. See #372.\n\t      delete this.projection;\n\t      delete this.depPaths;\n\t      delete this.tree;\n\t    }\n\t  }]);\n\t\n\t  return Monkey;\n\t})();\n\t\n\texports.Monkey = Monkey;\n\n/***/ },\n/* 29 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Baobab Type Checking\n\t * =====================\n\t *\n\t * Helpers functions used throughout the library to perform some type\n\t * tests at runtime.\n\t *\n\t */\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\t\n\tvar _monkey = __webpack_require__(28);\n\t\n\tvar type = {};\n\t\n\t/**\n\t * Helpers\n\t * --------\n\t */\n\t\n\t/**\n\t * Checking whether the given variable is of any of the given types.\n\t *\n\t * @todo   Optimize this function by dropping `some`.\n\t *\n\t * @param  {mixed} target  - Variable to test.\n\t * @param  {array} allowed - Array of allowed types.\n\t * @return {boolean}\n\t */\n\tfunction anyOf(target, allowed) {\n\t  return allowed.some(function (t) {\n\t    return type[t](target);\n\t  });\n\t}\n\t\n\t/**\n\t * Simple types\n\t * -------------\n\t */\n\t\n\t/**\n\t * Checking whether the given variable is an array.\n\t *\n\t * @param  {mixed} target - Variable to test.\n\t * @return {boolean}\n\t */\n\ttype.array = function (target) {\n\t  return Array.isArray(target);\n\t};\n\t\n\t/**\n\t * Checking whether the given variable is an object.\n\t *\n\t * @param  {mixed} target - Variable to test.\n\t * @return {boolean}\n\t */\n\ttype.object = function (target) {\n\t  return target && typeof target === 'object' && !Array.isArray(target) && !(target instanceof Date) && !(target instanceof RegExp) && !(typeof Map === 'function' && target instanceof Map) && !(typeof Set === 'function' && target instanceof Set);\n\t};\n\t\n\t/**\n\t * Checking whether the given variable is a string.\n\t *\n\t * @param  {mixed} target - Variable to test.\n\t * @return {boolean}\n\t */\n\ttype.string = function (target) {\n\t  return typeof target === 'string';\n\t};\n\t\n\t/**\n\t * Checking whether the given variable is a number.\n\t *\n\t * @param  {mixed} target - Variable to test.\n\t * @return {boolean}\n\t */\n\ttype.number = function (target) {\n\t  return typeof target === 'number';\n\t};\n\t\n\t/**\n\t * Checking whether the given variable is a function.\n\t *\n\t * @param  {mixed} target - Variable to test.\n\t * @return {boolean}\n\t */\n\ttype['function'] = function (target) {\n\t  return typeof target === 'function';\n\t};\n\t\n\t/**\n\t * Checking whether the given variable is a JavaScript primitive.\n\t *\n\t * @param  {mixed} target - Variable to test.\n\t * @return {boolean}\n\t */\n\ttype.primitive = function (target) {\n\t  return target !== Object(target);\n\t};\n\t\n\t/**\n\t * Complex types\n\t * --------------\n\t */\n\t\n\t/**\n\t * Checking whether the given variable is a valid splicer.\n\t *\n\t * @param  {mixed} target    - Variable to test.\n\t * @param  {array} [allowed] - Optional valid types in path.\n\t * @return {boolean}\n\t */\n\ttype.splicer = function (target) {\n\t  if (!type.array(target) || target.length < 2) return false;\n\t\n\t  return anyOf(target[0], ['number', 'function', 'object']) && type.number(target[1]);\n\t};\n\t\n\t/**\n\t * Checking whether the given variable is a valid cursor path.\n\t *\n\t * @param  {mixed} target    - Variable to test.\n\t * @param  {array} [allowed] - Optional valid types in path.\n\t * @return {boolean}\n\t */\n\t\n\t// Order is important for performance reasons\n\tvar ALLOWED_FOR_PATH = ['string', 'number', 'function', 'object'];\n\t\n\ttype.path = function (target) {\n\t  if (!target && target !== 0 && target !== '') return false;\n\t\n\t  return [].concat(target).every(function (step) {\n\t    return anyOf(step, ALLOWED_FOR_PATH);\n\t  });\n\t};\n\t\n\t/**\n\t * Checking whether the given path is a dynamic one.\n\t *\n\t * @param  {mixed} path - The path to test.\n\t * @return {boolean}\n\t */\n\ttype.dynamicPath = function (path) {\n\t  return path.some(function (step) {\n\t    return type['function'](step) || type.object(step);\n\t  });\n\t};\n\t\n\t/**\n\t * Retrieve any monkey subpath in the given path or null if the path never comes\n\t * across computed data.\n\t *\n\t * @param  {mixed} data - The data to test.\n\t * @param  {array} path - The path to test.\n\t * @return {boolean}\n\t */\n\ttype.monkeyPath = function (data, path) {\n\t  var subpath = [];\n\t\n\t  var c = data,\n\t      i = undefined,\n\t      l = undefined;\n\t\n\t  for (i = 0, l = path.length; i < l; i++) {\n\t    subpath.push(path[i]);\n\t\n\t    if (typeof c !== 'object') return null;\n\t\n\t    c = c[path[i]];\n\t\n\t    if (c instanceof _monkey.Monkey) return subpath;\n\t  }\n\t\n\t  return null;\n\t};\n\t\n\t/**\n\t * Check if the given object property is a lazy getter used by a monkey.\n\t *\n\t * @param  {mixed}   o           - The target object.\n\t * @param  {string}  propertyKey - The property to test.\n\t * @return {boolean}\n\t */\n\ttype.lazyGetter = function (o, propertyKey) {\n\t  var descriptor = Object.getOwnPropertyDescriptor(o, propertyKey);\n\t\n\t  return descriptor && descriptor.get && descriptor.get.isLazyGetter === true;\n\t};\n\t\n\t/**\n\t * Returns the type of the given monkey definition or `null` if invalid.\n\t *\n\t * @param  {mixed} definition - The definition to check.\n\t * @return {string|null}\n\t */\n\ttype.monkeyDefinition = function (definition) {\n\t\n\t  if (type.object(definition)) {\n\t    if (!type['function'](definition.get) || definition.cursors && (!type.object(definition.cursors) || !Object.keys(definition.cursors).every(function (k) {\n\t      return type.path(definition.cursors[k]);\n\t    }))) return null;\n\t\n\t    return 'object';\n\t  } else if (type.array(definition)) {\n\t    var offset = 1;\n\t\n\t    if (type.object(definition[definition.length - 1])) offset++;\n\t\n\t    if (!type['function'](definition[definition.length - offset]) || !definition.slice(0, -offset).every(function (p) {\n\t      return type.path(p);\n\t    })) return null;\n\t\n\t    return 'array';\n\t  }\n\t\n\t  return null;\n\t};\n\t\n\t/**\n\t * Checking whether the given watcher definition is valid.\n\t *\n\t * @param  {mixed}   definition - The definition to check.\n\t * @return {boolean}\n\t */\n\ttype.watcherMapping = function (definition) {\n\t  return type.object(definition) && Object.keys(definition).every(function (k) {\n\t    return type.path(definition[k]);\n\t  });\n\t};\n\t\n\t/**\n\t * Checking whether the given string is a valid operation type.\n\t *\n\t * @param  {mixed} string - The string to test.\n\t * @return {boolean}\n\t */\n\t\n\t// Ordered by likeliness\n\tvar VALID_OPERATIONS = ['set', 'apply', 'push', 'unshift', 'concat', 'pop', 'shift', 'deepMerge', 'merge', 'splice', 'unset'];\n\t\n\ttype.operationType = function (string) {\n\t  return typeof string === 'string' && !! ~VALID_OPERATIONS.indexOf(string);\n\t};\n\t\n\texports['default'] = type;\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 30 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Baobab Update\n\t * ==============\n\t *\n\t * The tree's update scheme.\n\t */\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\texports['default'] = update;\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }\n\t\n\tvar _type = __webpack_require__(29);\n\t\n\tvar _type2 = _interopRequireDefault(_type);\n\t\n\tvar _helpers = __webpack_require__(31);\n\t\n\tfunction err(operation, expectedTarget, path) {\n\t  return (0, _helpers.makeError)('Baobab.update: cannot apply the \"' + operation + '\" on ' + ('a non ' + expectedTarget + ' (path: /' + path.join('/') + ').'), { path: path });\n\t}\n\t\n\t/**\n\t * Function aiming at applying a single update operation on the given tree's\n\t * data.\n\t *\n\t * @param  {mixed}  data      - The tree's data.\n\t * @param  {path}   path      - Path of the update.\n\t * @param  {object} operation - The operation to apply.\n\t * @param  {object} [opts]    - Optional options.\n\t * @return {mixed}            - Both the new tree's data and the updated node.\n\t */\n\t\n\tfunction update(data, path, operation) {\n\t  var opts = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];\n\t  var operationType = operation.type;\n\t  var value = operation.value;\n\t  var _operation$options = operation.options;\n\t  var operationOptions = _operation$options === undefined ? {} : _operation$options;\n\t\n\t  // Dummy root, so we can shift and alter the root\n\t  var dummy = { root: data },\n\t      dummyPath = ['root'].concat(_toConsumableArray(path)),\n\t      currentPath = [];\n\t\n\t  // Walking the path\n\t  var p = dummy,\n\t      i = undefined,\n\t      l = undefined,\n\t      s = undefined;\n\t\n\t  for (i = 0, l = dummyPath.length; i < l; i++) {\n\t\n\t    // Current item's reference is therefore p[s]\n\t    // The reason why we don't create a variable here for convenience\n\t    // is because we actually need to mutate the reference.\n\t    s = dummyPath[i];\n\t\n\t    // Updating the path\n\t    if (i > 0) currentPath.push(s);\n\t\n\t    // If we reached the end of the path, we apply the operation\n\t    if (i === l - 1) {\n\t\n\t      /**\n\t       * Set\n\t       */\n\t      if (operationType === 'set') {\n\t\n\t        // Purity check\n\t        if (opts.pure && p[s] === value) return { node: p[s] };\n\t\n\t        if (_type2['default'].lazyGetter(p, s)) {\n\t          Object.defineProperty(p, s, {\n\t            value: value,\n\t            enumerable: true,\n\t            configurable: true\n\t          });\n\t        } else if (opts.persistent && !operationOptions.mutableLeaf) {\n\t          p[s] = (0, _helpers.shallowClone)(value);\n\t        } else {\n\t          p[s] = value;\n\t        }\n\t      }\n\t\n\t      /**\n\t       * Monkey\n\t       */\n\t      else if (operationType === 'monkey') {\n\t          Object.defineProperty(p, s, {\n\t            get: value,\n\t            enumerable: true,\n\t            configurable: true\n\t          });\n\t        }\n\t\n\t        /**\n\t         * Apply\n\t         */\n\t        else if (operationType === 'apply') {\n\t            var result = value(p[s]);\n\t\n\t            // Purity check\n\t            if (opts.pure && p[s] === result) return { node: p[s] };\n\t\n\t            if (_type2['default'].lazyGetter(p, s)) {\n\t              Object.defineProperty(p, s, {\n\t                value: result,\n\t                enumerable: true,\n\t                configurable: true\n\t              });\n\t            } else if (opts.persistent) {\n\t              p[s] = (0, _helpers.shallowClone)(result);\n\t            } else {\n\t              p[s] = result;\n\t            }\n\t          }\n\t\n\t          /**\n\t           * Push\n\t           */\n\t          else if (operationType === 'push') {\n\t              if (!_type2['default'].array(p[s])) throw err('push', 'array', currentPath);\n\t\n\t              if (opts.persistent) p[s] = p[s].concat([value]);else p[s].push(value);\n\t            }\n\t\n\t            /**\n\t             * Unshift\n\t             */\n\t            else if (operationType === 'unshift') {\n\t                if (!_type2['default'].array(p[s])) throw err('unshift', 'array', currentPath);\n\t\n\t                if (opts.persistent) p[s] = [value].concat(p[s]);else p[s].unshift(value);\n\t              }\n\t\n\t              /**\n\t               * Concat\n\t               */\n\t              else if (operationType === 'concat') {\n\t                  if (!_type2['default'].array(p[s])) throw err('concat', 'array', currentPath);\n\t\n\t                  if (opts.persistent) p[s] = p[s].concat(value);else p[s].push.apply(p[s], value);\n\t                }\n\t\n\t                /**\n\t                 * Splice\n\t                 */\n\t                else if (operationType === 'splice') {\n\t                    if (!_type2['default'].array(p[s])) throw err('splice', 'array', currentPath);\n\t\n\t                    if (opts.persistent) p[s] = _helpers.splice.apply(null, [p[s]].concat(value));else p[s].splice.apply(p[s], value);\n\t                  }\n\t\n\t                  /**\n\t                   * Pop\n\t                   */\n\t                  else if (operationType === 'pop') {\n\t                      if (!_type2['default'].array(p[s])) throw err('pop', 'array', currentPath);\n\t\n\t                      if (opts.persistent) p[s] = (0, _helpers.splice)(p[s], -1, 1);else p[s].pop();\n\t                    }\n\t\n\t                    /**\n\t                     * Shift\n\t                     */\n\t                    else if (operationType === 'shift') {\n\t                        if (!_type2['default'].array(p[s])) throw err('shift', 'array', currentPath);\n\t\n\t                        if (opts.persistent) p[s] = (0, _helpers.splice)(p[s], 0, 1);else p[s].shift();\n\t                      }\n\t\n\t                      /**\n\t                       * Unset\n\t                       */\n\t                      else if (operationType === 'unset') {\n\t                          if (_type2['default'].object(p)) delete p[s];else if (_type2['default'].array(p)) p.splice(s, 1);\n\t                        }\n\t\n\t                        /**\n\t                         * Merge\n\t                         */\n\t                        else if (operationType === 'merge') {\n\t                            if (!_type2['default'].object(p[s])) throw err('merge', 'object', currentPath);\n\t\n\t                            if (opts.persistent) p[s] = (0, _helpers.shallowMerge)({}, p[s], value);else p[s] = (0, _helpers.shallowMerge)(p[s], value);\n\t                          }\n\t\n\t                          /**\n\t                           * Deep merge\n\t                           */\n\t                          else if (operationType === 'deepMerge') {\n\t                              if (!_type2['default'].object(p[s])) throw err('deepMerge', 'object', currentPath);\n\t\n\t                              if (opts.persistent) p[s] = (0, _helpers.deepMerge)({}, p[s], value);else p[s] = (0, _helpers.deepMerge)(p[s], value);\n\t                            }\n\t\n\t      // Deep freezing the resulting value\n\t      if (opts.immutable && !operationOptions.mutableLeaf) (0, _helpers.deepFreeze)(p);\n\t\n\t      break;\n\t    }\n\t\n\t    // If we reached a leaf, we override by setting an empty object\n\t    else if (_type2['default'].primitive(p[s])) {\n\t        p[s] = {};\n\t      }\n\t\n\t      // Else, we shift the reference and continue the path\n\t      else if (opts.persistent) {\n\t          p[s] = (0, _helpers.shallowClone)(p[s]);\n\t        }\n\t\n\t    // Should we freeze the current step before continuing?\n\t    if (opts.immutable && l > 0) (0, _helpers.freeze)(p);\n\t\n\t    p = p[s];\n\t  }\n\t\n\t  // If we are updating a dynamic node, we need not return the affected node\n\t  if (_type2['default'].lazyGetter(p, s)) return { data: dummy.root };\n\t\n\t  // Returning new data object\n\t  return { data: dummy.root, node: p[s] };\n\t}\n\t\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 31 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {/* eslint eqeqeq: 0 */\n\t\n\t/**\n\t * Baobab Helpers\n\t * ===============\n\t *\n\t * Miscellaneous helper functions.\n\t */\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\t\n\tvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\t\n\texports.arrayFrom = arrayFrom;\n\texports.before = before;\n\texports.coercePath = coercePath;\n\texports.getIn = getIn;\n\texports.makeError = makeError;\n\texports.solveRelativePath = solveRelativePath;\n\texports.solveUpdate = solveUpdate;\n\texports.splice = splice;\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\t\n\tvar _monkey = __webpack_require__(28);\n\t\n\tvar _type = __webpack_require__(29);\n\t\n\tvar _type2 = _interopRequireDefault(_type);\n\t\n\t/**\n\t * Noop function\n\t */\n\tvar noop = Function.prototype;\n\t\n\t/**\n\t * Function returning the index of the first element of a list matching the\n\t * given predicate.\n\t *\n\t * @param  {array}     a  - The target array.\n\t * @param  {function}  fn - The predicate function.\n\t * @return {mixed}        - The index of the first matching item or -1.\n\t */\n\tfunction index(a, fn) {\n\t  var i = undefined,\n\t      l = undefined;\n\t  for (i = 0, l = a.length; i < l; i++) {\n\t    if (fn(a[i])) return i;\n\t  }\n\t  return -1;\n\t}\n\t\n\t/**\n\t * Efficient slice function used to clone arrays or parts of them.\n\t *\n\t * @param  {array} array - The array to slice.\n\t * @return {array}       - The sliced array.\n\t */\n\tfunction slice(array) {\n\t  var newArray = new Array(array.length);\n\t\n\t  var i = undefined,\n\t      l = undefined;\n\t\n\t  for (i = 0, l = array.length; i < l; i++) newArray[i] = array[i];\n\t\n\t  return newArray;\n\t}\n\t\n\t/**\n\t * Archive abstraction\n\t *\n\t * @constructor\n\t * @param {integer} size - Maximum number of records to store.\n\t */\n\t\n\tvar Archive = (function () {\n\t  function Archive(size) {\n\t    _classCallCheck(this, Archive);\n\t\n\t    this.size = size;\n\t    this.records = [];\n\t  }\n\t\n\t  /**\n\t   * Function creating a real array from what should be an array but is not.\n\t   * I'm looking at you nasty `arguments`...\n\t   *\n\t   * @param  {mixed} culprit - The culprit to convert.\n\t   * @return {array}         - The real array.\n\t   */\n\t\n\t  /**\n\t   * Method retrieving the records.\n\t   *\n\t   * @return {array} - The records.\n\t   */\n\t\n\t  _createClass(Archive, [{\n\t    key: 'get',\n\t    value: function get() {\n\t      return this.records;\n\t    }\n\t\n\t    /**\n\t     * Method adding a record to the archive\n\t     *\n\t     * @param {object}  record - The record to store.\n\t     * @return {Archive}       - The archive itself for chaining purposes.\n\t     */\n\t  }, {\n\t    key: 'add',\n\t    value: function add(record) {\n\t      this.records.unshift(record);\n\t\n\t      // If the number of records is exceeded, we truncate the records\n\t      if (this.records.length > this.size) this.records.length = this.size;\n\t\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Method clearing the records.\n\t     *\n\t     * @return {Archive} - The archive itself for chaining purposes.\n\t     */\n\t  }, {\n\t    key: 'clear',\n\t    value: function clear() {\n\t      this.records = [];\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Method to go back in time.\n\t     *\n\t     * @param {integer} steps - Number of steps we should go back by.\n\t     * @return {number}       - The last record.\n\t     */\n\t  }, {\n\t    key: 'back',\n\t    value: function back(steps) {\n\t      var record = this.records[steps - 1];\n\t\n\t      if (record) this.records = this.records.slice(steps);\n\t      return record;\n\t    }\n\t  }]);\n\t\n\t  return Archive;\n\t})();\n\t\n\texports.Archive = Archive;\n\t\n\tfunction arrayFrom(culprit) {\n\t  return slice(culprit);\n\t}\n\t\n\t/**\n\t * Function decorating one function with another that will be called before the\n\t * decorated one.\n\t *\n\t * @param  {function} decorator - The decorating function.\n\t * @param  {function} fn        - The function to decorate.\n\t * @return {function}           - The decorated function.\n\t */\n\t\n\tfunction before(decorator, fn) {\n\t  return function () {\n\t    decorator.apply(null, arguments);\n\t    fn.apply(null, arguments);\n\t  };\n\t}\n\t\n\t/**\n\t * Function cloning the given regular expression. Supports `y` and `u` flags\n\t * already.\n\t *\n\t * @param  {RegExp} re - The target regular expression.\n\t * @return {RegExp}    - The cloned regular expression.\n\t */\n\tfunction cloneRegexp(re) {\n\t  var pattern = re.source;\n\t\n\t  var flags = '';\n\t\n\t  if (re.global) flags += 'g';\n\t  if (re.multiline) flags += 'm';\n\t  if (re.ignoreCase) flags += 'i';\n\t  if (re.sticky) flags += 'y';\n\t  if (re.unicode) flags += 'u';\n\t\n\t  return new RegExp(pattern, flags);\n\t}\n\t\n\t/**\n\t * Function cloning the given variable.\n\t *\n\t * @todo: implement a faster way to clone an array.\n\t *\n\t * @param  {boolean} deep - Should we deep clone the variable.\n\t * @param  {mixed}   item - The variable to clone\n\t * @return {mixed}        - The cloned variable.\n\t */\n\tfunction cloner(deep, item) {\n\t  if (!item || typeof item !== 'object' || item instanceof Error || item instanceof _monkey.MonkeyDefinition || item instanceof _monkey.Monkey || 'ArrayBuffer' in global && item instanceof ArrayBuffer) return item;\n\t\n\t  // Array\n\t  if (_type2['default'].array(item)) {\n\t    if (deep) {\n\t      var a = [];\n\t\n\t      var i = undefined,\n\t          l = undefined;\n\t\n\t      for (i = 0, l = item.length; i < l; i++) a.push(cloner(true, item[i]));\n\t      return a;\n\t    }\n\t\n\t    return slice(item);\n\t  }\n\t\n\t  // Date\n\t  if (item instanceof Date) return new Date(item.getTime());\n\t\n\t  // RegExp\n\t  if (item instanceof RegExp) return cloneRegexp(item);\n\t\n\t  // Object\n\t  if (_type2['default'].object(item)) {\n\t    var o = {};\n\t\n\t    var k = undefined;\n\t\n\t    // NOTE: could be possible to erase computed properties through `null`.\n\t    for (k in item) {\n\t      if (_type2['default'].lazyGetter(item, k)) {\n\t        Object.defineProperty(o, k, {\n\t          get: Object.getOwnPropertyDescriptor(item, k).get,\n\t          enumerable: true,\n\t          configurable: true\n\t        });\n\t      } else if (item.hasOwnProperty(k)) {\n\t        o[k] = deep ? cloner(true, item[k]) : item[k];\n\t      }\n\t    }\n\t    return o;\n\t  }\n\t\n\t  return item;\n\t}\n\t\n\t/**\n\t * Exporting shallow and deep cloning functions.\n\t */\n\tvar shallowClone = cloner.bind(null, false),\n\t    deepClone = cloner.bind(null, true);\n\t\n\texports.shallowClone = shallowClone;\n\texports.deepClone = deepClone;\n\t\n\t/**\n\t * Coerce the given variable into a full-fledged path.\n\t *\n\t * @param  {mixed} target - The variable to coerce.\n\t * @return {array}        - The array path.\n\t */\n\t\n\tfunction coercePath(target) {\n\t  if (target || target === 0 || target === '') return target;\n\t  return [];\n\t}\n\t\n\t/**\n\t * Function comparing an object's properties to a given descriptive\n\t * object.\n\t *\n\t * @param  {object} object      - The object to compare.\n\t * @param  {object} description - The description's mapping.\n\t * @return {boolean}            - Whether the object matches the description.\n\t */\n\tfunction compare(object, description) {\n\t  var ok = true,\n\t      k = undefined;\n\t\n\t  // If we reached here via a recursive call, object may be undefined because\n\t  // not all items in a collection will have the same deep nesting structure.\n\t  if (!object) return false;\n\t\n\t  for (k in description) {\n\t    if (_type2['default'].object(description[k])) {\n\t      ok = ok && compare(object[k], description[k]);\n\t    } else if (_type2['default'].array(description[k])) {\n\t      ok = ok && !! ~description[k].indexOf(object[k]);\n\t    } else {\n\t      if (object[k] !== description[k]) return false;\n\t    }\n\t  }\n\t\n\t  return ok;\n\t}\n\t\n\t/**\n\t * Function freezing the given variable if possible.\n\t *\n\t * @param  {boolean} deep - Should we recursively freeze the given objects?\n\t * @param  {object}  o    - The variable to freeze.\n\t * @return {object}    - The merged object.\n\t */\n\tfunction freezer(deep, o) {\n\t  if (typeof o !== 'object' || o === null || o instanceof _monkey.Monkey) return;\n\t\n\t  Object.freeze(o);\n\t\n\t  if (!deep) return;\n\t\n\t  if (Array.isArray(o)) {\n\t\n\t    // Iterating through the elements\n\t    var i = undefined,\n\t        l = undefined;\n\t\n\t    for (i = 0, l = o.length; i < l; i++) freezer(true, o[i]);\n\t  } else {\n\t    var p = undefined,\n\t        k = undefined;\n\t\n\t    for (k in o) {\n\t      if (_type2['default'].lazyGetter(o, k)) continue;\n\t\n\t      p = o[k];\n\t\n\t      if (!p || !o.hasOwnProperty(k) || typeof p !== 'object' || Object.isFrozen(p)) continue;\n\t\n\t      freezer(true, p);\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t * Exporting both `freeze` and `deepFreeze` functions.\n\t * Note that if the engine does not support `Object.freeze` then this will\n\t * export noop functions instead.\n\t */\n\tvar isFreezeSupported = typeof Object.freeze === 'function';\n\t\n\tvar freeze = isFreezeSupported ? freezer.bind(null, false) : noop,\n\t    deepFreeze = isFreezeSupported ? freezer.bind(null, true) : noop;\n\t\n\texports.freeze = freeze;\n\texports.deepFreeze = deepFreeze;\n\t\n\t/**\n\t * Function retrieving nested data within the given object and according to\n\t * the given path.\n\t *\n\t * @todo: work if dynamic path hit objects also.\n\t * @todo: memoized perfgetters.\n\t *\n\t * @param  {object}  object - The object we need to get data from.\n\t * @param  {array}   path   - The path to follow.\n\t * @return {object}  result            - The result.\n\t * @return {mixed}   result.data       - The data at path, or `undefined`.\n\t * @return {array}   result.solvedPath - The solved path or `null`.\n\t * @return {boolean} result.exists     - Does the path exists in the tree?\n\t */\n\tvar NOT_FOUND_OBJECT = { data: undefined, solvedPath: null, exists: false };\n\t\n\tfunction getIn(object, path) {\n\t  if (!path) return NOT_FOUND_OBJECT;\n\t\n\t  var solvedPath = [];\n\t\n\t  var exists = true,\n\t      c = object,\n\t      idx = undefined,\n\t      i = undefined,\n\t      l = undefined;\n\t\n\t  for (i = 0, l = path.length; i < l; i++) {\n\t    if (!c) return {\n\t      data: undefined,\n\t      solvedPath: solvedPath.concat(path.slice(i)),\n\t      exists: false\n\t    };\n\t\n\t    if (typeof path[i] === 'function') {\n\t      if (!_type2['default'].array(c)) return NOT_FOUND_OBJECT;\n\t\n\t      idx = index(c, path[i]);\n\t      if (! ~idx) return NOT_FOUND_OBJECT;\n\t\n\t      solvedPath.push(idx);\n\t      c = c[idx];\n\t    } else if (typeof path[i] === 'object') {\n\t      if (!_type2['default'].array(c)) return NOT_FOUND_OBJECT;\n\t\n\t      idx = index(c, function (e) {\n\t        return compare(e, path[i]);\n\t      });\n\t      if (! ~idx) return NOT_FOUND_OBJECT;\n\t\n\t      solvedPath.push(idx);\n\t      c = c[idx];\n\t    } else {\n\t      solvedPath.push(path[i]);\n\t      exists = typeof c === 'object' && path[i] in c;\n\t      c = c[path[i]];\n\t    }\n\t  }\n\t\n\t  return { data: c, solvedPath: solvedPath, exists: exists };\n\t}\n\t\n\t/**\n\t * Little helper returning a JavaScript error carrying some data with it.\n\t *\n\t * @param  {string} message - The error message.\n\t * @param  {object} [data]  - Optional data to assign to the error.\n\t * @return {Error}          - The created error.\n\t */\n\t\n\tfunction makeError(message, data) {\n\t  var err = new Error(message);\n\t\n\t  for (var k in data) {\n\t    err[k] = data[k];\n\t  }return err;\n\t}\n\t\n\t/**\n\t * Function taking n objects to merge them together.\n\t * Note 1): the latter object will take precedence over the first one.\n\t * Note 2): the first object will be mutated to allow for perf scenarios.\n\t * Note 3): this function will consider monkeys as leaves.\n\t *\n\t * @param  {boolean}   deep    - Whether the merge should be deep or not.\n\t * @param  {...object} objects - Objects to merge.\n\t * @return {object}            - The merged object.\n\t */\n\tfunction merger(deep) {\n\t  for (var _len = arguments.length, objects = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t    objects[_key - 1] = arguments[_key];\n\t  }\n\t\n\t  var o = objects[0];\n\t\n\t  var t = undefined,\n\t      i = undefined,\n\t      l = undefined,\n\t      k = undefined;\n\t\n\t  for (i = 1, l = objects.length; i < l; i++) {\n\t    t = objects[i];\n\t\n\t    for (k in t) {\n\t      if (deep && _type2['default'].object(t[k]) && !(t[k] instanceof _monkey.Monkey)) {\n\t        o[k] = merger(true, o[k] || {}, t[k]);\n\t      } else {\n\t        o[k] = t[k];\n\t      }\n\t    }\n\t  }\n\t\n\t  return o;\n\t}\n\t\n\t/**\n\t * Exporting both `shallowMerge` and `deepMerge` functions.\n\t */\n\tvar shallowMerge = merger.bind(null, false),\n\t    deepMerge = merger.bind(null, true);\n\t\n\texports.shallowMerge = shallowMerge;\n\texports.deepMerge = deepMerge;\n\t\n\t/**\n\t * Solving a potentially relative path.\n\t *\n\t * @param  {array} base - The base path from which to solve the path.\n\t * @param  {array} to   - The subpath to reach.\n\t * @param  {array}      - The solved absolute path.\n\t */\n\t\n\tfunction solveRelativePath(base, to) {\n\t  var solvedPath = [];\n\t\n\t  // Coercing to array\n\t  to = [].concat(to);\n\t\n\t  for (var i = 0, l = to.length; i < l; i++) {\n\t    var step = to[i];\n\t\n\t    if (step === '.') {\n\t      if (!i) solvedPath = base.slice(0);\n\t    } else if (step === '..') {\n\t      solvedPath = (!i ? base : solvedPath).slice(0, -1);\n\t    } else {\n\t      solvedPath.push(step);\n\t    }\n\t  }\n\t\n\t  return solvedPath;\n\t}\n\t\n\t/**\n\t * Function determining whether some paths in the tree were affected by some\n\t * updates that occurred at the given paths. This helper is mainly used at\n\t * cursor level to determine whether the cursor is concerned by the updates\n\t * fired at tree level.\n\t *\n\t * NOTES: 1) If performance become an issue, the following threefold loop\n\t *           can be simplified to a complex twofold one.\n\t *        2) A regex version could also work but I am not confident it would\n\t *           be faster.\n\t *        3) Another solution would be to keep a register of cursors like with\n\t *           the monkeys and update along this tree.\n\t *\n\t * @param  {array} affectedPaths - The paths that were updated.\n\t * @param  {array} comparedPaths - The paths that we are actually interested in.\n\t * @return {boolean}             - Is the update relevant to the compared\n\t *                                 paths?\n\t */\n\t\n\tfunction solveUpdate(affectedPaths, comparedPaths) {\n\t  var i = undefined,\n\t      j = undefined,\n\t      k = undefined,\n\t      l = undefined,\n\t      m = undefined,\n\t      n = undefined,\n\t      p = undefined,\n\t      c = undefined,\n\t      s = undefined;\n\t\n\t  // Looping through possible paths\n\t  for (i = 0, l = affectedPaths.length; i < l; i++) {\n\t    p = affectedPaths[i];\n\t\n\t    if (!p.length) return true;\n\t\n\t    // Looping through logged paths\n\t    for (j = 0, m = comparedPaths.length; j < m; j++) {\n\t      c = comparedPaths[j];\n\t\n\t      if (!c || !c.length) return true;\n\t\n\t      // Looping through steps\n\t      for (k = 0, n = c.length; k < n; k++) {\n\t        s = c[k];\n\t\n\t        // If path is not relevant, we break\n\t        // NOTE: the '!=' instead of '!==' is required here!\n\t        if (s != p[k]) break;\n\t\n\t        // If we reached last item and we are relevant\n\t        if (k + 1 === n || k + 1 === p.length) return true;\n\t      }\n\t    }\n\t  }\n\t\n\t  return false;\n\t}\n\t\n\t/**\n\t * Non-mutative version of the splice array method.\n\t *\n\t * @param  {array}    array        - The array to splice.\n\t * @param  {integer}  startIndex   - The start index.\n\t * @param  {integer}  nb           - Number of elements to remove.\n\t * @param  {...mixed} elements     - Elements to append after splicing.\n\t * @return {array}                 - The spliced array.\n\t */\n\t\n\tfunction splice(array, startIndex, nb) {\n\t  nb = Math.max(0, nb);\n\t\n\t  // Solving startIndex\n\t  if (_type2['default']['function'](startIndex)) startIndex = index(array, startIndex);\n\t  if (_type2['default'].object(startIndex)) startIndex = index(array, function (e) {\n\t    return compare(e, startIndex);\n\t  });\n\t\n\t  // Positive index\n\t\n\t  for (var _len2 = arguments.length, elements = Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {\n\t    elements[_key2 - 3] = arguments[_key2];\n\t  }\n\t\n\t  if (startIndex >= 0) return array.slice(0, startIndex).concat(elements).concat(array.slice(startIndex + nb));\n\t\n\t  // Negative index\n\t  return array.slice(0, array.length + startIndex).concat(elements).concat(array.slice(array.length + startIndex + nb));\n\t}\n\t\n\t/**\n\t * Function returning a unique incremental id each time it is called.\n\t *\n\t * @return {integer} - The latest unique id.\n\t */\n\tvar uniqid = (function () {\n\t  var i = 0;\n\t\n\t  return function () {\n\t    return i++;\n\t  };\n\t})();\n\t\n\texports.uniqid = uniqid;\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 32 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Baobab Watchers\n\t * ================\n\t *\n\t * Abstraction used to listen and retrieve data from multiple parts of a\n\t * Baobab tree at once.\n\t */\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\t\n\tvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\t\n\tvar _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar _emmett = __webpack_require__(26);\n\t\n\tvar _emmett2 = _interopRequireDefault(_emmett);\n\t\n\tvar _cursor = __webpack_require__(27);\n\t\n\tvar _cursor2 = _interopRequireDefault(_cursor);\n\t\n\tvar _type = __webpack_require__(29);\n\t\n\tvar _type2 = _interopRequireDefault(_type);\n\t\n\tvar _helpers = __webpack_require__(31);\n\t\n\t/**\n\t * Watcher class.\n\t *\n\t * @constructor\n\t * @param {Baobab} tree     - The watched tree.\n\t * @param {object} mapping  - A mapping of the paths to watch in the tree.\n\t */\n\t\n\tvar Watcher = (function (_Emitter) {\n\t  _inherits(Watcher, _Emitter);\n\t\n\t  function Watcher(tree, mapping) {\n\t    var _this = this;\n\t\n\t    _classCallCheck(this, Watcher);\n\t\n\t    _get(Object.getPrototypeOf(Watcher.prototype), 'constructor', this).call(this);\n\t\n\t    // Properties\n\t    this.tree = tree;\n\t    this.mapping = null;\n\t\n\t    this.state = {\n\t      killed: false\n\t    };\n\t\n\t    // Initializing\n\t    this.refresh(mapping);\n\t\n\t    // Listening\n\t    this.handler = function (e) {\n\t      if (_this.state.killed) return;\n\t\n\t      var watchedPaths = _this.getWatchedPaths();\n\t\n\t      if ((0, _helpers.solveUpdate)(e.data.paths, watchedPaths)) return _this.emit('update');\n\t    };\n\t\n\t    this.tree.on('update', this.handler);\n\t  }\n\t\n\t  /**\n\t   * Method used to get the current watched paths.\n\t   *\n\t   * @return {array} - The array of watched paths.\n\t   */\n\t\n\t  _createClass(Watcher, [{\n\t    key: 'getWatchedPaths',\n\t    value: function getWatchedPaths() {\n\t      var _this2 = this;\n\t\n\t      var rawPaths = Object.keys(this.mapping).map(function (k) {\n\t        var v = _this2.mapping[k];\n\t\n\t        // Watcher mappings can accept a cursor\n\t        if (v instanceof _cursor2['default']) return v.solvedPath;\n\t\n\t        return _this2.mapping[k];\n\t      });\n\t\n\t      return rawPaths.reduce(function (cp, p) {\n\t\n\t        // Handling path polymorphisms\n\t        p = [].concat(p);\n\t\n\t        // Dynamic path?\n\t        if (_type2['default'].dynamicPath(p)) p = (0, _helpers.getIn)(_this2.tree._data, p).solvedPath;\n\t\n\t        if (!p) return cp;\n\t\n\t        // Facet path?\n\t        var monkeyPath = _type2['default'].monkeyPath(_this2.tree._monkeys, p);\n\t\n\t        if (monkeyPath) return cp.concat((0, _helpers.getIn)(_this2.tree._monkeys, monkeyPath).data.relatedPaths());\n\t\n\t        return cp.concat([p]);\n\t      }, []);\n\t    }\n\t\n\t    /**\n\t     * Method used to return a map of the watcher's cursors.\n\t     *\n\t     * @return {object} - TMap of relevant cursors.\n\t     */\n\t  }, {\n\t    key: 'getCursors',\n\t    value: function getCursors() {\n\t      var _this3 = this;\n\t\n\t      var cursors = {};\n\t\n\t      Object.keys(this.mapping).forEach(function (k) {\n\t        var path = _this3.mapping[k];\n\t\n\t        if (path instanceof _cursor2['default']) cursors[k] = path;else cursors[k] = _this3.tree.select(path);\n\t      });\n\t\n\t      return cursors;\n\t    }\n\t\n\t    /**\n\t     * Method used to refresh the watcher's mapping.\n\t     *\n\t     * @param  {object}  mapping  - The new mapping to apply.\n\t     * @return {Watcher}          - Itself for chaining purposes.\n\t     */\n\t  }, {\n\t    key: 'refresh',\n\t    value: function refresh(mapping) {\n\t\n\t      if (!_type2['default'].watcherMapping(mapping)) throw (0, _helpers.makeError)('Baobab.watch: invalid mapping.', { mapping: mapping });\n\t\n\t      this.mapping = mapping;\n\t\n\t      // Creating the get method\n\t      var projection = {};\n\t\n\t      for (var k in mapping) {\n\t        projection[k] = mapping[k] instanceof _cursor2['default'] ? mapping[k].path : mapping[k];\n\t      }this.get = this.tree.project.bind(this.tree, projection);\n\t    }\n\t\n\t    /**\n\t     * Methods releasing the watcher from memory.\n\t     */\n\t  }, {\n\t    key: 'release',\n\t    value: function release() {\n\t\n\t      this.tree.off('update', this.handler);\n\t      this.state.killed = true;\n\t      this.kill();\n\t    }\n\t  }]);\n\t\n\t  return Watcher;\n\t})(_emmett2['default']);\n\t\n\texports['default'] = Watcher;\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 33 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// style-loader: Adds some css to the DOM by adding a <style> tag\n\t\n\t// load the styles\n\tvar content = __webpack_require__(34);\n\tif(typeof content === 'string') content = [[module.id, content, '']];\n\t// add the styles to the DOM\n\tvar update = __webpack_require__(12)(content, {});\n\tif(content.locals) module.exports = content.locals;\n\t// Hot Module Replacement\n\tif(false) {\n\t\t// When the styles change, update the <style> tags\n\t\tif(!content.locals) {\n\t\t\tmodule.hot.accept(\"!!./../../node_modules/css-loader/index.js!./../../node_modules/sass-loader/index.js!./index.scss\", function() {\n\t\t\t\tvar newContent = require(\"!!./../../node_modules/css-loader/index.js!./../../node_modules/sass-loader/index.js!./index.scss\");\n\t\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\t\tupdate(newContent);\n\t\t\t});\n\t\t}\n\t\t// When the module is disposed, remove the <style> tags\n\t\tmodule.hot.dispose(function() { update(); });\n\t}\n\n/***/ },\n/* 34 */\n/***/ function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(11)();\n\t// imports\n\t\n\t\n\t// module\n\texports.push([module.id, \"i.arrow.ne:before{transform:rotate(45deg)}i.arrow.e:before{transform:rotate(90deg)}i.arrow.se:before{transform:rotate(135deg)}i.arrow.s:before{transform:rotate(180deg)}i.arrow.sw:before{transform:rotate(225deg)}i.arrow.w:before{transform:rotate(270deg)}i.arrow.nw:before{transform:rotate(315deg)}@media (max-width:500px){#dashboard-page-container .scroll>div .col{max-width:50px}#dashboard-page-container .scroll>div .col.iconCol{max-width:25px;min-width:25px}}\", \"\"]);\n\t\n\t// exports\n\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** bundle.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 62a364fa22f7bdb64881\n **/","import components from './components';\r\nimport { stateModule } from './store/index';\r\n\r\nimport './scss/index.scss';\r\nangular.module('app', ['ionic', components, stateModule])\r\n.run(function($ionicPlatform) {\r\n    $ionicPlatform.ready(function() {\r\n        // Hide the accessory bar by default (remove this to show the accessory bar above the keyboard\r\n        // for form inputs)\r\n        if (window.cordova && window.cordova.plugins && window.cordova.plugins.Keyboard) {\r\n            cordova.plugins.Keyboard.hideKeyboardAccessoryBar(true);\r\n            cordova.plugins.Keyboard.disableScroll(true);\r\n\r\n        }\r\n        if (window.StatusBar) {\r\n            // org.apache.cordova.statusbar required\r\n            StatusBar.styleDefault();\r\n        }\r\n    });\r\n}).config(function($stateProvider, $urlRouterProvider) {\r\n    $urlRouterProvider.otherwise('/tab/dash');\r\n}).config(['$ionicConfigProvider', function($ionicConfigProvider) {\r\n    $ionicConfigProvider.tabs.position('bottom'); // other values: top\r\n}]);\n\n\n/** WEBPACK FOOTER **\n ** ./app/index.js\n **/","import tabs from './tabs';\r\n\r\nexport default angular.module('app.components', [tabs])\r\n  .name;\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./app/components/index.js\n **/","import dashboard from './dashboard';\r\nimport routing from './tabs.route';\r\nimport './tabs.scss';\r\nexport default angular.module('app.components.tabs', [dashboard])\r\n  .config(routing)\r\n  .name;\n\n\n/** WEBPACK FOOTER **\n ** ./app/components/tabs/index.js\n **/","import routing from './dashboard.route';\r\nimport './dashboard.scss';\r\n\r\nexport default angular.module('app.components.tabs.dashboard', [])\r\n  .config(routing)\r\n  .name;\n\n\n/** WEBPACK FOOTER **\n ** ./app/components/tabs/dashboard/index.js\n **/","import controller from './dashboard.controller';\r\nimport template from './dashboard.html';\r\n\r\nexport default ($stateProvider, $urlRouterProvider) => {\r\n    $stateProvider\r\n        .state('tab.dash', {\r\n            url: '/dash',\r\n            views: {\r\n                'tab-dash': {\r\n                    template,\r\n                    controller\r\n                }\r\n            }\r\n        })\r\n}\n\n\n/** WEBPACK FOOTER **\n ** ./app/components/tabs/dashboard/dashboard.route.js\n **/","import { \r\n    addToSubscriptionIdsStorage,\r\n    removeFromSubscriptionIdsStorage,\r\n    getSubscriptionIdsFromStorage\r\n} from '../../../storage/subscriptionIds.helper';\r\n\r\nvar locationModalTemplate = require('./locationModal.html');\r\n\r\nexport default ['$scope', '$timeout', '$ionicModal', 'AppState',\r\n    (scope, $timeout, $ionicModal, AppState) => {\r\n        const subscriptionSelector = AppState.select('subscriptions', 'subscribedLocations');\r\n        const locationSelector = AppState.select('locations');\r\n        scope.currentData = subscriptionSelector.get();\r\n        \r\n        subscriptionSelector.on('update', function (e) {\r\n            scope.currentData = scope.forecastData = e.data.currentData;\r\n        });\r\n\r\n        locationSelector.on('update', (e) => {\r\n            scope.locations = e.data.currentData;\r\n        });\r\n\r\n        scope.getLocationsForModal = () => {\r\n            if(!scope.locations) return [];\r\n            const existingIds = getSubscriptionIdsFromStorage();\r\n            return scope.locations.filter((d) => existingIds.indexOf(d.id) == -1);\r\n        }\r\n\r\n        scope.modal = $ionicModal.fromTemplate(locationModalTemplate, {\r\n            scope,\r\n            animation: 'none'\r\n        });\r\n\r\n        scope.showAddLocation = function () {\r\n            scope.modal.show();\r\n        }\r\n\r\n        scope.closeModal = function () {\r\n            scope.modal.hide();\r\n        };\r\n\r\n        scope.removeLocation = (id) => {\r\n            const idsSelector = AppState.select([\"subscriptions\", \"ids\"]);\r\n            const existingIDs = idsSelector.get();\r\n            idsSelector.set(existingIDs.filter((l) => l != id));\r\n            removeFromSubscriptionIdsStorage(id);\r\n        }\r\n\r\n        scope.addLocation = (location) => {\r\n            AppState.push([\"subscriptions\", \"ids\"], location.id);\r\n            addToSubscriptionIdsStorage(location.id);\r\n            scope.modal.hide();\r\n        };\r\n    }]\n\n\n/** WEBPACK FOOTER **\n ** ./app/components/tabs/dashboard/dashboard.controller.js\n **/","export const addToSubscriptionIdsStorage = (id) => {\r\n    let existingSubscriptionIds = [];\r\n    if (window.localStorage.getItem(\"subscriptionIds\")) {\r\n        existingSubscriptionIds = JSON.parse(window.localStorage.getItem(\"subscriptionIds\"));\r\n    }\r\n    existingSubscriptionIds.push(id);\r\n    window.localStorage.setItem(\"subscriptionIds\", JSON.stringify(existingSubscriptionIds));\r\n\r\n}\r\n\r\nexport const removeFromSubscriptionIdsStorage = (id) => {\r\n    let existingSubscriptionIds = [];\r\n    if (window.localStorage.getItem(\"subscriptionIds\")) {\r\n        existingSubscriptionIds = JSON.parse(window.localStorage.getItem(\"subscriptionIds\"));\r\n    }\r\n    existingSubscriptionIds = existingSubscriptionIds.filter((l) => l != id);\r\n\r\n    window.localStorage.setItem(\"subscriptionIds\", JSON.stringify(existingSubscriptionIds));\r\n\r\n}\r\n\r\nexport const getSubscriptionIdsFromStorage = () => {\r\n    if (window.localStorage.getItem(\"subscriptionIds\")) {\r\n        return JSON.parse(window.localStorage.getItem(\"subscriptionIds\"));\r\n    }\r\n    return [];\r\n}\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./app/storage/subscriptionIds.helper.js\n **/","module.exports = \"<ion-modal-view> <ion-header-bar> <h1 class=title>הוספת ספוט</h1> <button class=\\\"button icon icon-left ion-ios-close-outline\\\" ng-click=closeModal()></button> </ion-header-bar> <ion-content> <ion-list> <ion-item ng-click=addLocation(loc) ng-repeat=\\\"loc in getLocationsForModal()\\\"> {{ loc.name }} </ion-item> </ion-list> </ion-content> </ion-modal-view>\";\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/components/tabs/dashboard/locationModal.html\n ** module id = 7\n ** module chunks = 0\n **/","module.exports = \"<ion-view view-title=Dashboard> <ion-nav-title> WEATHER GONG </ion-nav-title> <ion-content class=padding id=dashboard-page-container> <div class=current-weather-container> <h3>מצב הים</h3> <div class=\\\"row header\\\"> <div class=\\\"col iconCol\\\"></div> <div class=col>ספוט</div> <div class=col>שעה</div> <div class=col>עוצמת רוח</div> <div class=\\\"col iconCol\\\">כיוון</div> <div class=col>שעה</div> <div class=col>גובה גל</div> <div class=\\\"col iconCol\\\">כיוון</div> <div class=\\\"col iconCol\\\"></div> </div> <div class=row ng-repeat=\\\"row in currentData\\\"> <div class=\\\"col iconCol\\\"> <button class=\\\"button icon ion-ios-minus-outline\\\" ng-click=removeLocation(row.id)></button> </div> <div class=col>{{ row.location }}</div> <div class=col>{{ row.time }}</div> <div class=col>{{ row.wind }}</div> <div class=\\\"col iconCol\\\"> <i class=\\\"icon arrow ion-arrow-up-c {{row.windDirection}}\\\"></i> </div> <div class=col>{{ row.temperature }}</div> <div class=col>{{ row.wave }}</div> <div class=\\\"col iconCol\\\"> <i class=\\\"icon arrow ion-arrow-up-c {{row.waveDirection}}\\\"></i> </div> <div class=\\\"col iconCol\\\"> <button class=\\\"icon arrow ion-ios-camera-outline\\\"/></div> </div> <div class=row> <div class=col> <button class=\\\"button icon ion-ios-plus-outline\\\" ng-click=showAddLocation()></button> </div> </div> </div> <div class=forecast-container> <h3>תחזית (מצב שיא)</h3> <div class=\\\"row header\\\"> <div class=\\\"col iconCol\\\"></div> <div class=col>ספוט</div> <div class=col>שעה</div> <div class=col>עוצמת רוח</div> <div class=\\\"col iconCol\\\">כיוון</div> <div class=col>שעה</div> <div class=col>גובה גל</div> <div class=\\\"col iconCol\\\">כיוון</div> </div> <div class=row ng-repeat=\\\"row in forecastData\\\"> <div class=\\\"col iconCol\\\"> <button class=\\\"button icon ion-ios-minus-outline\\\" ng-click=removeLocation(row.id)></button> </div> <div class=col>{{ row.location }}</div> <div class=col>{{ row.time }}</div> <div class=col>{{ row.wind }}</div> <div class=\\\"col iconCol\\\"> <i class=\\\"icon arrow ion-arrow-up-c {{row.windDirection}}\\\"></i> </div> <div class=col>{{ row.temperature }}</div> <div class=col>{{ row.wave }}</div> <div class=\\\"col iconCol\\\"> <i class=\\\"icon arrow ion-arrow-up-c {{row.waveDirection}}\\\"></i> </div> </div> <div class=row> <div class=col> <button class=\\\"button icon ion-ios-plus-outline\\\" ng-click=showAddLocation()></button> </div> </div> </div> </ion-content> </ion-view>\";\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/components/tabs/dashboard/dashboard.html\n ** module id = 8\n ** module chunks = 0\n **/","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!./../../../../node_modules/css-loader/index.js!./../../../../node_modules/sass-loader/index.js!./dashboard.scss\");\nif(typeof content === 'string') content = [[module.id, content, '']];\n// add the styles to the DOM\nvar update = require(\"!./../../../../node_modules/style-loader/addStyles.js\")(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(module.hot) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!./../../../../node_modules/css-loader/index.js!./../../../../node_modules/sass-loader/index.js!./dashboard.scss\", function() {\n\t\t\tvar newContent = require(\"!!./../../../../node_modules/css-loader/index.js!./../../../../node_modules/sass-loader/index.js!./dashboard.scss\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/components/tabs/dashboard/dashboard.scss\n ** module id = 9\n ** module chunks = 0\n **/","exports = module.exports = require(\"./../../../../node_modules/css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \"#dashboard-page-container .scroll{direction:rtl}#dashboard-page-container .scroll>div{margin-bottom:30px;word-wrap:normal}#dashboard-page-container .scroll>div .col{text-align:right;font-size:11px;direction:ltr}#dashboard-page-container .scroll>div .col .button{background:transparent;min-height:auto;min-width:auto}#dashboard-page-container .scroll>div .col .button.icon:before{font-size:15px;line-height:20px}#dashboard-page-container .scroll>div .col button.icon{font-size:21px;line-height:0;background:none;padding:0;margin:0;outline:0;border:none}\", \"\"]);\n\n// exports\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/css-loader!./~/sass-loader!./app/components/tabs/dashboard/dashboard.scss\n ** module id = 10\n ** module chunks = 0\n **/","/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n// css base code, injected by the css-loader\r\nmodule.exports = function() {\r\n\tvar list = [];\r\n\r\n\t// return the list of modules as css string\r\n\tlist.toString = function toString() {\r\n\t\tvar result = [];\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar item = this[i];\r\n\t\t\tif(item[2]) {\r\n\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\r\n\t\t\t} else {\r\n\t\t\t\tresult.push(item[1]);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result.join(\"\");\r\n\t};\r\n\r\n\t// import a list of modules into the list\r\n\tlist.i = function(modules, mediaQuery) {\r\n\t\tif(typeof modules === \"string\")\r\n\t\t\tmodules = [[null, modules, \"\"]];\r\n\t\tvar alreadyImportedModules = {};\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar id = this[i][0];\r\n\t\t\tif(typeof id === \"number\")\r\n\t\t\t\talreadyImportedModules[id] = true;\r\n\t\t}\r\n\t\tfor(i = 0; i < modules.length; i++) {\r\n\t\t\tvar item = modules[i];\r\n\t\t\t// skip already imported module\r\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\r\n\t\t\t//  when a module is imported multiple times with different media queries.\r\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\r\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\r\n\t\t\t\tif(mediaQuery && !item[2]) {\r\n\t\t\t\t\titem[2] = mediaQuery;\r\n\t\t\t\t} else if(mediaQuery) {\r\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\r\n\t\t\t\t}\r\n\t\t\t\tlist.push(item);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\treturn list;\r\n};\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/css-loader/lib/css-base.js\n ** module id = 11\n ** module chunks = 0\n **/","/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\nvar stylesInDom = {},\r\n\tmemoize = function(fn) {\r\n\t\tvar memo;\r\n\t\treturn function () {\r\n\t\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\r\n\t\t\treturn memo;\r\n\t\t};\r\n\t},\r\n\tisOldIE = memoize(function() {\r\n\t\treturn /msie [6-9]\\b/.test(window.navigator.userAgent.toLowerCase());\r\n\t}),\r\n\tgetHeadElement = memoize(function () {\r\n\t\treturn document.head || document.getElementsByTagName(\"head\")[0];\r\n\t}),\r\n\tsingletonElement = null,\r\n\tsingletonCounter = 0,\r\n\tstyleElementsInsertedAtTop = [];\r\n\r\nmodule.exports = function(list, options) {\r\n\tif(typeof DEBUG !== \"undefined\" && DEBUG) {\r\n\t\tif(typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\r\n\t}\r\n\r\n\toptions = options || {};\r\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\r\n\t// tags it will allow on a page\r\n\tif (typeof options.singleton === \"undefined\") options.singleton = isOldIE();\r\n\r\n\t// By default, add <style> tags to the bottom of <head>.\r\n\tif (typeof options.insertAt === \"undefined\") options.insertAt = \"bottom\";\r\n\r\n\tvar styles = listToStyles(list);\r\n\taddStylesToDom(styles, options);\r\n\r\n\treturn function update(newList) {\r\n\t\tvar mayRemove = [];\r\n\t\tfor(var i = 0; i < styles.length; i++) {\r\n\t\t\tvar item = styles[i];\r\n\t\t\tvar domStyle = stylesInDom[item.id];\r\n\t\t\tdomStyle.refs--;\r\n\t\t\tmayRemove.push(domStyle);\r\n\t\t}\r\n\t\tif(newList) {\r\n\t\t\tvar newStyles = listToStyles(newList);\r\n\t\t\taddStylesToDom(newStyles, options);\r\n\t\t}\r\n\t\tfor(var i = 0; i < mayRemove.length; i++) {\r\n\t\t\tvar domStyle = mayRemove[i];\r\n\t\t\tif(domStyle.refs === 0) {\r\n\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++)\r\n\t\t\t\t\tdomStyle.parts[j]();\r\n\t\t\t\tdelete stylesInDom[domStyle.id];\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n}\r\n\r\nfunction addStylesToDom(styles, options) {\r\n\tfor(var i = 0; i < styles.length; i++) {\r\n\t\tvar item = styles[i];\r\n\t\tvar domStyle = stylesInDom[item.id];\r\n\t\tif(domStyle) {\r\n\t\t\tdomStyle.refs++;\r\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\r\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\r\n\t\t\t}\r\n\t\t\tfor(; j < item.parts.length; j++) {\r\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tvar parts = [];\r\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\r\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\r\n\t\t\t}\r\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction listToStyles(list) {\r\n\tvar styles = [];\r\n\tvar newStyles = {};\r\n\tfor(var i = 0; i < list.length; i++) {\r\n\t\tvar item = list[i];\r\n\t\tvar id = item[0];\r\n\t\tvar css = item[1];\r\n\t\tvar media = item[2];\r\n\t\tvar sourceMap = item[3];\r\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\r\n\t\tif(!newStyles[id])\r\n\t\t\tstyles.push(newStyles[id] = {id: id, parts: [part]});\r\n\t\telse\r\n\t\t\tnewStyles[id].parts.push(part);\r\n\t}\r\n\treturn styles;\r\n}\r\n\r\nfunction insertStyleElement(options, styleElement) {\r\n\tvar head = getHeadElement();\r\n\tvar lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];\r\n\tif (options.insertAt === \"top\") {\r\n\t\tif(!lastStyleElementInsertedAtTop) {\r\n\t\t\thead.insertBefore(styleElement, head.firstChild);\r\n\t\t} else if(lastStyleElementInsertedAtTop.nextSibling) {\r\n\t\t\thead.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);\r\n\t\t} else {\r\n\t\t\thead.appendChild(styleElement);\r\n\t\t}\r\n\t\tstyleElementsInsertedAtTop.push(styleElement);\r\n\t} else if (options.insertAt === \"bottom\") {\r\n\t\thead.appendChild(styleElement);\r\n\t} else {\r\n\t\tthrow new Error(\"Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.\");\r\n\t}\r\n}\r\n\r\nfunction removeStyleElement(styleElement) {\r\n\tstyleElement.parentNode.removeChild(styleElement);\r\n\tvar idx = styleElementsInsertedAtTop.indexOf(styleElement);\r\n\tif(idx >= 0) {\r\n\t\tstyleElementsInsertedAtTop.splice(idx, 1);\r\n\t}\r\n}\r\n\r\nfunction createStyleElement(options) {\r\n\tvar styleElement = document.createElement(\"style\");\r\n\tstyleElement.type = \"text/css\";\r\n\tinsertStyleElement(options, styleElement);\r\n\treturn styleElement;\r\n}\r\n\r\nfunction createLinkElement(options) {\r\n\tvar linkElement = document.createElement(\"link\");\r\n\tlinkElement.rel = \"stylesheet\";\r\n\tinsertStyleElement(options, linkElement);\r\n\treturn linkElement;\r\n}\r\n\r\nfunction addStyle(obj, options) {\r\n\tvar styleElement, update, remove;\r\n\r\n\tif (options.singleton) {\r\n\t\tvar styleIndex = singletonCounter++;\r\n\t\tstyleElement = singletonElement || (singletonElement = createStyleElement(options));\r\n\t\tupdate = applyToSingletonTag.bind(null, styleElement, styleIndex, false);\r\n\t\tremove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);\r\n\t} else if(obj.sourceMap &&\r\n\t\ttypeof URL === \"function\" &&\r\n\t\ttypeof URL.createObjectURL === \"function\" &&\r\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\r\n\t\ttypeof Blob === \"function\" &&\r\n\t\ttypeof btoa === \"function\") {\r\n\t\tstyleElement = createLinkElement(options);\r\n\t\tupdate = updateLink.bind(null, styleElement);\r\n\t\tremove = function() {\r\n\t\t\tremoveStyleElement(styleElement);\r\n\t\t\tif(styleElement.href)\r\n\t\t\t\tURL.revokeObjectURL(styleElement.href);\r\n\t\t};\r\n\t} else {\r\n\t\tstyleElement = createStyleElement(options);\r\n\t\tupdate = applyToTag.bind(null, styleElement);\r\n\t\tremove = function() {\r\n\t\t\tremoveStyleElement(styleElement);\r\n\t\t};\r\n\t}\r\n\r\n\tupdate(obj);\r\n\r\n\treturn function updateStyle(newObj) {\r\n\t\tif(newObj) {\r\n\t\t\tif(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)\r\n\t\t\t\treturn;\r\n\t\t\tupdate(obj = newObj);\r\n\t\t} else {\r\n\t\t\tremove();\r\n\t\t}\r\n\t};\r\n}\r\n\r\nvar replaceText = (function () {\r\n\tvar textStore = [];\r\n\r\n\treturn function (index, replacement) {\r\n\t\ttextStore[index] = replacement;\r\n\t\treturn textStore.filter(Boolean).join('\\n');\r\n\t};\r\n})();\r\n\r\nfunction applyToSingletonTag(styleElement, index, remove, obj) {\r\n\tvar css = remove ? \"\" : obj.css;\r\n\r\n\tif (styleElement.styleSheet) {\r\n\t\tstyleElement.styleSheet.cssText = replaceText(index, css);\r\n\t} else {\r\n\t\tvar cssNode = document.createTextNode(css);\r\n\t\tvar childNodes = styleElement.childNodes;\r\n\t\tif (childNodes[index]) styleElement.removeChild(childNodes[index]);\r\n\t\tif (childNodes.length) {\r\n\t\t\tstyleElement.insertBefore(cssNode, childNodes[index]);\r\n\t\t} else {\r\n\t\t\tstyleElement.appendChild(cssNode);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction applyToTag(styleElement, obj) {\r\n\tvar css = obj.css;\r\n\tvar media = obj.media;\r\n\r\n\tif(media) {\r\n\t\tstyleElement.setAttribute(\"media\", media)\r\n\t}\r\n\r\n\tif(styleElement.styleSheet) {\r\n\t\tstyleElement.styleSheet.cssText = css;\r\n\t} else {\r\n\t\twhile(styleElement.firstChild) {\r\n\t\t\tstyleElement.removeChild(styleElement.firstChild);\r\n\t\t}\r\n\t\tstyleElement.appendChild(document.createTextNode(css));\r\n\t}\r\n}\r\n\r\nfunction updateLink(linkElement, obj) {\r\n\tvar css = obj.css;\r\n\tvar sourceMap = obj.sourceMap;\r\n\r\n\tif(sourceMap) {\r\n\t\t// http://stackoverflow.com/a/26603875\r\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\r\n\t}\r\n\r\n\tvar blob = new Blob([css], { type: \"text/css\" });\r\n\r\n\tvar oldSrc = linkElement.href;\r\n\r\n\tlinkElement.href = URL.createObjectURL(blob);\r\n\r\n\tif(oldSrc)\r\n\t\tURL.revokeObjectURL(oldSrc);\r\n}\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/style-loader/addStyles.js\n ** module id = 12\n ** module chunks = 0\n **/","export default ($stateProvider, $urlRouterProvider) => {\r\n    $stateProvider\r\n\r\n        // setup an abstract state for the tabs directive\r\n        .state('tab', {\r\n            url: '/tab',\r\n            abstract: true,\r\n            template: require('./tabs.html')\r\n        })\r\n}\n\n\n/** WEBPACK FOOTER **\n ** ./app/components/tabs/tabs.route.js\n **/","module.exports = \"<ion-tabs class=\\\"tabs-icon-top tabs-color-active-positive\\\"> <ion-tab title=תחזית href=#/tab/chats class=small> <ion-nav-view name=tab-chats></ion-nav-view> </ion-tab> <ion-tab title=דיווחים href=#/tab/reports class=small> <ion-nav-view name=tab-reports></ion-nav-view> </ion-tab> <ion-tab title=\\\"זמן אמת\\\" href=#/tab/account> <ion-nav-view name=tab-account></ion-nav-view> </ion-tab> <ion-tab title=\\\"ההתראות שלי\\\" href=#/tab/account> <ion-nav-view name=tab-account></ion-nav-view> </ion-tab> <ion-tab icon-off=ion-ios-home icon-on=ion-ios-home href=#/tab/dash> <ion-nav-view name=tab-dash></ion-nav-view> </ion-tab> </ion-tabs>\";\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/components/tabs/tabs.html\n ** module id = 14\n ** module chunks = 0\n **/","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!./../../../node_modules/css-loader/index.js!./../../../node_modules/sass-loader/index.js!./tabs.scss\");\nif(typeof content === 'string') content = [[module.id, content, '']];\n// add the styles to the DOM\nvar update = require(\"!./../../../node_modules/style-loader/addStyles.js\")(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(module.hot) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!./../../../node_modules/css-loader/index.js!./../../../node_modules/sass-loader/index.js!./tabs.scss\", function() {\n\t\t\tvar newContent = require(\"!!./../../../node_modules/css-loader/index.js!./../../../node_modules/sass-loader/index.js!./tabs.scss\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/components/tabs/tabs.scss\n ** module id = 15\n ** module chunks = 0\n **/","exports = module.exports = require(\"./../../../node_modules/css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \".tabs-icon-top>.tabs .tab-item{flex:1;font-size:11px;display:flex;align-items:center;justify-content:center}\", \"\"]);\n\n// exports\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/css-loader!./~/sass-loader!./app/components/tabs/tabs.scss\n ** module id = 16\n ** module chunks = 0\n **/","import { default_subscriptions } from './consts';\r\nimport subscript_data_monkey from './monkeys/subscriptionData';\r\nimport { fetchLocations } from '../api/mockApi';\r\nvar Baobab = require('baobab');\r\nconst tree = new Baobab({\r\n    locations: {\r\n\r\n    },\r\n    subscriptions: {\r\n        ids: window.localStorage.getItem(\"subscriptionIds\") ?\r\n               JSON.parse(window.localStorage.getItem(\"subscriptionIds\")) : \r\n               default_subscriptions,\r\n        data: [],\r\n        subscribedLocations: subscript_data_monkey\r\n    }\r\n}, {\r\n        immutable: false\r\n    });\r\n\r\n fetchLocations().then((result) => {\r\n    tree.set(\"locations\", result);\r\n});\r\n\r\nexport const stateModule = angular.module('app.store', [])\r\n  .factory('AppState', ['$rootScope', function($rootScope) {\r\n    tree.on('update', function () {\r\n        setTimeout(function () {\r\n            $rootScope.$apply();\r\n        }, 0);\r\n    });\r\n  return tree;\r\n}]).name;\r\n\r\nexport const state = tree;\n\n\n/** WEBPACK FOOTER **\n ** ./app/store/index.js\n **/","export const default_subscriptions = [];\n\n\n/** WEBPACK FOOTER **\n ** ./app/store/consts.js\n **/","\r\nvar Baobab = require('baobab');\r\nvar monkey = Baobab.monkey;\r\nimport loadSubscriptions from './loaders/subscriptionData';\r\nexport default monkey({\r\n    cursors: {\r\n        ids: ['subscriptions', 'ids'],\r\n        data: ['subscriptions', 'data']\r\n    },\r\n    get: function (state) {\r\n        const result = state.ids.map((id) => {\r\n            let data = state.data[id];\r\n            return data || { id, loading: true };\r\n        });     \r\n        loadSubscriptions(result.filter((r) => r.loading));   \r\n        return result;\r\n    }\r\n});\r\n\r\n\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./app/store/monkeys/subscriptionData.js\n **/","import { state } from '../../index.js';\r\nimport { fetchLocationsData } from '../../../api/mockApi'\r\nexport default (ids) => {\r\n    if (ids.length == 0)\r\n        return null;\r\n    let dataSelector = state.select('subscriptions', 'data');\r\n    fetchLocationsData(ids)\r\n    .then((data) => {\r\n            data.forEach((d) => {\r\n                dataSelector.set(d.id, d);\r\n            });\r\n        });\r\n}\n\n\n/** WEBPACK FOOTER **\n ** ./app/store/monkeys/loaders/subscriptionData.js\n **/","import config from '../config';\r\nconst locationsData = require('./mocks/locationsData.js');\r\nconst locations = require('./mocks/locations.js');\r\nexport const fetchLocationsData = (ids) => {\r\n    return new Promise((resolve) => {\r\n        resolve(locationsData);\r\n    });\r\n}\r\n\r\nexport const fetchLocations = () => {\r\n    return new Promise((resolve) => {\r\n        resolve(locations);\r\n    });\r\n}\n\n\n/** WEBPACK FOOTER **\n ** ./app/api/mockApi.js\n **/","export default {\r\n    apiUrl: 'http://some.url.to.api'\r\n}\n\n\n/** WEBPACK FOOTER **\n ** ./app/config.js\n **/","module.exports = [\r\n    {\r\n        \"id\": 1,\r\n        \"location\": \"tel-aviv\",\r\n        \"time\": \"08:00\",\r\n        \"wind\": \"8 Kts\",\r\n        \"windDirection\": \"ne\",\r\n        \"temp\": \"28°\",\r\n        \"wave\": \"0.5/7s\",\r\n        \"waveDirection\": \"nw\"\r\n    },\r\n    {\r\n        \"id\": 2,\r\n        \"location\": \"haifa\",\r\n        \"time\": \"08:00\",\r\n        \"wind\": \"8 Kts\",\r\n        \"windDirection\": \"w\",\r\n        \"temp\": \"28°\",\r\n        \"wave\": \"0.5/7s\",\r\n        \"waveDirection\": \"e\"\r\n    },\r\n    {\r\n        \"id\": 3,\r\n        \"location\": \"kineret\",\r\n        \"time\": \"08:00\",\r\n        \"wind\": \"8 Kts\",\r\n        \"windDirection\": \"se\",\r\n        \"temp\": \"28°\",\r\n        \"wave\": \"0.5 / 7sec\",\r\n        \"waveDirection\": \"sw\"\r\n    },\r\n    {\r\n        \"id\": 4,\r\n        \"location\": \"bat-yam\",\r\n        \"time\": \"08:00\",\r\n        \"wind\": \"8 Kts\",\r\n        \"windDirection\": \"ne\",\r\n        \"temp\": \"28°\",\r\n        \"wave\": \"0.5 / 7sec\",\r\n        \"waveDirection\": \"nw\"\r\n    }\r\n]\n\n\n/** WEBPACK FOOTER **\n ** ./app/api/mocks/locationsData.js\n **/","module.exports = [{\"id\":1,\"name\":\"tel-aviv\"},{\"id\": 2, \"name\":\"haifa\"},{\"id\": 3, \"name\":\"kineret\"},{\"id\": 4, \"name\": \"bat-yam\"}]\n\n\n/** WEBPACK FOOTER **\n ** ./app/api/mocks/locations.js\n **/","/**\n * Baobab Data Structure\n * ======================\n *\n * A handy data tree with cursors.\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nvar _get = function get(_x3, _x4, _x5) { var _again = true; _function: while (_again) { var object = _x3, property = _x4, receiver = _x5; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x3 = parent; _x4 = property; _x5 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _emmett = require('emmett');\n\nvar _emmett2 = _interopRequireDefault(_emmett);\n\nvar _cursor = require('./cursor');\n\nvar _cursor2 = _interopRequireDefault(_cursor);\n\nvar _monkey = require('./monkey');\n\nvar _watcher = require('./watcher');\n\nvar _watcher2 = _interopRequireDefault(_watcher);\n\nvar _type = require('./type');\n\nvar _type2 = _interopRequireDefault(_type);\n\nvar _update2 = require('./update');\n\nvar _update3 = _interopRequireDefault(_update2);\n\nvar _helpers = require('./helpers');\n\nvar helpers = _interopRequireWildcard(_helpers);\n\nvar arrayFrom = helpers.arrayFrom;\nvar coercePath = helpers.coercePath;\nvar deepFreeze = helpers.deepFreeze;\nvar getIn = helpers.getIn;\nvar makeError = helpers.makeError;\nvar deepClone = helpers.deepClone;\nvar deepMerge = helpers.deepMerge;\nvar shallowClone = helpers.shallowClone;\nvar shallowMerge = helpers.shallowMerge;\nvar uniqid = helpers.uniqid;\n\n/**\n * Baobab defaults\n */\nvar DEFAULTS = {\n\n  // Should the tree handle its transactions on its own?\n  autoCommit: true,\n\n  // Should the transactions be handled asynchronously?\n  asynchronous: true,\n\n  // Should the tree's data be immutable?\n  immutable: true,\n\n  // Should the monkeys be lazy?\n  lazyMonkeys: true,\n\n  // Should the tree be persistent?\n  persistent: true,\n\n  // Should the tree's update be pure?\n  pure: true,\n\n  // Validation specifications\n  validate: null,\n\n  // Validation behavior 'rollback' or 'notify'\n  validationBehavior: 'rollback'\n};\n\n/**\n * Function returning a string hash from a non-dynamic path expressed as an\n * array.\n *\n * @param  {array}  path - The path to hash.\n * @return {string} string - The resultant hash.\n */\nfunction hashPath(path) {\n  return 'λ' + path.map(function (step) {\n    if (_type2['default']['function'](step) || _type2['default'].object(step)) return '#' + uniqid() + '#';\n\n    return step;\n  }).join('λ');\n}\n\n/**\n * Baobab class\n *\n * @constructor\n * @param {object|array} [initialData={}]    - Initial data passed to the tree.\n * @param {object}       [opts]              - Optional options.\n * @param {boolean}      [opts.autoCommit]   - Should the tree auto-commit?\n * @param {boolean}      [opts.asynchronous] - Should the tree's transactions\n *                                             handled asynchronously?\n * @param {boolean}      [opts.immutable]    - Should the tree be immutable?\n * @param {boolean}      [opts.persistent]   - Should the tree be persistent?\n * @param {boolean}      [opts.pure]         - Should the tree be pure?\n * @param {function}     [opts.validate]     - Validation function.\n * @param {string}       [opts.validationBehaviour] - \"rollback\" or \"notify\".\n */\n\nvar Baobab = (function (_Emitter) {\n  _inherits(Baobab, _Emitter);\n\n  function Baobab(initialData, opts) {\n    var _this = this;\n\n    _classCallCheck(this, Baobab);\n\n    _get(Object.getPrototypeOf(Baobab.prototype), 'constructor', this).call(this);\n\n    // Setting initialData to an empty object if no data is provided by use\n    if (arguments.length < 1) initialData = {};\n\n    // Checking whether given initial data is valid\n    if (!_type2['default'].object(initialData) && !_type2['default'].array(initialData)) throw makeError('Baobab: invalid data.', { data: initialData });\n\n    // Merging given options with defaults\n    this.options = shallowMerge({}, DEFAULTS, opts);\n\n    // Disabling immutability & persistence if persistence if disabled\n    if (!this.options.persistent) {\n      this.options.immutable = false;\n      this.options.pure = false;\n    }\n\n    // Privates\n    this._identity = '[object Baobab]';\n    this._cursors = {};\n    this._future = null;\n    this._transaction = [];\n    this._affectedPathsIndex = {};\n    this._monkeys = {};\n    this._previousData = null;\n    this._data = initialData;\n\n    // Properties\n    this.root = new _cursor2['default'](this, [], 'λ');\n    delete this.root.release;\n\n    // Does the user want an immutable tree?\n    if (this.options.immutable) deepFreeze(this._data);\n\n    // Bootstrapping root cursor's getters and setters\n    var bootstrap = function bootstrap(name) {\n      _this[name] = function () {\n        var r = this.root[name].apply(this.root, arguments);\n        return r instanceof _cursor2['default'] ? this : r;\n      };\n    };\n\n    ['apply', 'clone', 'concat', 'deepClone', 'deepMerge', 'exists', 'get', 'push', 'merge', 'pop', 'project', 'serialize', 'set', 'shift', 'splice', 'unset', 'unshift'].forEach(bootstrap);\n\n    // Registering the initial monkeys\n    this._refreshMonkeys();\n\n    // Initial validation\n    var validationError = this.validate();\n\n    if (validationError) throw Error('Baobab: invalid data.', { error: validationError });\n  }\n\n  /**\n   * Monkey helper.\n   */\n\n  /**\n   * Internal method used to refresh the tree's monkey register on every\n   * update.\n   * Note 1) For the time being, placing monkeys beneath array nodes is not\n   * allowed for performance reasons.\n   *\n   * @param  {mixed}   node      - The starting node.\n   * @param  {array}   path      - The starting node's path.\n   * @param  {string}  operation - The operation that lead to a refreshment.\n   * @return {Baobab}            - The tree instance for chaining purposes.\n   */\n\n  _createClass(Baobab, [{\n    key: '_refreshMonkeys',\n    value: function _refreshMonkeys(node, path, operation) {\n      var _this2 = this;\n\n      var clean = function clean(data) {\n        var p = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];\n\n        if (data instanceof _monkey.Monkey) {\n          data.release();\n          (0, _update3['default'])(_this2._monkeys, p, { type: 'unset' }, {\n            immutable: false,\n            persistent: false,\n            pure: false\n          });\n\n          return;\n        }\n\n        if (_type2['default'].object(data)) {\n          for (var k in data) {\n            clean(data[k], p.concat(k));\n          }\n        }\n      };\n\n      var walk = function walk(data) {\n        var p = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];\n\n        // Should we sit a monkey in the tree?\n        if (data instanceof _monkey.MonkeyDefinition || data instanceof _monkey.Monkey) {\n          var monkeyInstance = new _monkey.Monkey(_this2, p, data instanceof _monkey.Monkey ? data.definition : data);\n\n          (0, _update3['default'])(_this2._monkeys, p, { type: 'set', value: monkeyInstance }, {\n            immutable: false,\n            persistent: false,\n            pure: false\n          });\n\n          return;\n        }\n\n        // Object iteration\n        if (_type2['default'].object(data)) {\n          for (var k in data) {\n            walk(data[k], p.concat(k));\n          }\n        }\n      };\n\n      // Walking the whole tree\n      if (!arguments.length) {\n        walk(this._data);\n      } else {\n        var monkeysNode = getIn(this._monkeys, path).data;\n\n        // Is this required that we clean some already existing monkeys?\n        if (monkeysNode) clean(monkeysNode, path);\n\n        // Let's walk the tree only from the updated point\n        if (operation !== 'unset') {\n          walk(node, path);\n        }\n      }\n\n      return this;\n    }\n\n    /**\n     * Method used to validate the tree's data.\n     *\n     * @return {boolean} - Is the tree valid?\n     */\n  }, {\n    key: 'validate',\n    value: function validate(affectedPaths) {\n      var _options = this.options;\n      var validate = _options.validate;\n      var behavior = _options.validationBehavior;\n\n      if (typeof validate !== 'function') return null;\n\n      var error = validate.call(this, this._previousData, this._data, affectedPaths || [[]]);\n\n      if (error instanceof Error) {\n\n        if (behavior === 'rollback') {\n          this._data = this._previousData;\n          this._affectedPathsIndex = {};\n          this._transaction = [];\n          this._previousData = this._data;\n        }\n\n        this.emit('invalid', { error: error });\n\n        return error;\n      }\n\n      return null;\n    }\n\n    /**\n     * Method used to select data within the tree by creating a cursor. Cursors\n     * are kept as singletons by the tree for performance and hygiene reasons.\n     *\n     * Arity (1):\n     * @param {path}    path - Path to select in the tree.\n     *\n     * Arity (*):\n     * @param {...step} path - Path to select in the tree.\n     *\n     * @return {Cursor}      - The resultant cursor.\n     */\n  }, {\n    key: 'select',\n    value: function select(path) {\n\n      // If no path is given, we simply return the root\n      path = path || [];\n\n      // Variadic\n      if (arguments.length > 1) path = arrayFrom(arguments);\n\n      // Checking that given path is valid\n      if (!_type2['default'].path(path)) throw makeError('Baobab.select: invalid path.', { path: path });\n\n      // Casting to array\n      path = [].concat(path);\n\n      // Computing hash (done here because it would be too late to do it in the\n      // cursor's constructor since we need to hit the cursors' index first).\n      var hash = hashPath(path);\n\n      // Creating a new cursor or returning the already existing one for the\n      // requested path.\n      var cursor = this._cursors[hash];\n\n      if (!cursor) {\n        cursor = new _cursor2['default'](this, path, hash);\n        this._cursors[hash] = cursor;\n      }\n\n      // Emitting an event to notify that a part of the tree was selected\n      this.emit('select', { path: path, cursor: cursor });\n      return cursor;\n    }\n\n    /**\n     * Method used to update the tree. Updates are simply expressed by a path,\n     * dynamic or not, and an operation.\n     *\n     * This is where path solving should happen and not in the cursor.\n     *\n     * @param  {path}   path      - The path where we'll apply the operation.\n     * @param  {object} operation - The operation to apply.\n     * @return {mixed} - Return the result of the update.\n     */\n  }, {\n    key: 'update',\n    value: function update(path, operation) {\n      var _this3 = this;\n\n      // Coercing path\n      path = coercePath(path);\n\n      if (!_type2['default'].operationType(operation.type)) throw makeError('Baobab.update: unknown operation type \"' + operation.type + '\".', { operation: operation });\n\n      // Solving the given path\n\n      var _getIn = getIn(this._data, path);\n\n      var solvedPath = _getIn.solvedPath;\n      var exists = _getIn.exists;\n\n      // If we couldn't solve the path, we throw\n      if (!solvedPath) throw makeError('Baobab.update: could not solve the given path.', {\n        path: solvedPath\n      });\n\n      // Read-only path?\n      var monkeyPath = _type2['default'].monkeyPath(this._monkeys, solvedPath);\n      if (monkeyPath && solvedPath.length > monkeyPath.length) throw makeError('Baobab.update: attempting to update a read-only path.', {\n        path: solvedPath\n      });\n\n      // We don't unset irrelevant paths\n      if (operation.type === 'unset' && !exists) return;\n\n      // If we merge data, we need to acknowledge monkeys\n      var realOperation = operation;\n      if (/merge/i.test(operation.type)) {\n        var monkeysNode = getIn(this._monkeys, solvedPath).data;\n\n        if (_type2['default'].object(monkeysNode)) {\n\n          // Cloning the operation not to create weird behavior for the user\n          realOperation = shallowClone(realOperation);\n\n          // Fetching the existing node in the current data\n          var currentNode = getIn(this._data, solvedPath).data;\n\n          if (/deep/i.test(realOperation.type)) realOperation.value = deepMerge({}, deepMerge({}, currentNode, deepClone(monkeysNode)), realOperation.value);else realOperation.value = shallowMerge({}, deepMerge({}, currentNode, deepClone(monkeysNode)), realOperation.value);\n        }\n      }\n\n      // Stashing previous data if this is the frame's first update\n      if (!this._transaction.length) this._previousData = this._data;\n\n      // Applying the operation\n      var result = (0, _update3['default'])(this._data, solvedPath, realOperation, this.options);\n\n      var data = result.data;\n      var node = result.node;\n\n      // If because of purity, the update was moot, we stop here\n      if (!('data' in result)) return node;\n\n      // If the operation is push, the affected path is slightly different\n      var affectedPath = solvedPath.concat(operation.type === 'push' ? node.length - 1 : []);\n\n      var hash = hashPath(affectedPath);\n\n      // Updating data and transaction\n      this._data = data;\n      this._affectedPathsIndex[hash] = true;\n      this._transaction.push(shallowMerge({}, operation, { path: affectedPath }));\n\n      // Updating the monkeys\n      this._refreshMonkeys(node, solvedPath, operation.type);\n\n      // Emitting a `write` event\n      this.emit('write', { path: affectedPath });\n\n      // Should we let the user commit?\n      if (!this.options.autoCommit) return node;\n\n      // Should we update asynchronously?\n      if (!this.options.asynchronous) {\n        this.commit();\n        return node;\n      }\n\n      // Updating asynchronously\n      if (!this._future) this._future = setTimeout(function () {\n        return _this3.commit();\n      }, 0);\n\n      // Finally returning the affected node\n      return node;\n    }\n\n    /**\n     * Method committing the updates of the tree and firing the tree's events.\n     *\n     * @return {Baobab} - The tree instance for chaining purposes.\n     */\n  }, {\n    key: 'commit',\n    value: function commit() {\n\n      // Do not fire update if the transaction is empty\n      if (!this._transaction.length) return this;\n\n      // Clearing timeout if one was defined\n      if (this._future) this._future = clearTimeout(this._future);\n\n      var affectedPaths = Object.keys(this._affectedPathsIndex).map(function (h) {\n        return h !== 'λ' ? h.split('λ').slice(1) : [];\n      });\n\n      // Is the tree still valid?\n      var validationError = this.validate(affectedPaths);\n\n      if (validationError) return this;\n\n      // Caching to keep original references before we change them\n      var transaction = this._transaction,\n          previousData = this._previousData;\n\n      this._affectedPathsIndex = {};\n      this._transaction = [];\n      this._previousData = this._data;\n\n      // Emitting update event\n      this.emit('update', {\n        paths: affectedPaths,\n        currentData: this._data,\n        transaction: transaction,\n        previousData: previousData\n      });\n\n      return this;\n    }\n\n    /**\n     * Method returning a monkey at the given path or else `null`.\n     *\n     * @param  {path}        path - Path of the monkey to retrieve.\n     * @return {Monkey|null}      - The Monkey instance of `null`.\n     */\n  }, {\n    key: 'getMonkey',\n    value: function getMonkey(path) {\n      path = coercePath(path);\n\n      var monkey = getIn(this._monkeys, [].concat(path)).data;\n\n      if (monkey instanceof _monkey.Monkey) return monkey;\n\n      return null;\n    }\n\n    /**\n     * Method used to watch a collection of paths within the tree. Very useful\n     * to bind UI components and such to the tree.\n     *\n     * @param  {object} mapping - Mapping of paths to listen.\n     * @return {Cursor}         - The created watcher.\n     */\n  }, {\n    key: 'watch',\n    value: function watch(mapping) {\n      return new _watcher2['default'](this, mapping);\n    }\n\n    /**\n     * Method releasing the tree and its attached data from memory.\n     */\n  }, {\n    key: 'release',\n    value: function release() {\n      var k = undefined;\n\n      this.emit('release');\n\n      delete this.root;\n\n      delete this._data;\n      delete this._previousData;\n      delete this._transaction;\n      delete this._affectedPathsIndex;\n      delete this._monkeys;\n\n      // Releasing cursors\n      for (k in this._cursors) this._cursors[k].release();\n      delete this._cursors;\n\n      // Killing event emitter\n      this.kill();\n    }\n\n    /**\n     * Overriding the `toJSON` method for convenient use with JSON.stringify.\n     *\n     * @return {mixed} - Data at cursor.\n     */\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return this.serialize();\n    }\n\n    /**\n     * Overriding the `toString` method for debugging purposes.\n     *\n     * @return {string} - The baobab's identity.\n     */\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return this._identity;\n    }\n  }]);\n\n  return Baobab;\n})(_emmett2['default']);\n\nexports['default'] = Baobab;\nBaobab.monkey = function () {\n  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  if (!args.length) throw new Error('Baobab.monkey: missing definition.');\n\n  if (args.length === 1 && typeof args[0] !== 'function') return new _monkey.MonkeyDefinition(args[0]);\n\n  return new _monkey.MonkeyDefinition(args);\n};\nBaobab.dynamicNode = Baobab.monkey;\n\n/**\n * Exposing some internals for convenience\n */\nBaobab.Cursor = _cursor2['default'];\nBaobab.MonkeyDefinition = _monkey.MonkeyDefinition;\nBaobab.Monkey = _monkey.Monkey;\nBaobab.type = _type2['default'];\nBaobab.helpers = helpers;\n\n/**\n * Version\n */\nBaobab.VERSION = '2.3.2';\nmodule.exports = exports['default'];\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/baobab/dist/baobab.js\n ** module id = 25\n ** module chunks = 0\n **/","(function() {\n  'use strict';\n\n  /**\n   * Here is the list of every allowed parameter when using Emitter#on:\n   * @type {Object}\n   */\n  var __allowedOptions = {\n    once: 'boolean',\n    scope: 'object'\n  };\n\n  /**\n   * Incremental id used to order event handlers.\n   */\n  var __order = 0;\n\n  /**\n   * A simple helper to shallowly merge two objects. The second one will \"win\"\n   * over the first one.\n   *\n   * @param  {object}  o1 First target object.\n   * @param  {object}  o2 Second target object.\n   * @return {object}     Returns the merged object.\n   */\n  function shallowMerge(o1, o2) {\n    var o = {},\n        k;\n\n    for (k in o1) o[k] = o1[k];\n    for (k in o2) o[k] = o2[k];\n\n    return o;\n  }\n\n  /**\n   * Is the given variable a plain JavaScript object?\n   *\n   * @param  {mixed}  v   Target.\n   * @return {boolean}    The boolean result.\n   */\n  function isPlainObject(v) {\n    return v &&\n           typeof v === 'object' &&\n           !Array.isArray(v) &&\n           !(v instanceof Function) &&\n           !(v instanceof RegExp);\n  }\n\n  /**\n   * Iterate over an object that may have ES6 Symbols.\n   *\n   * @param  {object}   object  Object on which to iterate.\n   * @param  {function} fn      Iterator function.\n   * @param  {object}   [scope] Optional scope.\n   */\n  function forIn(object, fn, scope) {\n    var symbols,\n        k,\n        i,\n        l;\n\n    for (k in object)\n      fn.call(scope || null, k, object[k]);\n\n    if (Object.getOwnPropertySymbols) {\n      symbols = Object.getOwnPropertySymbols(object);\n\n      for (i = 0, l = symbols.length; i < l; i++)\n        fn.call(scope || null, symbols[i], object[symbols[i]]);\n    }\n  }\n\n  /**\n   * The emitter's constructor. It initializes the handlers-per-events store and\n   * the global handlers store.\n   *\n   * Emitters are useful for non-DOM events communication. Read its methods\n   * documentation for more information about how it works.\n   *\n   * @return {Emitter}         The fresh new instance.\n   */\n  var Emitter = function() {\n    this._enabled = true;\n\n    // Dirty trick that will set the necessary properties to the emitter\n    this.unbindAll();\n  };\n\n  /**\n   * This method unbinds every handlers attached to every or any events. So,\n   * these functions will no more be executed when the related events are\n   * emitted. If the functions were not bound to the events, nothing will\n   * happen, and no error will be thrown.\n   *\n   * Usage:\n   * ******\n   * > myEmitter.unbindAll();\n   *\n   * @return {Emitter}      Returns this.\n   */\n  Emitter.prototype.unbindAll = function() {\n\n    this._handlers = {};\n    this._handlersAll = [];\n    this._handlersComplex = [];\n\n    return this;\n  };\n\n\n  /**\n   * This method binds one or more functions to the emitter, handled to one or a\n   * suite of events. So, these functions will be executed anytime one related\n   * event is emitted.\n   *\n   * It is also possible to bind a function to any emitted event by not\n   * specifying any event to bind the function to.\n   *\n   * Recognized options:\n   * *******************\n   *  - {?boolean} once   If true, the handlers will be unbound after the first\n   *                      execution. Default value: false.\n   *  - {?object}  scope  If a scope is given, then the listeners will be called\n   *                      with this scope as \"this\".\n   *\n   * Variant 1:\n   * **********\n   * > myEmitter.on('myEvent', function(e) { console.log(e); });\n   * > // Or:\n   * > myEmitter.on('myEvent', function(e) { console.log(e); }, { once: true });\n   *\n   * @param  {string}   event   The event to listen to.\n   * @param  {function} handler The function to bind.\n   * @param  {?object}  options Eventually some options.\n   * @return {Emitter}          Returns this.\n   *\n   * Variant 2:\n   * **********\n   * > myEmitter.on(\n   * >   ['myEvent1', 'myEvent2'],\n   * >   function(e) { console.log(e); }\n   * >);\n   * > // Or:\n   * > myEmitter.on(\n   * >   ['myEvent1', 'myEvent2'],\n   * >   function(e) { console.log(e); }\n   * >   { once: true }}\n   * >);\n   *\n   * @param  {array}    events  The events to listen to.\n   * @param  {function} handler The function to bind.\n   * @param  {?object}  options Eventually some options.\n   * @return {Emitter}          Returns this.\n   *\n   * Variant 3:\n   * **********\n   * > myEmitter.on({\n   * >   myEvent1: function(e) { console.log(e); },\n   * >   myEvent2: function(e) { console.log(e); }\n   * > });\n   * > // Or:\n   * > myEmitter.on({\n   * >   myEvent1: function(e) { console.log(e); },\n   * >   myEvent2: function(e) { console.log(e); }\n   * > }, { once: true });\n   *\n   * @param  {object}  bindings An object containing pairs event / function.\n   * @param  {?object}  options Eventually some options.\n   * @return {Emitter}          Returns this.\n   *\n   * Variant 4:\n   * **********\n   * > myEmitter.on(function(e) { console.log(e); });\n   * > // Or:\n   * > myEmitter.on(function(e) { console.log(e); }, { once: true});\n   *\n   * @param  {function} handler The function to bind to every events.\n   * @param  {?object}  options Eventually some options.\n   * @return {Emitter}          Returns this.\n   */\n  Emitter.prototype.on = function(a, b, c) {\n    var i,\n        l,\n        k,\n        event,\n        eArray,\n        handlersList,\n        bindingObject;\n\n    // Variant 3\n    if (isPlainObject(a)) {\n      forIn(a, function(name, fn) {\n        this.on(name, fn, b);\n      }, this);\n\n      return this;\n    }\n\n    // Variant 1, 2 and 4\n    if (typeof a === 'function') {\n      c = b;\n      b = a;\n      a = null;\n    }\n\n    eArray = [].concat(a);\n\n    for (i = 0, l = eArray.length; i < l; i++) {\n      event = eArray[i];\n\n      bindingObject = {\n        order: __order++,\n        fn: b\n      };\n\n      // Defining the list in which the handler should be inserted\n      if (typeof event === 'string' || typeof event === 'symbol') {\n        if (!this._handlers[event])\n          this._handlers[event] = [];\n        handlersList = this._handlers[event];\n        bindingObject.type = event;\n      }\n      else if (event instanceof RegExp) {\n        handlersList = this._handlersComplex;\n        bindingObject.pattern = event;\n      }\n      else if (event === null) {\n        handlersList = this._handlersAll;\n      }\n      else {\n        throw Error('Emitter.on: invalid event.');\n      }\n\n      // Appending needed properties\n      for (k in c || {})\n        if (__allowedOptions[k])\n          bindingObject[k] = c[k];\n\n      handlersList.push(bindingObject);\n    }\n\n    return this;\n  };\n\n\n  /**\n   * This method works exactly as the previous #on, but will add an options\n   * object if none is given, and set the option \"once\" to true.\n   *\n   * The polymorphism works exactly as with the #on method.\n   */\n  Emitter.prototype.once = function() {\n    var args = Array.prototype.slice.call(arguments),\n        li = args.length - 1;\n\n    if (isPlainObject(args[li]) && args.length > 1)\n      args[li] = shallowMerge(args[li], {once: true});\n    else\n      args.push({once: true});\n\n    return this.on.apply(this, args);\n  };\n\n\n  /**\n   * This method unbinds one or more functions from events of the emitter. So,\n   * these functions will no more be executed when the related events are\n   * emitted. If the functions were not bound to the events, nothing will\n   * happen, and no error will be thrown.\n   *\n   * Variant 1:\n   * **********\n   * > myEmitter.off('myEvent', myHandler);\n   *\n   * @param  {string}   event   The event to unbind the handler from.\n   * @param  {function} handler The function to unbind.\n   * @return {Emitter}          Returns this.\n   *\n   * Variant 2:\n   * **********\n   * > myEmitter.off(['myEvent1', 'myEvent2'], myHandler);\n   *\n   * @param  {array}    events  The events to unbind the handler from.\n   * @param  {function} handler The function to unbind.\n   * @return {Emitter}          Returns this.\n   *\n   * Variant 3:\n   * **********\n   * > myEmitter.off({\n   * >   myEvent1: myHandler1,\n   * >   myEvent2: myHandler2\n   * > });\n   *\n   * @param  {object} bindings An object containing pairs event / function.\n   * @return {Emitter}         Returns this.\n   *\n   * Variant 4:\n   * **********\n   * > myEmitter.off(myHandler);\n   *\n   * @param  {function} handler The function to unbind from every events.\n   * @return {Emitter}          Returns this.\n   *\n   * Variant 5:\n   * **********\n   * > myEmitter.off(event);\n   *\n   * @param  {string} event     The event we should unbind.\n   * @return {Emitter}          Returns this.\n   */\n  function filter(target, fn) {\n    target = target || [];\n\n    var a = [],\n        l,\n        i;\n\n    for (i = 0, l = target.length; i < l; i++)\n      if (target[i].fn !== fn)\n        a.push(target[i]);\n\n    return a;\n  }\n\n  Emitter.prototype.off = function(events, fn) {\n    var i,\n        n,\n        k,\n        event;\n\n    // Variant 4:\n    if (arguments.length === 1 && typeof events === 'function') {\n      fn = arguments[0];\n\n      // Handlers bound to events:\n      for (k in this._handlers) {\n        this._handlers[k] = filter(this._handlers[k], fn);\n\n        if (this._handlers[k].length === 0)\n          delete this._handlers[k];\n      }\n\n      // Generic Handlers\n      this._handlersAll = filter(this._handlersAll, fn);\n\n      // Complex handlers\n      this._handlersComplex = filter(this._handlersComplex, fn);\n    }\n\n    // Variant 5\n    else if (arguments.length === 1 &&\n             (typeof events === 'string' || typeof events === 'symbol')) {\n      delete this._handlers[events];\n    }\n\n    // Variant 1 and 2:\n    else if (arguments.length === 2) {\n      var eArray = [].concat(events);\n\n      for (i = 0, n = eArray.length; i < n; i++) {\n        event = eArray[i];\n\n        this._handlers[event] = filter(this._handlers[event], fn);\n\n        if ((this._handlers[event] || []).length === 0)\n          delete this._handlers[event];\n      }\n    }\n\n    // Variant 3\n    else if (isPlainObject(events)) {\n      forIn(events, this.off, this);\n    }\n\n    return this;\n  };\n\n  /**\n   * This method retrieve the listeners attached to a particular event.\n   *\n   * @param  {?string}    Name of the event.\n   * @return {array}      Array of handler functions.\n   */\n  Emitter.prototype.listeners = function(event) {\n    var handlers = this._handlersAll || [],\n        complex = false,\n        h,\n        i,\n        l;\n\n    if (!event)\n      throw Error('Emitter.listeners: no event provided.');\n\n    handlers = handlers.concat(this._handlers[event] || []);\n\n    for (i = 0, l = this._handlersComplex.length; i < l; i++) {\n      h = this._handlersComplex[i];\n\n      if (~event.search(h.pattern)) {\n        complex = true;\n        handlers.push(h);\n      }\n    }\n\n    // If we have any complex handlers, we need to sort\n    if (this._handlersAll.length || complex)\n      return handlers.sort(function(a, b) {\n        return a.order - b.order;\n      });\n    else\n      return handlers.slice(0);\n  };\n\n  /**\n   * This method emits the specified event(s), and executes every handlers bound\n   * to the event(s).\n   *\n   * Use cases:\n   * **********\n   * > myEmitter.emit('myEvent');\n   * > myEmitter.emit('myEvent', myData);\n   * > myEmitter.emit(['myEvent1', 'myEvent2']);\n   * > myEmitter.emit(['myEvent1', 'myEvent2'], myData);\n   * > myEmitter.emit({myEvent1: myData1, myEvent2: myData2});\n   *\n   * @param  {string|array} events The event(s) to emit.\n   * @param  {object?}      data   The data.\n   * @return {Emitter}             Returns this.\n   */\n  Emitter.prototype.emit = function(events, data) {\n\n    // Short exit if the emitter is disabled\n    if (!this._enabled)\n      return this;\n\n    // Object variant\n    if (isPlainObject(events)) {\n      forIn(events, this.emit, this);\n      return this;\n    }\n\n    var eArray = [].concat(events),\n        onces = [],\n        event,\n        parent,\n        handlers,\n        handler,\n        i,\n        j,\n        l,\n        m;\n\n    for (i = 0, l = eArray.length; i < l; i++) {\n      handlers = this.listeners(eArray[i]);\n\n      for (j = 0, m = handlers.length; j < m; j++) {\n        handler = handlers[j];\n        event = {\n          type: eArray[i],\n          target: this\n        };\n\n        if (arguments.length > 1)\n          event.data = data;\n\n        handler.fn.call('scope' in handler ? handler.scope : this, event);\n\n        if (handler.once)\n          onces.push(handler);\n      }\n\n      // Cleaning onces\n      for (j = onces.length - 1; j >= 0; j--) {\n        parent = onces[j].type ?\n          this._handlers[onces[j].type] :\n          onces[j].pattern ?\n            this._handlersComplex :\n            this._handlersAll;\n\n        parent.splice(parent.indexOf(onces[j]), 1);\n      }\n    }\n\n    return this;\n  };\n\n\n  /**\n   * This method will unbind all listeners and make it impossible to ever\n   * rebind any listener to any event.\n   */\n  Emitter.prototype.kill = function() {\n\n    this.unbindAll();\n    this._handlers = null;\n    this._handlersAll = null;\n    this._handlersComplex = null;\n    this._enabled = false;\n\n    // Nooping methods\n    this.unbindAll =\n    this.on =\n    this.once =\n    this.off =\n    this.emit =\n    this.listeners = Function.prototype;\n  };\n\n\n  /**\n   * This method disabled the emitter, which means its emit method will do\n   * nothing.\n   *\n   * @return {Emitter} Returns this.\n   */\n  Emitter.prototype.disable = function() {\n    this._enabled = false;\n\n    return this;\n  };\n\n\n  /**\n   * This method enables the emitter.\n   *\n   * @return {Emitter} Returns this.\n   */\n  Emitter.prototype.enable = function() {\n    this._enabled = true;\n\n    return this;\n  };\n\n\n  /**\n   * Version:\n   */\n  Emitter.version = '3.1.1';\n\n\n  // Export:\n  if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports)\n      exports = module.exports = Emitter;\n    exports.Emitter = Emitter;\n  } else if (typeof define === 'function' && define.amd)\n    define('emmett', [], function() {\n      return Emitter;\n    });\n  else\n    this.Emitter = Emitter;\n}).call(this);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/emmett/emmett.js\n ** module id = 26\n ** module chunks = 0\n **/","/**\n * Baobab Cursors\n * ===============\n *\n * Cursors created by selecting some data within a Baobab tree.\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nvar _get = function get(_x3, _x4, _x5) { var _again = true; _function: while (_again) { var object = _x3, property = _x4, receiver = _x5; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x3 = parent; _x4 = property; _x5 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _emmett = require('emmett');\n\nvar _emmett2 = _interopRequireDefault(_emmett);\n\nvar _monkey = require('./monkey');\n\nvar _type = require('./type');\n\nvar _type2 = _interopRequireDefault(_type);\n\nvar _helpers = require('./helpers');\n\n/**\n * Traversal helper function for dynamic cursors. Will throw a legible error\n * if traversal is not possible.\n *\n * @param {string} method     - The method name, to create a correct error msg.\n * @param {array}  solvedPath - The cursor's solved path.\n */\nfunction checkPossibilityOfDynamicTraversal(method, solvedPath) {\n  if (!solvedPath) throw (0, _helpers.makeError)('Baobab.Cursor.' + method + ': ' + ('cannot use ' + method + ' on an unresolved dynamic path.'), { path: solvedPath });\n}\n\n/**\n * Cursor class\n *\n * @constructor\n * @param {Baobab} tree   - The cursor's root.\n * @param {array}  path   - The cursor's path in the tree.\n * @param {string} hash   - The path's hash computed ahead by the tree.\n */\n\nvar Cursor = (function (_Emitter) {\n  _inherits(Cursor, _Emitter);\n\n  function Cursor(tree, path, hash) {\n    var _this = this;\n\n    _classCallCheck(this, Cursor);\n\n    _get(Object.getPrototypeOf(Cursor.prototype), 'constructor', this).call(this);\n\n    // If no path were to be provided, we fallback to an empty path (root)\n    path = path || [];\n\n    // Privates\n    this._identity = '[object Cursor]';\n    this._archive = null;\n\n    // Properties\n    this.tree = tree;\n    this.path = path;\n    this.hash = hash;\n\n    // State\n    this.state = {\n      killed: false,\n      recording: false,\n      undoing: false\n    };\n\n    // Checking whether the given path is dynamic or not\n    this._dynamicPath = _type2['default'].dynamicPath(this.path);\n\n    // Checking whether the given path will meet a monkey\n    this._monkeyPath = _type2['default'].monkeyPath(this.tree._monkeys, this.path);\n\n    if (!this._dynamicPath) this.solvedPath = this.path;else this.solvedPath = (0, _helpers.getIn)(this.tree._data, this.path).solvedPath;\n\n    /**\n     * Listener bound to the tree's writes so that cursors with dynamic paths\n     * may update their solved path correctly.\n     *\n     * @param {object} event - The event fired by the tree.\n     */\n    this._writeHandler = function (_ref) {\n      var data = _ref.data;\n\n      if (_this.state.killed || !(0, _helpers.solveUpdate)([data.path], _this._getComparedPaths())) return;\n\n      _this.solvedPath = (0, _helpers.getIn)(_this.tree._data, _this.path).solvedPath;\n    };\n\n    /**\n     * Function in charge of actually trigger the cursor's updates and\n     * deal with the archived records.\n     *\n     * @note: probably should wrap the current solvedPath in closure to avoid\n     * for tricky cases where it would fail.\n     *\n     * @param {mixed} previousData - the tree's previous data.\n     */\n    var fireUpdate = function fireUpdate(previousData) {\n      var self = _this;\n\n      var eventData = Object.defineProperties({}, {\n        previousData: {\n          get: function get() {\n            return (0, _helpers.getIn)(previousData, self.solvedPath).data;\n          },\n          configurable: true,\n          enumerable: true\n        },\n        currentData: {\n          get: function get() {\n            return self.get();\n          },\n          configurable: true,\n          enumerable: true\n        }\n      });\n\n      if (_this.state.recording && !_this.state.undoing) _this.archive.add(eventData.previousData);\n\n      _this.state.undoing = false;\n\n      return _this.emit('update', eventData);\n    };\n\n    /**\n     * Listener bound to the tree's updates and determining whether the\n     * cursor is affected and should react accordingly.\n     *\n     * Note that this listener is lazily bound to the tree to be sure\n     * one wouldn't leak listeners when only creating cursors for convenience\n     * and not to listen to updates specifically.\n     *\n     * @param {object} event - The event fired by the tree.\n     */\n    this._updateHandler = function (event) {\n      if (_this.state.killed) return;\n\n      var _event$data = event.data;\n      var paths = _event$data.paths;\n      var previousData = _event$data.previousData;\n      var update = fireUpdate.bind(_this, previousData);\n      var comparedPaths = _this._getComparedPaths();\n\n      if ((0, _helpers.solveUpdate)(paths, comparedPaths)) return update();\n    };\n\n    // Lazy binding\n    var bound = false;\n    this._lazyBind = function () {\n      if (bound) return;\n\n      bound = true;\n\n      if (_this._dynamicPath) _this.tree.on('write', _this._writeHandler);\n\n      return _this.tree.on('update', _this._updateHandler);\n    };\n\n    // If the path is dynamic, we actually need to listen to the tree\n    if (this._dynamicPath) {\n      this._lazyBind();\n    } else {\n\n      // Overriding the emitter `on` and `once` methods\n      this.on = (0, _helpers.before)(this._lazyBind, this.on.bind(this));\n      this.once = (0, _helpers.before)(this._lazyBind, this.once.bind(this));\n    }\n  }\n\n  /**\n   * Method used to allow iterating over cursors containing list-type data.\n   *\n   * e.g. for(let i of cursor) { ... }\n   *\n   * @returns {object} -  Each item sequentially.\n   */\n\n  /**\n   * Internal helpers\n   * -----------------\n   */\n\n  /**\n   * Method returning the paths of the tree watched over by the cursor and that\n   * should be taken into account when solving a potential update.\n   *\n   * @return {array} - Array of paths to compare with a given update.\n   */\n\n  _createClass(Cursor, [{\n    key: '_getComparedPaths',\n    value: function _getComparedPaths() {\n\n      // Checking whether we should keep track of some dependencies\n      var additionalPaths = this._monkeyPath ? (0, _helpers.getIn)(this.tree._monkeys, this._monkeyPath).data.relatedPaths() : [];\n\n      return [this.solvedPath].concat(additionalPaths);\n    }\n\n    /**\n     * Predicates\n     * -----------\n     */\n\n    /**\n     * Method returning whether the cursor is at root level.\n     *\n     * @return {boolean} - Is the cursor the root?\n     */\n  }, {\n    key: 'isRoot',\n    value: function isRoot() {\n      return !this.path.length;\n    }\n\n    /**\n     * Method returning whether the cursor is at leaf level.\n     *\n     * @return {boolean} - Is the cursor a leaf?\n     */\n  }, {\n    key: 'isLeaf',\n    value: function isLeaf() {\n      return _type2['default'].primitive(this._get().data);\n    }\n\n    /**\n     * Method returning whether the cursor is at branch level.\n     *\n     * @return {boolean} - Is the cursor a branch?\n     */\n  }, {\n    key: 'isBranch',\n    value: function isBranch() {\n      return !this.isRoot() && !this.isLeaf();\n    }\n\n    /**\n     * Traversal Methods\n     * ------------------\n     */\n\n    /**\n     * Method returning the root cursor.\n     *\n     * @return {Baobab} - The root cursor.\n     */\n  }, {\n    key: 'root',\n    value: function root() {\n      return this.tree.select();\n    }\n\n    /**\n     * Method selecting a subpath as a new cursor.\n     *\n     * Arity (1):\n     * @param  {path} path    - The path to select.\n     *\n     * Arity (*):\n     * @param  {...step} path - The path to select.\n     *\n     * @return {Cursor}       - The created cursor.\n     */\n  }, {\n    key: 'select',\n    value: function select(path) {\n      if (arguments.length > 1) path = (0, _helpers.arrayFrom)(arguments);\n\n      return this.tree.select(this.path.concat(path));\n    }\n\n    /**\n     * Method returning the parent node of the cursor or else `null` if the\n     * cursor is already at root level.\n     *\n     * @return {Baobab} - The parent cursor.\n     */\n  }, {\n    key: 'up',\n    value: function up() {\n      if (!this.isRoot()) return this.tree.select(this.path.slice(0, -1));\n\n      return null;\n    }\n\n    /**\n     * Method returning the child node of the cursor.\n     *\n     * @return {Baobab} - The child cursor.\n     */\n  }, {\n    key: 'down',\n    value: function down() {\n      checkPossibilityOfDynamicTraversal('down', this.solvedPath);\n\n      if (!(this._get().data instanceof Array)) throw Error('Baobab.Cursor.down: cannot go down on a non-list type.');\n\n      return this.tree.select(this.solvedPath.concat(0));\n    }\n\n    /**\n     * Method returning the left sibling node of the cursor if this one is\n     * pointing at a list. Returns `null` if this cursor is already leftmost.\n     *\n     * @return {Baobab} - The left sibling cursor.\n     */\n  }, {\n    key: 'left',\n    value: function left() {\n      checkPossibilityOfDynamicTraversal('left', this.solvedPath);\n\n      var last = +this.solvedPath[this.solvedPath.length - 1];\n\n      if (isNaN(last)) throw Error('Baobab.Cursor.left: cannot go left on a non-list type.');\n\n      return last ? this.tree.select(this.solvedPath.slice(0, -1).concat(last - 1)) : null;\n    }\n\n    /**\n     * Method returning the right sibling node of the cursor if this one is\n     * pointing at a list. Returns `null` if this cursor is already rightmost.\n     *\n     * @return {Baobab} - The right sibling cursor.\n     */\n  }, {\n    key: 'right',\n    value: function right() {\n      checkPossibilityOfDynamicTraversal('right', this.solvedPath);\n\n      var last = +this.solvedPath[this.solvedPath.length - 1];\n\n      if (isNaN(last)) throw Error('Baobab.Cursor.right: cannot go right on a non-list type.');\n\n      if (last + 1 === this.up()._get().data.length) return null;\n\n      return this.tree.select(this.solvedPath.slice(0, -1).concat(last + 1));\n    }\n\n    /**\n     * Method returning the leftmost sibling node of the cursor if this one is\n     * pointing at a list.\n     *\n     * @return {Baobab} - The leftmost sibling cursor.\n     */\n  }, {\n    key: 'leftmost',\n    value: function leftmost() {\n      checkPossibilityOfDynamicTraversal('leftmost', this.solvedPath);\n\n      var last = +this.solvedPath[this.solvedPath.length - 1];\n\n      if (isNaN(last)) throw Error('Baobab.Cursor.leftmost: cannot go left on a non-list type.');\n\n      return this.tree.select(this.solvedPath.slice(0, -1).concat(0));\n    }\n\n    /**\n     * Method returning the rightmost sibling node of the cursor if this one is\n     * pointing at a list.\n     *\n     * @return {Baobab} - The rightmost sibling cursor.\n     */\n  }, {\n    key: 'rightmost',\n    value: function rightmost() {\n      checkPossibilityOfDynamicTraversal('rightmost', this.solvedPath);\n\n      var last = +this.solvedPath[this.solvedPath.length - 1];\n\n      if (isNaN(last)) throw Error('Baobab.Cursor.rightmost: cannot go right on a non-list type.');\n\n      var list = this.up()._get().data;\n\n      return this.tree.select(this.solvedPath.slice(0, -1).concat(list.length - 1));\n    }\n\n    /**\n     * Method mapping the children nodes of the cursor.\n     *\n     * @param  {function} fn      - The function to map.\n     * @param  {object}   [scope] - An optional scope.\n     * @return {array}            - The resultant array.\n     */\n  }, {\n    key: 'map',\n    value: function map(fn, scope) {\n      checkPossibilityOfDynamicTraversal('map', this.solvedPath);\n\n      var array = this._get().data,\n          l = arguments.length;\n\n      if (!_type2['default'].array(array)) throw Error('baobab.Cursor.map: cannot map a non-list type.');\n\n      return array.map(function (item, i) {\n        return fn.call(l > 1 ? scope : this, this.select(i), i, array);\n      }, this);\n    }\n\n    /**\n     * Getter Methods\n     * ---------------\n     */\n\n    /**\n     * Internal get method. Basically contains the main body of the `get` method\n     * without the event emitting. This is sometimes needed not to fire useless\n     * events.\n     *\n     * @param  {path}   [path=[]]       - Path to get in the tree.\n     * @return {object} info            - The resultant information.\n     * @return {mixed}  info.data       - Data at path.\n     * @return {array}  info.solvedPath - The path solved when getting.\n     */\n  }, {\n    key: '_get',\n    value: function _get() {\n      var path = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];\n\n      if (!_type2['default'].path(path)) throw (0, _helpers.makeError)('Baobab.Cursor.getters: invalid path.', { path: path });\n\n      if (!this.solvedPath) return { data: undefined, solvedPath: null, exists: false };\n\n      return (0, _helpers.getIn)(this.tree._data, this.solvedPath.concat(path));\n    }\n\n    /**\n     * Method used to check whether a certain path exists in the tree starting\n     * from the current cursor.\n     *\n     * Arity (1):\n     * @param  {path}   path           - Path to check in the tree.\n     *\n     * Arity (2):\n     * @param {..step}  path           - Path to check in the tree.\n     *\n     * @return {boolean}               - Does the given path exists?\n     */\n  }, {\n    key: 'exists',\n    value: function exists(path) {\n      path = (0, _helpers.coercePath)(path);\n\n      if (arguments.length > 1) path = (0, _helpers.arrayFrom)(arguments);\n\n      return this._get(path).exists;\n    }\n\n    /**\n     * Method used to get data from the tree. Will fire a `get` event from the\n     * tree so that the user may sometimes react upon it to fetch data, for\n     * instance.\n     *\n     * Arity (1):\n     * @param  {path}   path           - Path to get in the tree.\n     *\n     * Arity (2):\n     * @param  {..step} path           - Path to get in the tree.\n     *\n     * @return {mixed}                 - Data at path.\n     */\n  }, {\n    key: 'get',\n    value: function get(path) {\n      path = (0, _helpers.coercePath)(path);\n\n      if (arguments.length > 1) path = (0, _helpers.arrayFrom)(arguments);\n\n      var _get2 = this._get(path);\n\n      var data = _get2.data;\n      var solvedPath = _get2.solvedPath;\n\n      // Emitting the event\n      this.tree.emit('get', { data: data, solvedPath: solvedPath, path: this.path.concat(path) });\n\n      return data;\n    }\n\n    /**\n     * Method used to shallow clone data from the tree.\n     *\n     * Arity (1):\n     * @param  {path}   path           - Path to get in the tree.\n     *\n     * Arity (2):\n     * @param  {..step} path           - Path to get in the tree.\n     *\n     * @return {mixed}                 - Cloned data at path.\n     */\n  }, {\n    key: 'clone',\n    value: function clone() {\n      var data = this.get.apply(this, arguments);\n\n      return (0, _helpers.shallowClone)(data);\n    }\n\n    /**\n     * Method used to deep clone data from the tree.\n     *\n     * Arity (1):\n     * @param  {path}   path           - Path to get in the tree.\n     *\n     * Arity (2):\n     * @param  {..step} path           - Path to get in the tree.\n     *\n     * @return {mixed}                 - Cloned data at path.\n     */\n  }, {\n    key: 'deepClone',\n    value: function deepClone() {\n      var data = this.get.apply(this, arguments);\n\n      return (0, _helpers.deepClone)(data);\n    }\n\n    /**\n     * Method used to return raw data from the tree, by carefully avoiding\n     * computed one.\n     *\n     * @todo: should be more performant as the cloning should happen as well as\n     * when dropping computed data.\n     *\n     * Arity (1):\n     * @param  {path}   path           - Path to serialize in the tree.\n     *\n     * Arity (2):\n     * @param  {..step} path           - Path to serialize in the tree.\n     *\n     * @return {mixed}                 - The retrieved raw data.\n     */\n  }, {\n    key: 'serialize',\n    value: function serialize(path) {\n      path = (0, _helpers.coercePath)(path);\n\n      if (arguments.length > 1) path = (0, _helpers.arrayFrom)(arguments);\n\n      if (!_type2['default'].path(path)) throw (0, _helpers.makeError)('Baobab.Cursor.getters: invalid path.', { path: path });\n\n      if (!this.solvedPath) return undefined;\n\n      var fullPath = this.solvedPath.concat(path);\n\n      var data = (0, _helpers.deepClone)((0, _helpers.getIn)(this.tree._data, fullPath).data),\n          monkeys = (0, _helpers.getIn)(this.tree._monkeys, fullPath).data;\n\n      var dropComputedData = function dropComputedData(d, m) {\n        if (!_type2['default'].object(m) || !_type2['default'].object(d)) return;\n\n        for (var k in m) {\n          if (m[k] instanceof _monkey.Monkey) delete d[k];else dropComputedData(d[k], m[k]);\n        }\n      };\n\n      dropComputedData(data, monkeys);\n      return data;\n    }\n\n    /**\n     * Method used to project some of the data at cursor onto a map or a list.\n     *\n     * @param  {object|array} projection - The projection's formal definition.\n     * @return {object|array}            - The resultant map/list.\n     */\n  }, {\n    key: 'project',\n    value: function project(projection) {\n      if (_type2['default'].object(projection)) {\n        var data = {};\n\n        for (var k in projection) {\n          data[k] = this.get(projection[k]);\n        }return data;\n      } else if (_type2['default'].array(projection)) {\n        var data = [];\n\n        for (var i = 0, l = projection.length; i < l; i++) {\n          data.push(this.get(projection[i]));\n        }return data;\n      }\n\n      throw (0, _helpers.makeError)('Baobab.Cursor.project: wrong projection.', { projection: projection });\n    }\n\n    /**\n     * History Methods\n     * ----------------\n     */\n\n    /**\n     * Methods starting to record the cursor's successive states.\n     *\n     * @param  {integer} [maxRecords] - Maximum records to keep in memory. Note\n     *                                  that if no number is provided, the cursor\n     *                                  will keep everything.\n     * @return {Cursor}               - The cursor instance for chaining purposes.\n     */\n  }, {\n    key: 'startRecording',\n    value: function startRecording(maxRecords) {\n      maxRecords = maxRecords || Infinity;\n\n      if (maxRecords < 1) throw (0, _helpers.makeError)('Baobab.Cursor.startRecording: invalid max records.', {\n        value: maxRecords\n      });\n\n      this.state.recording = true;\n\n      if (this.archive) return this;\n\n      // Lazy binding\n      this._lazyBind();\n\n      this.archive = new _helpers.Archive(maxRecords);\n      return this;\n    }\n\n    /**\n     * Methods stopping to record the cursor's successive states.\n     *\n     * @return {Cursor} - The cursor instance for chaining purposes.\n     */\n  }, {\n    key: 'stopRecording',\n    value: function stopRecording() {\n      this.state.recording = false;\n      return this;\n    }\n\n    /**\n     * Methods undoing n steps of the cursor's recorded states.\n     *\n     * @param  {integer} [steps=1] - The number of steps to rollback.\n     * @return {Cursor}            - The cursor instance for chaining purposes.\n     */\n  }, {\n    key: 'undo',\n    value: function undo() {\n      var steps = arguments.length <= 0 || arguments[0] === undefined ? 1 : arguments[0];\n\n      if (!this.state.recording) throw new Error('Baobab.Cursor.undo: cursor is not recording.');\n\n      var record = this.archive.back(steps);\n\n      if (!record) throw Error('Baobab.Cursor.undo: cannot find a relevant record.');\n\n      this.state.undoing = true;\n      this.set(record);\n\n      return this;\n    }\n\n    /**\n     * Methods returning whether the cursor has a recorded history.\n     *\n     * @return {boolean} - `true` if the cursor has a recorded history?\n     */\n  }, {\n    key: 'hasHistory',\n    value: function hasHistory() {\n      return !!(this.archive && this.archive.get().length);\n    }\n\n    /**\n     * Methods returning the cursor's history.\n     *\n     * @return {array} - The cursor's history.\n     */\n  }, {\n    key: 'getHistory',\n    value: function getHistory() {\n      return this.archive ? this.archive.get() : [];\n    }\n\n    /**\n     * Methods clearing the cursor's history.\n     *\n     * @return {Cursor} - The cursor instance for chaining purposes.\n     */\n  }, {\n    key: 'clearHistory',\n    value: function clearHistory() {\n      if (this.archive) this.archive.clear();\n      return this;\n    }\n\n    /**\n     * Releasing\n     * ----------\n     */\n\n    /**\n     * Methods releasing the cursor from memory.\n     */\n  }, {\n    key: 'release',\n    value: function release() {\n\n      // Removing listeners on parent\n      if (this._dynamicPath) this.tree.off('write', this._writeHandler);\n\n      this.tree.off('update', this._updateHandler);\n\n      // Unsubscribe from the parent\n      if (this.hash) delete this.tree._cursors[this.hash];\n\n      // Dereferencing\n      delete this.tree;\n      delete this.path;\n      delete this.solvedPath;\n      delete this.archive;\n\n      // Killing emitter\n      this.kill();\n      this.state.killed = true;\n    }\n\n    /**\n     * Output\n     * -------\n     */\n\n    /**\n     * Overriding the `toJSON` method for convenient use with JSON.stringify.\n     *\n     * @return {mixed} - Data at cursor.\n     */\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return this.serialize();\n    }\n\n    /**\n     * Overriding the `toString` method for debugging purposes.\n     *\n     * @return {string} - The cursor's identity.\n     */\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return this._identity;\n    }\n  }]);\n\n  return Cursor;\n})(_emmett2['default']);\n\nexports['default'] = Cursor;\nif (typeof Symbol === 'function' && typeof Symbol.iterator !== 'undefined') {\n  Cursor.prototype[Symbol.iterator] = function () {\n    var array = this._get().data;\n\n    if (!_type2['default'].array(array)) throw Error('baobab.Cursor.@@iterate: cannot iterate a non-list type.');\n\n    var i = 0;\n\n    var cursor = this,\n        length = array.length;\n\n    return {\n      next: function next() {\n        if (i < length) {\n          return {\n            value: cursor.select(i++)\n          };\n        }\n\n        return {\n          done: true\n        };\n      }\n    };\n  };\n}\n\n/**\n * Setter Methods\n * ---------------\n *\n * Those methods are dynamically assigned to the class for DRY reasons.\n */\n\n// Not using a Set so that ES5 consumers don't pay a bundle size price\nvar INTRANSITIVE_SETTERS = {\n  unset: true,\n  pop: true,\n  shift: true\n};\n\n/**\n * Function creating a setter method for the Cursor class.\n *\n * @param {string}   name          - the method's name.\n * @param {function} [typeChecker] - a function checking that the given value is\n *                                   valid for the given operation.\n */\nfunction makeSetter(name, typeChecker) {\n\n  /**\n   * Binding a setter method to the Cursor class and having the following\n   * definition.\n   *\n   * Note: this is not really possible to make those setters variadic because\n   * it would create an impossible polymorphism with path.\n   *\n   * @todo: perform value validation elsewhere so that tree.update can\n   * beneficiate from it.\n   *\n   * Arity (1):\n   * @param  {mixed} value - New value to set at cursor's path.\n   *\n   * Arity (2):\n   * @param  {path}  path  - Subpath to update starting from cursor's.\n   * @param  {mixed} value - New value to set.\n   *\n   * @return {mixed}       - Data at path.\n   */\n  Cursor.prototype[name] = function (path, value) {\n\n    // We should warn the user if he applies to many arguments to the function\n    if (arguments.length > 2) throw (0, _helpers.makeError)('Baobab.Cursor.' + name + ': too many arguments.');\n\n    // Handling arities\n    if (arguments.length === 1 && !INTRANSITIVE_SETTERS[name]) {\n      value = path;\n      path = [];\n    }\n\n    // Coerce path\n    path = (0, _helpers.coercePath)(path);\n\n    // Checking the path's validity\n    if (!_type2['default'].path(path)) throw (0, _helpers.makeError)('Baobab.Cursor.' + name + ': invalid path.', { path: path });\n\n    // Checking the value's validity\n    if (typeChecker && !typeChecker(value)) throw (0, _helpers.makeError)('Baobab.Cursor.' + name + ': invalid value.', { path: path, value: value });\n\n    // Checking the solvability of the cursor's dynamic path\n    if (!this.solvedPath) throw (0, _helpers.makeError)('Baobab.Cursor.' + name + ': the dynamic path of the cursor cannot be solved.', { path: this.path });\n\n    var fullPath = this.solvedPath.concat(path);\n\n    // Filing the update to the tree\n    return this.tree.update(fullPath, {\n      type: name,\n      value: value\n    });\n  };\n}\n\n/**\n * Making the necessary setters.\n */\nmakeSetter('set');\nmakeSetter('unset');\nmakeSetter('apply', _type2['default']['function']);\nmakeSetter('push');\nmakeSetter('concat', _type2['default'].array);\nmakeSetter('unshift');\nmakeSetter('pop');\nmakeSetter('shift');\nmakeSetter('splice', _type2['default'].splicer);\nmakeSetter('merge', _type2['default'].object);\nmakeSetter('deepMerge', _type2['default'].object);\nmodule.exports = exports['default'];\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/baobab/dist/cursor.js\n ** module id = 27\n ** module chunks = 0\n **/","/**\n * Baobab Monkeys\n * ===============\n *\n * Exposing both handy monkey definitions and the underlying working class.\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nvar _type = require('./type');\n\nvar _type2 = _interopRequireDefault(_type);\n\nvar _update2 = require('./update');\n\nvar _update3 = _interopRequireDefault(_update2);\n\nvar _helpers = require('./helpers');\n\n/**\n * Monkey Definition class\n * Note: The only reason why this is a class is to be able to spot it within\n * otherwise ordinary data.\n *\n * @constructor\n * @param {array|object} definition - The formal definition of the monkey.\n */\n\nvar MonkeyDefinition = function MonkeyDefinition(definition) {\n  var _this = this;\n\n  _classCallCheck(this, MonkeyDefinition);\n\n  var monkeyType = _type2['default'].monkeyDefinition(definition);\n\n  if (!monkeyType) throw (0, _helpers.makeError)('Baobab.monkey: invalid definition.', { definition: definition });\n\n  this.type = monkeyType;\n\n  if (this.type === 'object') {\n    this.getter = definition.get;\n    this.projection = definition.cursors || {};\n    this.paths = Object.keys(this.projection).map(function (k) {\n      return _this.projection[k];\n    });\n    this.options = definition.options || {};\n  } else {\n    var offset = 1,\n        options = {};\n\n    if (_type2['default'].object(definition[definition.length - 1])) {\n      offset++;\n      options = definition[definition.length - 1];\n    }\n\n    this.getter = definition[definition.length - offset];\n    this.projection = definition.slice(0, -offset);\n    this.paths = this.projection;\n    this.options = options;\n  }\n\n  // Coercing paths for convenience\n  this.paths = this.paths.map(function (p) {\n    return [].concat(p);\n  });\n\n  // Does the definition contain dynamic paths\n  this.hasDynamicPaths = this.paths.some(_type2['default'].dynamicPath);\n}\n\n/**\n * Monkey core class\n *\n * @constructor\n * @param {Baobab}           tree       - The bound tree.\n * @param {MonkeyDefinition} definition - A definition instance.\n */\n;\n\nexports.MonkeyDefinition = MonkeyDefinition;\n\nvar Monkey = (function () {\n  function Monkey(tree, pathInTree, definition) {\n    var _this2 = this;\n\n    _classCallCheck(this, Monkey);\n\n    // Properties\n    this.tree = tree;\n    this.path = pathInTree;\n    this.definition = definition;\n\n    // Adapting the definition's paths & projection to this monkey's case\n    var projection = definition.projection,\n        relative = _helpers.solveRelativePath.bind(null, pathInTree.slice(0, -1));\n\n    if (definition.type === 'object') {\n      this.projection = Object.keys(projection).reduce(function (acc, k) {\n        acc[k] = relative(projection[k]);\n        return acc;\n      }, {});\n      this.depPaths = Object.keys(this.projection).map(function (k) {\n        return _this2.projection[k];\n      });\n    } else {\n      this.projection = projection.map(relative);\n      this.depPaths = this.projection;\n    }\n\n    // Internal state\n    this.state = {\n      killed: false\n    };\n\n    /**\n     * Listener on the tree's `write` event.\n     *\n     * When the tree writes, this listener will check whether the updated paths\n     * are of any use to the monkey and, if so, will update the tree's node\n     * where the monkey sits.\n     */\n    this.writeListener = function (_ref) {\n      var path = _ref.data.path;\n\n      if (_this2.state.killed) return;\n\n      // Is the monkey affected by the current write event?\n      var concerned = (0, _helpers.solveUpdate)([path], _this2.relatedPaths());\n\n      if (concerned) _this2.update();\n    };\n\n    /**\n     * Listener on the tree's `monkey` event.\n     *\n     * When another monkey updates, this listener will check whether the\n     * updated paths are of any use to the monkey and, if so, will update the\n     * tree's node where the monkey sits.\n     */\n    this.recursiveListener = function (_ref2) {\n      var _ref2$data = _ref2.data;\n      var monkey = _ref2$data.monkey;\n      var path = _ref2$data.path;\n\n      if (_this2.state.killed) return;\n\n      // Breaking if this is the same monkey\n      if (_this2 === monkey) return;\n\n      // Is the monkey affected by the current monkey event?\n      var concerned = (0, _helpers.solveUpdate)([path], _this2.relatedPaths(false));\n\n      if (concerned) _this2.update();\n    };\n\n    // Binding listeners\n    this.tree.on('write', this.writeListener);\n    this.tree.on('_monkey', this.recursiveListener);\n\n    // Updating relevant node\n    this.update();\n  }\n\n  /**\n   * Method returning solved paths related to the monkey.\n   *\n   * @param  {boolean} recursive - Should we compute recursive paths?\n   * @return {array}             - An array of related paths.\n   */\n\n  _createClass(Monkey, [{\n    key: 'relatedPaths',\n    value: function relatedPaths() {\n      var _this3 = this;\n\n      var recursive = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];\n\n      var paths = undefined;\n\n      if (this.definition.hasDynamicPaths) paths = this.depPaths.map(function (p) {\n        return (0, _helpers.getIn)(_this3.tree._data, p).solvedPath;\n      });else paths = this.depPaths;\n\n      var isRecursive = recursive && this.depPaths.some(function (p) {\n        return !!_type2['default'].monkeyPath(_this3.tree._monkeys, p);\n      });\n\n      if (!isRecursive) return paths;\n\n      return paths.reduce(function (accumulatedPaths, path) {\n        var monkeyPath = _type2['default'].monkeyPath(_this3.tree._monkeys, path);\n\n        if (!monkeyPath) return accumulatedPaths.concat([path]);\n\n        // Solving recursive path\n        var relatedMonkey = (0, _helpers.getIn)(_this3.tree._monkeys, monkeyPath).data;\n\n        return accumulatedPaths.concat(relatedMonkey.relatedPaths());\n      }, []);\n    }\n\n    /**\n     * Method used to update the tree's internal data with a lazy getter holding\n     * the computed data.\n     *\n     * @return {Monkey} - Returns itself for chaining purposes.\n     */\n  }, {\n    key: 'update',\n    value: function update() {\n      var deps = this.tree.project(this.projection);\n\n      var lazyGetter = (function (tree, def, data) {\n        var cache = null,\n            alreadyComputed = false;\n\n        return function () {\n\n          if (!alreadyComputed) {\n            cache = def.getter.apply(tree, def.type === 'object' ? [data] : data);\n\n            if (tree.options.immutable && def.options.immutable !== false) (0, _helpers.deepFreeze)(cache);\n\n            alreadyComputed = true;\n          }\n\n          return cache;\n        };\n      })(this.tree, this.definition, deps);\n\n      lazyGetter.isLazyGetter = true;\n\n      // Should we write the lazy getter in the tree or solve it right now?\n      if (this.tree.options.lazyMonkeys) {\n        this.tree._data = (0, _update3['default'])(this.tree._data, this.path, {\n          type: 'monkey',\n          value: lazyGetter\n        }, this.tree.options).data;\n      } else {\n        var result = (0, _update3['default'])(this.tree._data, this.path, {\n          type: 'set',\n          value: lazyGetter(),\n          options: {\n            mutableLeaf: !this.definition.options.immutable\n          }\n        }, this.tree.options);\n\n        if ('data' in result) this.tree._data = result.data;\n      }\n\n      // Notifying the monkey's update so we can handle recursivity\n      this.tree.emit('_monkey', { monkey: this, path: this.path });\n\n      return this;\n    }\n\n    /**\n     * Method releasing the monkey from memory.\n     */\n  }, {\n    key: 'release',\n    value: function release() {\n\n      // Unbinding events\n      this.tree.off('write', this.writeListener);\n      this.tree.off('_monkey', this.monkeyListener);\n      this.state.killed = true;\n\n      // Deleting properties\n      // NOTE: not deleting this.definition because some strange things happen\n      // in the _refreshMonkeys method. See #372.\n      delete this.projection;\n      delete this.depPaths;\n      delete this.tree;\n    }\n  }]);\n\n  return Monkey;\n})();\n\nexports.Monkey = Monkey;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/baobab/dist/monkey.js\n ** module id = 28\n ** module chunks = 0\n **/","/**\n * Baobab Type Checking\n * =====================\n *\n * Helpers functions used throughout the library to perform some type\n * tests at runtime.\n *\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _monkey = require('./monkey');\n\nvar type = {};\n\n/**\n * Helpers\n * --------\n */\n\n/**\n * Checking whether the given variable is of any of the given types.\n *\n * @todo   Optimize this function by dropping `some`.\n *\n * @param  {mixed} target  - Variable to test.\n * @param  {array} allowed - Array of allowed types.\n * @return {boolean}\n */\nfunction anyOf(target, allowed) {\n  return allowed.some(function (t) {\n    return type[t](target);\n  });\n}\n\n/**\n * Simple types\n * -------------\n */\n\n/**\n * Checking whether the given variable is an array.\n *\n * @param  {mixed} target - Variable to test.\n * @return {boolean}\n */\ntype.array = function (target) {\n  return Array.isArray(target);\n};\n\n/**\n * Checking whether the given variable is an object.\n *\n * @param  {mixed} target - Variable to test.\n * @return {boolean}\n */\ntype.object = function (target) {\n  return target && typeof target === 'object' && !Array.isArray(target) && !(target instanceof Date) && !(target instanceof RegExp) && !(typeof Map === 'function' && target instanceof Map) && !(typeof Set === 'function' && target instanceof Set);\n};\n\n/**\n * Checking whether the given variable is a string.\n *\n * @param  {mixed} target - Variable to test.\n * @return {boolean}\n */\ntype.string = function (target) {\n  return typeof target === 'string';\n};\n\n/**\n * Checking whether the given variable is a number.\n *\n * @param  {mixed} target - Variable to test.\n * @return {boolean}\n */\ntype.number = function (target) {\n  return typeof target === 'number';\n};\n\n/**\n * Checking whether the given variable is a function.\n *\n * @param  {mixed} target - Variable to test.\n * @return {boolean}\n */\ntype['function'] = function (target) {\n  return typeof target === 'function';\n};\n\n/**\n * Checking whether the given variable is a JavaScript primitive.\n *\n * @param  {mixed} target - Variable to test.\n * @return {boolean}\n */\ntype.primitive = function (target) {\n  return target !== Object(target);\n};\n\n/**\n * Complex types\n * --------------\n */\n\n/**\n * Checking whether the given variable is a valid splicer.\n *\n * @param  {mixed} target    - Variable to test.\n * @param  {array} [allowed] - Optional valid types in path.\n * @return {boolean}\n */\ntype.splicer = function (target) {\n  if (!type.array(target) || target.length < 2) return false;\n\n  return anyOf(target[0], ['number', 'function', 'object']) && type.number(target[1]);\n};\n\n/**\n * Checking whether the given variable is a valid cursor path.\n *\n * @param  {mixed} target    - Variable to test.\n * @param  {array} [allowed] - Optional valid types in path.\n * @return {boolean}\n */\n\n// Order is important for performance reasons\nvar ALLOWED_FOR_PATH = ['string', 'number', 'function', 'object'];\n\ntype.path = function (target) {\n  if (!target && target !== 0 && target !== '') return false;\n\n  return [].concat(target).every(function (step) {\n    return anyOf(step, ALLOWED_FOR_PATH);\n  });\n};\n\n/**\n * Checking whether the given path is a dynamic one.\n *\n * @param  {mixed} path - The path to test.\n * @return {boolean}\n */\ntype.dynamicPath = function (path) {\n  return path.some(function (step) {\n    return type['function'](step) || type.object(step);\n  });\n};\n\n/**\n * Retrieve any monkey subpath in the given path or null if the path never comes\n * across computed data.\n *\n * @param  {mixed} data - The data to test.\n * @param  {array} path - The path to test.\n * @return {boolean}\n */\ntype.monkeyPath = function (data, path) {\n  var subpath = [];\n\n  var c = data,\n      i = undefined,\n      l = undefined;\n\n  for (i = 0, l = path.length; i < l; i++) {\n    subpath.push(path[i]);\n\n    if (typeof c !== 'object') return null;\n\n    c = c[path[i]];\n\n    if (c instanceof _monkey.Monkey) return subpath;\n  }\n\n  return null;\n};\n\n/**\n * Check if the given object property is a lazy getter used by a monkey.\n *\n * @param  {mixed}   o           - The target object.\n * @param  {string}  propertyKey - The property to test.\n * @return {boolean}\n */\ntype.lazyGetter = function (o, propertyKey) {\n  var descriptor = Object.getOwnPropertyDescriptor(o, propertyKey);\n\n  return descriptor && descriptor.get && descriptor.get.isLazyGetter === true;\n};\n\n/**\n * Returns the type of the given monkey definition or `null` if invalid.\n *\n * @param  {mixed} definition - The definition to check.\n * @return {string|null}\n */\ntype.monkeyDefinition = function (definition) {\n\n  if (type.object(definition)) {\n    if (!type['function'](definition.get) || definition.cursors && (!type.object(definition.cursors) || !Object.keys(definition.cursors).every(function (k) {\n      return type.path(definition.cursors[k]);\n    }))) return null;\n\n    return 'object';\n  } else if (type.array(definition)) {\n    var offset = 1;\n\n    if (type.object(definition[definition.length - 1])) offset++;\n\n    if (!type['function'](definition[definition.length - offset]) || !definition.slice(0, -offset).every(function (p) {\n      return type.path(p);\n    })) return null;\n\n    return 'array';\n  }\n\n  return null;\n};\n\n/**\n * Checking whether the given watcher definition is valid.\n *\n * @param  {mixed}   definition - The definition to check.\n * @return {boolean}\n */\ntype.watcherMapping = function (definition) {\n  return type.object(definition) && Object.keys(definition).every(function (k) {\n    return type.path(definition[k]);\n  });\n};\n\n/**\n * Checking whether the given string is a valid operation type.\n *\n * @param  {mixed} string - The string to test.\n * @return {boolean}\n */\n\n// Ordered by likeliness\nvar VALID_OPERATIONS = ['set', 'apply', 'push', 'unshift', 'concat', 'pop', 'shift', 'deepMerge', 'merge', 'splice', 'unset'];\n\ntype.operationType = function (string) {\n  return typeof string === 'string' && !! ~VALID_OPERATIONS.indexOf(string);\n};\n\nexports['default'] = type;\nmodule.exports = exports['default'];\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/baobab/dist/type.js\n ** module id = 29\n ** module chunks = 0\n **/","/**\n * Baobab Update\n * ==============\n *\n * The tree's update scheme.\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports['default'] = update;\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }\n\nvar _type = require('./type');\n\nvar _type2 = _interopRequireDefault(_type);\n\nvar _helpers = require('./helpers');\n\nfunction err(operation, expectedTarget, path) {\n  return (0, _helpers.makeError)('Baobab.update: cannot apply the \"' + operation + '\" on ' + ('a non ' + expectedTarget + ' (path: /' + path.join('/') + ').'), { path: path });\n}\n\n/**\n * Function aiming at applying a single update operation on the given tree's\n * data.\n *\n * @param  {mixed}  data      - The tree's data.\n * @param  {path}   path      - Path of the update.\n * @param  {object} operation - The operation to apply.\n * @param  {object} [opts]    - Optional options.\n * @return {mixed}            - Both the new tree's data and the updated node.\n */\n\nfunction update(data, path, operation) {\n  var opts = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];\n  var operationType = operation.type;\n  var value = operation.value;\n  var _operation$options = operation.options;\n  var operationOptions = _operation$options === undefined ? {} : _operation$options;\n\n  // Dummy root, so we can shift and alter the root\n  var dummy = { root: data },\n      dummyPath = ['root'].concat(_toConsumableArray(path)),\n      currentPath = [];\n\n  // Walking the path\n  var p = dummy,\n      i = undefined,\n      l = undefined,\n      s = undefined;\n\n  for (i = 0, l = dummyPath.length; i < l; i++) {\n\n    // Current item's reference is therefore p[s]\n    // The reason why we don't create a variable here for convenience\n    // is because we actually need to mutate the reference.\n    s = dummyPath[i];\n\n    // Updating the path\n    if (i > 0) currentPath.push(s);\n\n    // If we reached the end of the path, we apply the operation\n    if (i === l - 1) {\n\n      /**\n       * Set\n       */\n      if (operationType === 'set') {\n\n        // Purity check\n        if (opts.pure && p[s] === value) return { node: p[s] };\n\n        if (_type2['default'].lazyGetter(p, s)) {\n          Object.defineProperty(p, s, {\n            value: value,\n            enumerable: true,\n            configurable: true\n          });\n        } else if (opts.persistent && !operationOptions.mutableLeaf) {\n          p[s] = (0, _helpers.shallowClone)(value);\n        } else {\n          p[s] = value;\n        }\n      }\n\n      /**\n       * Monkey\n       */\n      else if (operationType === 'monkey') {\n          Object.defineProperty(p, s, {\n            get: value,\n            enumerable: true,\n            configurable: true\n          });\n        }\n\n        /**\n         * Apply\n         */\n        else if (operationType === 'apply') {\n            var result = value(p[s]);\n\n            // Purity check\n            if (opts.pure && p[s] === result) return { node: p[s] };\n\n            if (_type2['default'].lazyGetter(p, s)) {\n              Object.defineProperty(p, s, {\n                value: result,\n                enumerable: true,\n                configurable: true\n              });\n            } else if (opts.persistent) {\n              p[s] = (0, _helpers.shallowClone)(result);\n            } else {\n              p[s] = result;\n            }\n          }\n\n          /**\n           * Push\n           */\n          else if (operationType === 'push') {\n              if (!_type2['default'].array(p[s])) throw err('push', 'array', currentPath);\n\n              if (opts.persistent) p[s] = p[s].concat([value]);else p[s].push(value);\n            }\n\n            /**\n             * Unshift\n             */\n            else if (operationType === 'unshift') {\n                if (!_type2['default'].array(p[s])) throw err('unshift', 'array', currentPath);\n\n                if (opts.persistent) p[s] = [value].concat(p[s]);else p[s].unshift(value);\n              }\n\n              /**\n               * Concat\n               */\n              else if (operationType === 'concat') {\n                  if (!_type2['default'].array(p[s])) throw err('concat', 'array', currentPath);\n\n                  if (opts.persistent) p[s] = p[s].concat(value);else p[s].push.apply(p[s], value);\n                }\n\n                /**\n                 * Splice\n                 */\n                else if (operationType === 'splice') {\n                    if (!_type2['default'].array(p[s])) throw err('splice', 'array', currentPath);\n\n                    if (opts.persistent) p[s] = _helpers.splice.apply(null, [p[s]].concat(value));else p[s].splice.apply(p[s], value);\n                  }\n\n                  /**\n                   * Pop\n                   */\n                  else if (operationType === 'pop') {\n                      if (!_type2['default'].array(p[s])) throw err('pop', 'array', currentPath);\n\n                      if (opts.persistent) p[s] = (0, _helpers.splice)(p[s], -1, 1);else p[s].pop();\n                    }\n\n                    /**\n                     * Shift\n                     */\n                    else if (operationType === 'shift') {\n                        if (!_type2['default'].array(p[s])) throw err('shift', 'array', currentPath);\n\n                        if (opts.persistent) p[s] = (0, _helpers.splice)(p[s], 0, 1);else p[s].shift();\n                      }\n\n                      /**\n                       * Unset\n                       */\n                      else if (operationType === 'unset') {\n                          if (_type2['default'].object(p)) delete p[s];else if (_type2['default'].array(p)) p.splice(s, 1);\n                        }\n\n                        /**\n                         * Merge\n                         */\n                        else if (operationType === 'merge') {\n                            if (!_type2['default'].object(p[s])) throw err('merge', 'object', currentPath);\n\n                            if (opts.persistent) p[s] = (0, _helpers.shallowMerge)({}, p[s], value);else p[s] = (0, _helpers.shallowMerge)(p[s], value);\n                          }\n\n                          /**\n                           * Deep merge\n                           */\n                          else if (operationType === 'deepMerge') {\n                              if (!_type2['default'].object(p[s])) throw err('deepMerge', 'object', currentPath);\n\n                              if (opts.persistent) p[s] = (0, _helpers.deepMerge)({}, p[s], value);else p[s] = (0, _helpers.deepMerge)(p[s], value);\n                            }\n\n      // Deep freezing the resulting value\n      if (opts.immutable && !operationOptions.mutableLeaf) (0, _helpers.deepFreeze)(p);\n\n      break;\n    }\n\n    // If we reached a leaf, we override by setting an empty object\n    else if (_type2['default'].primitive(p[s])) {\n        p[s] = {};\n      }\n\n      // Else, we shift the reference and continue the path\n      else if (opts.persistent) {\n          p[s] = (0, _helpers.shallowClone)(p[s]);\n        }\n\n    // Should we freeze the current step before continuing?\n    if (opts.immutable && l > 0) (0, _helpers.freeze)(p);\n\n    p = p[s];\n  }\n\n  // If we are updating a dynamic node, we need not return the affected node\n  if (_type2['default'].lazyGetter(p, s)) return { data: dummy.root };\n\n  // Returning new data object\n  return { data: dummy.root, node: p[s] };\n}\n\nmodule.exports = exports['default'];\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/baobab/dist/update.js\n ** module id = 30\n ** module chunks = 0\n **/","/* eslint eqeqeq: 0 */\n\n/**\n * Baobab Helpers\n * ===============\n *\n * Miscellaneous helper functions.\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nexports.arrayFrom = arrayFrom;\nexports.before = before;\nexports.coercePath = coercePath;\nexports.getIn = getIn;\nexports.makeError = makeError;\nexports.solveRelativePath = solveRelativePath;\nexports.solveUpdate = solveUpdate;\nexports.splice = splice;\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nvar _monkey = require('./monkey');\n\nvar _type = require('./type');\n\nvar _type2 = _interopRequireDefault(_type);\n\n/**\n * Noop function\n */\nvar noop = Function.prototype;\n\n/**\n * Function returning the index of the first element of a list matching the\n * given predicate.\n *\n * @param  {array}     a  - The target array.\n * @param  {function}  fn - The predicate function.\n * @return {mixed}        - The index of the first matching item or -1.\n */\nfunction index(a, fn) {\n  var i = undefined,\n      l = undefined;\n  for (i = 0, l = a.length; i < l; i++) {\n    if (fn(a[i])) return i;\n  }\n  return -1;\n}\n\n/**\n * Efficient slice function used to clone arrays or parts of them.\n *\n * @param  {array} array - The array to slice.\n * @return {array}       - The sliced array.\n */\nfunction slice(array) {\n  var newArray = new Array(array.length);\n\n  var i = undefined,\n      l = undefined;\n\n  for (i = 0, l = array.length; i < l; i++) newArray[i] = array[i];\n\n  return newArray;\n}\n\n/**\n * Archive abstraction\n *\n * @constructor\n * @param {integer} size - Maximum number of records to store.\n */\n\nvar Archive = (function () {\n  function Archive(size) {\n    _classCallCheck(this, Archive);\n\n    this.size = size;\n    this.records = [];\n  }\n\n  /**\n   * Function creating a real array from what should be an array but is not.\n   * I'm looking at you nasty `arguments`...\n   *\n   * @param  {mixed} culprit - The culprit to convert.\n   * @return {array}         - The real array.\n   */\n\n  /**\n   * Method retrieving the records.\n   *\n   * @return {array} - The records.\n   */\n\n  _createClass(Archive, [{\n    key: 'get',\n    value: function get() {\n      return this.records;\n    }\n\n    /**\n     * Method adding a record to the archive\n     *\n     * @param {object}  record - The record to store.\n     * @return {Archive}       - The archive itself for chaining purposes.\n     */\n  }, {\n    key: 'add',\n    value: function add(record) {\n      this.records.unshift(record);\n\n      // If the number of records is exceeded, we truncate the records\n      if (this.records.length > this.size) this.records.length = this.size;\n\n      return this;\n    }\n\n    /**\n     * Method clearing the records.\n     *\n     * @return {Archive} - The archive itself for chaining purposes.\n     */\n  }, {\n    key: 'clear',\n    value: function clear() {\n      this.records = [];\n      return this;\n    }\n\n    /**\n     * Method to go back in time.\n     *\n     * @param {integer} steps - Number of steps we should go back by.\n     * @return {number}       - The last record.\n     */\n  }, {\n    key: 'back',\n    value: function back(steps) {\n      var record = this.records[steps - 1];\n\n      if (record) this.records = this.records.slice(steps);\n      return record;\n    }\n  }]);\n\n  return Archive;\n})();\n\nexports.Archive = Archive;\n\nfunction arrayFrom(culprit) {\n  return slice(culprit);\n}\n\n/**\n * Function decorating one function with another that will be called before the\n * decorated one.\n *\n * @param  {function} decorator - The decorating function.\n * @param  {function} fn        - The function to decorate.\n * @return {function}           - The decorated function.\n */\n\nfunction before(decorator, fn) {\n  return function () {\n    decorator.apply(null, arguments);\n    fn.apply(null, arguments);\n  };\n}\n\n/**\n * Function cloning the given regular expression. Supports `y` and `u` flags\n * already.\n *\n * @param  {RegExp} re - The target regular expression.\n * @return {RegExp}    - The cloned regular expression.\n */\nfunction cloneRegexp(re) {\n  var pattern = re.source;\n\n  var flags = '';\n\n  if (re.global) flags += 'g';\n  if (re.multiline) flags += 'm';\n  if (re.ignoreCase) flags += 'i';\n  if (re.sticky) flags += 'y';\n  if (re.unicode) flags += 'u';\n\n  return new RegExp(pattern, flags);\n}\n\n/**\n * Function cloning the given variable.\n *\n * @todo: implement a faster way to clone an array.\n *\n * @param  {boolean} deep - Should we deep clone the variable.\n * @param  {mixed}   item - The variable to clone\n * @return {mixed}        - The cloned variable.\n */\nfunction cloner(deep, item) {\n  if (!item || typeof item !== 'object' || item instanceof Error || item instanceof _monkey.MonkeyDefinition || item instanceof _monkey.Monkey || 'ArrayBuffer' in global && item instanceof ArrayBuffer) return item;\n\n  // Array\n  if (_type2['default'].array(item)) {\n    if (deep) {\n      var a = [];\n\n      var i = undefined,\n          l = undefined;\n\n      for (i = 0, l = item.length; i < l; i++) a.push(cloner(true, item[i]));\n      return a;\n    }\n\n    return slice(item);\n  }\n\n  // Date\n  if (item instanceof Date) return new Date(item.getTime());\n\n  // RegExp\n  if (item instanceof RegExp) return cloneRegexp(item);\n\n  // Object\n  if (_type2['default'].object(item)) {\n    var o = {};\n\n    var k = undefined;\n\n    // NOTE: could be possible to erase computed properties through `null`.\n    for (k in item) {\n      if (_type2['default'].lazyGetter(item, k)) {\n        Object.defineProperty(o, k, {\n          get: Object.getOwnPropertyDescriptor(item, k).get,\n          enumerable: true,\n          configurable: true\n        });\n      } else if (item.hasOwnProperty(k)) {\n        o[k] = deep ? cloner(true, item[k]) : item[k];\n      }\n    }\n    return o;\n  }\n\n  return item;\n}\n\n/**\n * Exporting shallow and deep cloning functions.\n */\nvar shallowClone = cloner.bind(null, false),\n    deepClone = cloner.bind(null, true);\n\nexports.shallowClone = shallowClone;\nexports.deepClone = deepClone;\n\n/**\n * Coerce the given variable into a full-fledged path.\n *\n * @param  {mixed} target - The variable to coerce.\n * @return {array}        - The array path.\n */\n\nfunction coercePath(target) {\n  if (target || target === 0 || target === '') return target;\n  return [];\n}\n\n/**\n * Function comparing an object's properties to a given descriptive\n * object.\n *\n * @param  {object} object      - The object to compare.\n * @param  {object} description - The description's mapping.\n * @return {boolean}            - Whether the object matches the description.\n */\nfunction compare(object, description) {\n  var ok = true,\n      k = undefined;\n\n  // If we reached here via a recursive call, object may be undefined because\n  // not all items in a collection will have the same deep nesting structure.\n  if (!object) return false;\n\n  for (k in description) {\n    if (_type2['default'].object(description[k])) {\n      ok = ok && compare(object[k], description[k]);\n    } else if (_type2['default'].array(description[k])) {\n      ok = ok && !! ~description[k].indexOf(object[k]);\n    } else {\n      if (object[k] !== description[k]) return false;\n    }\n  }\n\n  return ok;\n}\n\n/**\n * Function freezing the given variable if possible.\n *\n * @param  {boolean} deep - Should we recursively freeze the given objects?\n * @param  {object}  o    - The variable to freeze.\n * @return {object}    - The merged object.\n */\nfunction freezer(deep, o) {\n  if (typeof o !== 'object' || o === null || o instanceof _monkey.Monkey) return;\n\n  Object.freeze(o);\n\n  if (!deep) return;\n\n  if (Array.isArray(o)) {\n\n    // Iterating through the elements\n    var i = undefined,\n        l = undefined;\n\n    for (i = 0, l = o.length; i < l; i++) freezer(true, o[i]);\n  } else {\n    var p = undefined,\n        k = undefined;\n\n    for (k in o) {\n      if (_type2['default'].lazyGetter(o, k)) continue;\n\n      p = o[k];\n\n      if (!p || !o.hasOwnProperty(k) || typeof p !== 'object' || Object.isFrozen(p)) continue;\n\n      freezer(true, p);\n    }\n  }\n}\n\n/**\n * Exporting both `freeze` and `deepFreeze` functions.\n * Note that if the engine does not support `Object.freeze` then this will\n * export noop functions instead.\n */\nvar isFreezeSupported = typeof Object.freeze === 'function';\n\nvar freeze = isFreezeSupported ? freezer.bind(null, false) : noop,\n    deepFreeze = isFreezeSupported ? freezer.bind(null, true) : noop;\n\nexports.freeze = freeze;\nexports.deepFreeze = deepFreeze;\n\n/**\n * Function retrieving nested data within the given object and according to\n * the given path.\n *\n * @todo: work if dynamic path hit objects also.\n * @todo: memoized perfgetters.\n *\n * @param  {object}  object - The object we need to get data from.\n * @param  {array}   path   - The path to follow.\n * @return {object}  result            - The result.\n * @return {mixed}   result.data       - The data at path, or `undefined`.\n * @return {array}   result.solvedPath - The solved path or `null`.\n * @return {boolean} result.exists     - Does the path exists in the tree?\n */\nvar NOT_FOUND_OBJECT = { data: undefined, solvedPath: null, exists: false };\n\nfunction getIn(object, path) {\n  if (!path) return NOT_FOUND_OBJECT;\n\n  var solvedPath = [];\n\n  var exists = true,\n      c = object,\n      idx = undefined,\n      i = undefined,\n      l = undefined;\n\n  for (i = 0, l = path.length; i < l; i++) {\n    if (!c) return {\n      data: undefined,\n      solvedPath: solvedPath.concat(path.slice(i)),\n      exists: false\n    };\n\n    if (typeof path[i] === 'function') {\n      if (!_type2['default'].array(c)) return NOT_FOUND_OBJECT;\n\n      idx = index(c, path[i]);\n      if (! ~idx) return NOT_FOUND_OBJECT;\n\n      solvedPath.push(idx);\n      c = c[idx];\n    } else if (typeof path[i] === 'object') {\n      if (!_type2['default'].array(c)) return NOT_FOUND_OBJECT;\n\n      idx = index(c, function (e) {\n        return compare(e, path[i]);\n      });\n      if (! ~idx) return NOT_FOUND_OBJECT;\n\n      solvedPath.push(idx);\n      c = c[idx];\n    } else {\n      solvedPath.push(path[i]);\n      exists = typeof c === 'object' && path[i] in c;\n      c = c[path[i]];\n    }\n  }\n\n  return { data: c, solvedPath: solvedPath, exists: exists };\n}\n\n/**\n * Little helper returning a JavaScript error carrying some data with it.\n *\n * @param  {string} message - The error message.\n * @param  {object} [data]  - Optional data to assign to the error.\n * @return {Error}          - The created error.\n */\n\nfunction makeError(message, data) {\n  var err = new Error(message);\n\n  for (var k in data) {\n    err[k] = data[k];\n  }return err;\n}\n\n/**\n * Function taking n objects to merge them together.\n * Note 1): the latter object will take precedence over the first one.\n * Note 2): the first object will be mutated to allow for perf scenarios.\n * Note 3): this function will consider monkeys as leaves.\n *\n * @param  {boolean}   deep    - Whether the merge should be deep or not.\n * @param  {...object} objects - Objects to merge.\n * @return {object}            - The merged object.\n */\nfunction merger(deep) {\n  for (var _len = arguments.length, objects = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    objects[_key - 1] = arguments[_key];\n  }\n\n  var o = objects[0];\n\n  var t = undefined,\n      i = undefined,\n      l = undefined,\n      k = undefined;\n\n  for (i = 1, l = objects.length; i < l; i++) {\n    t = objects[i];\n\n    for (k in t) {\n      if (deep && _type2['default'].object(t[k]) && !(t[k] instanceof _monkey.Monkey)) {\n        o[k] = merger(true, o[k] || {}, t[k]);\n      } else {\n        o[k] = t[k];\n      }\n    }\n  }\n\n  return o;\n}\n\n/**\n * Exporting both `shallowMerge` and `deepMerge` functions.\n */\nvar shallowMerge = merger.bind(null, false),\n    deepMerge = merger.bind(null, true);\n\nexports.shallowMerge = shallowMerge;\nexports.deepMerge = deepMerge;\n\n/**\n * Solving a potentially relative path.\n *\n * @param  {array} base - The base path from which to solve the path.\n * @param  {array} to   - The subpath to reach.\n * @param  {array}      - The solved absolute path.\n */\n\nfunction solveRelativePath(base, to) {\n  var solvedPath = [];\n\n  // Coercing to array\n  to = [].concat(to);\n\n  for (var i = 0, l = to.length; i < l; i++) {\n    var step = to[i];\n\n    if (step === '.') {\n      if (!i) solvedPath = base.slice(0);\n    } else if (step === '..') {\n      solvedPath = (!i ? base : solvedPath).slice(0, -1);\n    } else {\n      solvedPath.push(step);\n    }\n  }\n\n  return solvedPath;\n}\n\n/**\n * Function determining whether some paths in the tree were affected by some\n * updates that occurred at the given paths. This helper is mainly used at\n * cursor level to determine whether the cursor is concerned by the updates\n * fired at tree level.\n *\n * NOTES: 1) If performance become an issue, the following threefold loop\n *           can be simplified to a complex twofold one.\n *        2) A regex version could also work but I am not confident it would\n *           be faster.\n *        3) Another solution would be to keep a register of cursors like with\n *           the monkeys and update along this tree.\n *\n * @param  {array} affectedPaths - The paths that were updated.\n * @param  {array} comparedPaths - The paths that we are actually interested in.\n * @return {boolean}             - Is the update relevant to the compared\n *                                 paths?\n */\n\nfunction solveUpdate(affectedPaths, comparedPaths) {\n  var i = undefined,\n      j = undefined,\n      k = undefined,\n      l = undefined,\n      m = undefined,\n      n = undefined,\n      p = undefined,\n      c = undefined,\n      s = undefined;\n\n  // Looping through possible paths\n  for (i = 0, l = affectedPaths.length; i < l; i++) {\n    p = affectedPaths[i];\n\n    if (!p.length) return true;\n\n    // Looping through logged paths\n    for (j = 0, m = comparedPaths.length; j < m; j++) {\n      c = comparedPaths[j];\n\n      if (!c || !c.length) return true;\n\n      // Looping through steps\n      for (k = 0, n = c.length; k < n; k++) {\n        s = c[k];\n\n        // If path is not relevant, we break\n        // NOTE: the '!=' instead of '!==' is required here!\n        if (s != p[k]) break;\n\n        // If we reached last item and we are relevant\n        if (k + 1 === n || k + 1 === p.length) return true;\n      }\n    }\n  }\n\n  return false;\n}\n\n/**\n * Non-mutative version of the splice array method.\n *\n * @param  {array}    array        - The array to splice.\n * @param  {integer}  startIndex   - The start index.\n * @param  {integer}  nb           - Number of elements to remove.\n * @param  {...mixed} elements     - Elements to append after splicing.\n * @return {array}                 - The spliced array.\n */\n\nfunction splice(array, startIndex, nb) {\n  nb = Math.max(0, nb);\n\n  // Solving startIndex\n  if (_type2['default']['function'](startIndex)) startIndex = index(array, startIndex);\n  if (_type2['default'].object(startIndex)) startIndex = index(array, function (e) {\n    return compare(e, startIndex);\n  });\n\n  // Positive index\n\n  for (var _len2 = arguments.length, elements = Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {\n    elements[_key2 - 3] = arguments[_key2];\n  }\n\n  if (startIndex >= 0) return array.slice(0, startIndex).concat(elements).concat(array.slice(startIndex + nb));\n\n  // Negative index\n  return array.slice(0, array.length + startIndex).concat(elements).concat(array.slice(array.length + startIndex + nb));\n}\n\n/**\n * Function returning a unique incremental id each time it is called.\n *\n * @return {integer} - The latest unique id.\n */\nvar uniqid = (function () {\n  var i = 0;\n\n  return function () {\n    return i++;\n  };\n})();\n\nexports.uniqid = uniqid;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/baobab/dist/helpers.js\n ** module id = 31\n ** module chunks = 0\n **/","/**\n * Baobab Watchers\n * ================\n *\n * Abstraction used to listen and retrieve data from multiple parts of a\n * Baobab tree at once.\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nvar _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _emmett = require('emmett');\n\nvar _emmett2 = _interopRequireDefault(_emmett);\n\nvar _cursor = require('./cursor');\n\nvar _cursor2 = _interopRequireDefault(_cursor);\n\nvar _type = require('./type');\n\nvar _type2 = _interopRequireDefault(_type);\n\nvar _helpers = require('./helpers');\n\n/**\n * Watcher class.\n *\n * @constructor\n * @param {Baobab} tree     - The watched tree.\n * @param {object} mapping  - A mapping of the paths to watch in the tree.\n */\n\nvar Watcher = (function (_Emitter) {\n  _inherits(Watcher, _Emitter);\n\n  function Watcher(tree, mapping) {\n    var _this = this;\n\n    _classCallCheck(this, Watcher);\n\n    _get(Object.getPrototypeOf(Watcher.prototype), 'constructor', this).call(this);\n\n    // Properties\n    this.tree = tree;\n    this.mapping = null;\n\n    this.state = {\n      killed: false\n    };\n\n    // Initializing\n    this.refresh(mapping);\n\n    // Listening\n    this.handler = function (e) {\n      if (_this.state.killed) return;\n\n      var watchedPaths = _this.getWatchedPaths();\n\n      if ((0, _helpers.solveUpdate)(e.data.paths, watchedPaths)) return _this.emit('update');\n    };\n\n    this.tree.on('update', this.handler);\n  }\n\n  /**\n   * Method used to get the current watched paths.\n   *\n   * @return {array} - The array of watched paths.\n   */\n\n  _createClass(Watcher, [{\n    key: 'getWatchedPaths',\n    value: function getWatchedPaths() {\n      var _this2 = this;\n\n      var rawPaths = Object.keys(this.mapping).map(function (k) {\n        var v = _this2.mapping[k];\n\n        // Watcher mappings can accept a cursor\n        if (v instanceof _cursor2['default']) return v.solvedPath;\n\n        return _this2.mapping[k];\n      });\n\n      return rawPaths.reduce(function (cp, p) {\n\n        // Handling path polymorphisms\n        p = [].concat(p);\n\n        // Dynamic path?\n        if (_type2['default'].dynamicPath(p)) p = (0, _helpers.getIn)(_this2.tree._data, p).solvedPath;\n\n        if (!p) return cp;\n\n        // Facet path?\n        var monkeyPath = _type2['default'].monkeyPath(_this2.tree._monkeys, p);\n\n        if (monkeyPath) return cp.concat((0, _helpers.getIn)(_this2.tree._monkeys, monkeyPath).data.relatedPaths());\n\n        return cp.concat([p]);\n      }, []);\n    }\n\n    /**\n     * Method used to return a map of the watcher's cursors.\n     *\n     * @return {object} - TMap of relevant cursors.\n     */\n  }, {\n    key: 'getCursors',\n    value: function getCursors() {\n      var _this3 = this;\n\n      var cursors = {};\n\n      Object.keys(this.mapping).forEach(function (k) {\n        var path = _this3.mapping[k];\n\n        if (path instanceof _cursor2['default']) cursors[k] = path;else cursors[k] = _this3.tree.select(path);\n      });\n\n      return cursors;\n    }\n\n    /**\n     * Method used to refresh the watcher's mapping.\n     *\n     * @param  {object}  mapping  - The new mapping to apply.\n     * @return {Watcher}          - Itself for chaining purposes.\n     */\n  }, {\n    key: 'refresh',\n    value: function refresh(mapping) {\n\n      if (!_type2['default'].watcherMapping(mapping)) throw (0, _helpers.makeError)('Baobab.watch: invalid mapping.', { mapping: mapping });\n\n      this.mapping = mapping;\n\n      // Creating the get method\n      var projection = {};\n\n      for (var k in mapping) {\n        projection[k] = mapping[k] instanceof _cursor2['default'] ? mapping[k].path : mapping[k];\n      }this.get = this.tree.project.bind(this.tree, projection);\n    }\n\n    /**\n     * Methods releasing the watcher from memory.\n     */\n  }, {\n    key: 'release',\n    value: function release() {\n\n      this.tree.off('update', this.handler);\n      this.state.killed = true;\n      this.kill();\n    }\n  }]);\n\n  return Watcher;\n})(_emmett2['default']);\n\nexports['default'] = Watcher;\nmodule.exports = exports['default'];\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/baobab/dist/watcher.js\n ** module id = 32\n ** module chunks = 0\n **/","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!./../../node_modules/css-loader/index.js!./../../node_modules/sass-loader/index.js!./index.scss\");\nif(typeof content === 'string') content = [[module.id, content, '']];\n// add the styles to the DOM\nvar update = require(\"!./../../node_modules/style-loader/addStyles.js\")(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(module.hot) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!./../../node_modules/css-loader/index.js!./../../node_modules/sass-loader/index.js!./index.scss\", function() {\n\t\t\tvar newContent = require(\"!!./../../node_modules/css-loader/index.js!./../../node_modules/sass-loader/index.js!./index.scss\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/scss/index.scss\n ** module id = 33\n ** module chunks = 0\n **/","exports = module.exports = require(\"./../../node_modules/css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \"i.arrow.ne:before{transform:rotate(45deg)}i.arrow.e:before{transform:rotate(90deg)}i.arrow.se:before{transform:rotate(135deg)}i.arrow.s:before{transform:rotate(180deg)}i.arrow.sw:before{transform:rotate(225deg)}i.arrow.w:before{transform:rotate(270deg)}i.arrow.nw:before{transform:rotate(315deg)}@media (max-width:500px){#dashboard-page-container .scroll>div .col{max-width:50px}#dashboard-page-container .scroll>div .col.iconCol{max-width:25px;min-width:25px}}\", \"\"]);\n\n// exports\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/css-loader!./~/sass-loader!./app/scss/index.scss\n ** module id = 34\n ** module chunks = 0\n **/"],"sourceRoot":""}