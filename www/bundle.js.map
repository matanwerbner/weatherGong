{"version":3,"sources":["webpack:///bundle.js","webpack:///webpack/bootstrap 1fa6ef086c2ee59145ad","webpack:///./app/index.js","webpack:///./app/components/index.js","webpack:///./app/components/tabs/index.js","webpack:///./app/components/tabs/dashboard/index.js","webpack:///./app/components/tabs/dashboard/dashboard.route.js","webpack:///./app/components/tabs/dashboard/dashboard.controller.js","webpack:///./app/store/index.js","webpack:///./app/store/consts.js","webpack:///./app/store/monkeys/subscriptionData.js","webpack:///./app/store/monkeys/loaders/subscriptionData.js","webpack:///./app/api/mockApi.js","webpack:///./app/config.js","webpack:///./app/api/mocks/locationsData.js","webpack:///./app/api/mocks/locations.js","webpack:///./~/baobab/dist/baobab.js","webpack:///./~/emmett/emmett.js","webpack:///./~/baobab/dist/cursor.js","webpack:///./~/baobab/dist/monkey.js","webpack:///./~/baobab/dist/type.js","webpack:///./~/baobab/dist/update.js","webpack:///./~/baobab/dist/helpers.js","webpack:///./~/baobab/dist/watcher.js","webpack:///./app/storage/subscriptionIds.helper.js","webpack:///./app/components/tabs/dashboard/locationModal.html","webpack:///./app/components/tabs/dashboard/dashboard.html","webpack:///./app/components/tabs/dashboard/dashboard.scss?421f","webpack:///./app/components/tabs/dashboard/dashboard.scss","webpack:///./~/css-loader/lib/css-base.js","webpack:///./~/style-loader/addStyles.js","webpack:///./app/components/tabs/tabs.route.js","webpack:///./app/components/tabs/tabs.html","webpack:///./app/components/tabs/tabs.scss?ec1b","webpack:///./app/components/tabs/tabs.scss","webpack:///./app/scss/index.scss?3a4b","webpack:///./app/scss/index.scss"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","_components","_components2","angular","run","$ionicPlatform","ready","window","cordova","plugins","Keyboard","hideKeyboardAccessoryBar","disableScroll","StatusBar","styleDefault","config","$stateProvider","$urlRouterProvider","otherwise","Object","defineProperty","value","_tabs","_tabs2","name","_dashboard","_dashboard2","_dashboard3","_dashboard4","state","url","views","tab-dash","template","controller","_store","_store2","_subscriptionIds","locationModalTemplate","connectSubscriptions","data","scope","$timeout","currentData","forecastData","connectLocations","locations","$ionicModal","subscriptionSelector","select","locationSelector","get","on","e","getLocationsForModal","existingIds","getSubscriptionIdsFromStorage","filter","d","indexOf","modal","fromTemplate","animation","showAddLocation","show","closeModal","hide","removeLocation","idsSelector","existingIDs","set","l","removeFromSubscriptionIdsStorage","addLocation","location","push","addToSubscriptionIdsStorage","_consts","_subscriptionData","_subscriptionData2","_mockApi","Baobab","tree","subscriptions","ids","localStorage","getItem","JSON","parse","default_subscriptions","subscribedLocations","immutable","fetchLocations","then","result","monkey","cursors","map","loading","r","_index","_index2","length","dataSelector","fetchLocationsData","forEach","undefined","_config","locationsData","Promise","resolve","apiUrl","time","wind","windDirection","temp","wave","waveDirection","_interopRequireWildcard","newObj","key","prototype","hasOwnProperty","_classCallCheck","instance","Constructor","TypeError","_inherits","subClass","superClass","create","constructor","enumerable","writable","configurable","setPrototypeOf","__proto__","hashPath","path","step","_type2","object","uniqid","join","_createClass","defineProperties","target","props","i","descriptor","protoProps","staticProps","_get","_x3","_x4","_x5","_again","property","receiver","Function","desc","getOwnPropertyDescriptor","getter","parent","getPrototypeOf","_emmett","_emmett2","_cursor","_cursor2","_monkey","_watcher","_watcher2","_type","_update2","_update3","_helpers","helpers","arrayFrom","coercePath","deepFreeze","getIn","makeError","deepClone","deepMerge","shallowClone","shallowMerge","DEFAULTS","autoCommit","asynchronous","lazyMonkeys","persistent","pure","validate","validationBehavior","_Emitter","initialData","opts","_this","this","arguments","array","options","_identity","_cursors","_future","_transaction","_affectedPathsIndex","_monkeys","_previousData","_data","root","release","bootstrap","apply","_refreshMonkeys","validationError","Error","error","node","operation","_this2","clean","Monkey","type","k","concat","walk","MonkeyDefinition","monkeyInstance","definition","monkeysNode","affectedPaths","_options","behavior","emit","hash","cursor","_this3","operationType","_getIn","solvedPath","exists","monkeyPath","realOperation","test","currentNode","affectedPath","setTimeout","commit","clearTimeout","keys","h","split","slice","transaction","previousData","paths","mapping","kill","serialize","_len","args","Array","_key","dynamicNode","Cursor","VERSION","o1","o2","o","isPlainObject","v","isArray","RegExp","forIn","fn","symbols","getOwnPropertySymbols","a","__allowedOptions","once","__order","Emitter","_enabled","unbindAll","_handlers","_handlersAll","_handlersComplex","b","event","eArray","handlersList","bindingObject","order","pattern","li","off","events","n","listeners","handlers","complex","search","sort","handler","j","onces","splice","disable","enable","version","checkPossibilityOfDynamicTraversal","method","makeSetter","typeChecker","INTRANSITIVE_SETTERS","fullPath","update","_archive","killed","recording","undoing","_dynamicPath","dynamicPath","_monkeyPath","_writeHandler","_ref","solveUpdate","_getComparedPaths","fireUpdate","self","eventData","archive","add","_updateHandler","_event$data","bind","comparedPaths","bound","_lazyBind","before","additionalPaths","relatedPaths","primitive","isRoot","isLeaf","last","isNaN","up","list","item","_get2","monkeys","dropComputedData","projection","maxRecords","Infinity","Archive","steps","record","back","clear","Symbol","iterator","next","done","unset","pop","shift","splicer","monkeyType","monkeyDefinition","offset","hasDynamicPaths","some","pathInTree","relative","solveRelativePath","reduce","acc","depPaths","writeListener","concerned","recursiveListener","_ref2","_ref2$data","recursive","isRecursive","accumulatedPaths","relatedMonkey","deps","project","lazyGetter","def","cache","alreadyComputed","isLazyGetter","mutableLeaf","monkeyListener","anyOf","allowed","t","Date","Map","Set","string","number","ALLOWED_FOR_PATH","every","subpath","propertyKey","watcherMapping","VALID_OPERATIONS","_toConsumableArray","arr","arr2","from","err","expectedTarget","_operation$options","operationOptions","dummy","dummyPath","currentPath","s","unshift","freeze","global","index","newArray","culprit","decorator","cloneRegexp","re","source","flags","multiline","ignoreCase","sticky","unicode","cloner","deep","ArrayBuffer","getTime","compare","description","ok","freezer","isFrozen","NOT_FOUND_OBJECT","idx","message","merger","objects","base","to","startIndex","nb","Math","max","_len2","elements","_key2","noop","size","records","isFreezeSupported","_x","_x2","Watcher","refresh","watchedPaths","getWatchedPaths","rawPaths","cp","existingSubscriptionIds","setItem","stringify","content","locals","toString","mediaQuery","alreadyImportedModules","addStylesToDom","styles","domStyle","stylesInDom","refs","parts","addStyle","listToStyles","newStyles","css","media","sourceMap","part","insertStyleElement","styleElement","head","getHeadElement","lastStyleElementInsertedAtTop","styleElementsInsertedAtTop","insertAt","nextSibling","insertBefore","appendChild","firstChild","removeStyleElement","parentNode","removeChild","createStyleElement","document","createElement","createLinkElement","linkElement","rel","remove","singleton","styleIndex","singletonCounter","singletonElement","applyToSingletonTag","URL","createObjectURL","revokeObjectURL","Blob","btoa","updateLink","href","applyToTag","styleSheet","cssText","replaceText","cssNode","createTextNode","childNodes","setAttribute","unescape","encodeURIComponent","blob","oldSrc","memoize","memo","isOldIE","navigator","userAgent","toLowerCase","getElementsByTagName","newList","mayRemove","textStore","replacement","Boolean","abstract"],"mappings":"CAAS,SAAUA,SCInB,QAAAC,qBAAAC,UAGA,GAAAC,iBAAAD,UACA,MAAAC,kBAAAD,UAAAE,OAGA,IAAAC,QAAAF,iBAAAD,WACAE,WACAE,GAAAJ,SACAK,QAAA,EAUA,OANAP,SAAAE,UAAAM,KAAAH,OAAAD,QAAAC,cAAAD,QAAAH,qBAGAI,OAAAE,QAAA,EAGAF,OAAAD,QAvBA,GAAAD,oBAqCA,OATAF,qBAAAQ,EAAAT,QAGAC,oBAAAS,EAAAP,iBAGAF,oBAAAU,EAAA,GAGAV,oBAAA,KDMM,SAASI,OAAQD,QAASH,qBAE/B,YAQA,SAASW,wBAAuBC,KAAO,MAAOA,MAAOA,IAAIC,WAAaD,KAAQE,UAASF,KEtDxF,GAAAG,aAAAf,oBAAA,GFkDKgB,aAAeL,uBAAuBI,YEjD3Cf,qBAAA,IACAiB,QAAQb,OAAO,OAAQ,QAADY,0BACrBE,IAAI,SAASC,gBACVA,eAAeC,MAAM,WAGbC,OAAOC,SAAWD,OAAOC,QAAQC,SAAWF,OAAOC,QAAQC,QAAQC,WACnEF,QAAQC,QAAQC,SAASC,0BAAyB,GAClDH,QAAQC,QAAQC,SAASE,eAAc,IAGvCL,OAAOM,WAEPA,UAAUC,mBAGnBC,OAAO,SAASC,eAAgBC,oBAC/BA,mBAAmBC,UAAU,gBFyD3B,SAAS5B,OAAQD,QAASH,qBAE/B,YAUA,SAASW,wBAAuBC,KAAO,MAAOA,MAAOA,IAAIC,WAAaD,KAAQE,UAASF,KARvFqB,OAAOC,eAAe/B,QAAS,cAC7BgC,OAAO,GGhFV,IAAAC,OAAApC,oBAAA,GHqFKqC,OAAS1B,uBAAuByB,MAIpCjC,oBGvFcc,QAAQb,OAAO,kBAAkBiC,oBAC7CC,MH0FG,SAASlC,OAAQD,QAASH,qBAE/B,YAgBA,SAASW,wBAAuBC,KAAO,MAAOA,MAAOA,IAAIC,WAAaD,KAAQE,UAASF,KAdvFqB,OAAOC,eAAe/B,QAAS,cAC7BgC,OAAO,GIlGV,IAAAI,YAAAvC,oBAAA,GJuGKwC,YAAc7B,uBAAuB4B,YItG1CH,MAAApC,oBAAA,IJ0GKqC,OAAS1B,uBAAuByB,MIzGrCpC,qBAAA,IJ+GCG,mBI9Gcc,QAAQb,OAAO,uBAAuBoC,yBAClDX,OADYQ,mBAEZC,MJgHG,SAASlC,OAAQD,QAASH,qBAE/B,YAYA,SAASW,wBAAuBC,KAAO,MAAOA,MAAOA,IAAIC,WAAaD,KAAQE,UAASF,KAVvFqB,OAAOC,eAAe/B,QAAS,cAC7BgC,OAAO,GK1HV,IAAAI,YAAAvC,oBAAA,GL+HKwC,YAAc7B,uBAAuB4B,WK9H1CvC,qBAAA,ILoICG,mBKlIcc,QAAQb,OAAO,oCAC3ByB,OADYW,wBAEZF,MLoIG,SAASlC,OAAQD,QAASH,qBAE/B,YAcA,SAASW,wBAAuBC,KAAO,MAAOA,MAAOA,IAAIC,WAAaD,KAAQE,UAASF,KAZvFqB,OAAOC,eAAe/B,QAAS,cAC3BgC,OAAO,GM9IZ,IAAAI,YAAAvC,oBAAA,GNmJKwC,YAAc7B,uBAAuB4B,YMlJ1CE,YAAAzC,oBAAA,INsJK0C,YAAc/B,uBAAuB8B,YAIzCtC,oBMxJc,SAAC2B,eAAgBC,oBAC5BD,eACKa,MAAM,YACHC,IAAK,QACLC,OACIC,YACIC,SAAAL,uBACAM,WAAAR,6BN+Jd,SAASpC,OAAQD,QAASH,qBAE/B,YAYA,SAASW,wBAAuBC,KAAO,MAAOA,MAAOA,IAAIC,WAAaD,KAAQE,UAASF,KAVvFqB,OAAOC,eAAe/B,QAAS,cAC3BgC,OAAO,GO9KZ,IAAAc,QAAAjD,oBAAA,GPmLKkD,QAAUvC,uBAAuBsC,QOlLtCE,iBAAAnD,oBAAA,IAKIoD,sBAAwBpD,oBAAQ,IAE9BqD,qBAAuB,SAACC,KAAMC,MAAOC,UACvCA,SAAS,WACLD,MAAME,YAAcF,MAAMG,aAAeJ,QAI3CK,iBAAmB,SAACL,KAAMC,MAAOC,UACnCA,SAAS,WACLD,MAAMK,UAAYN,OPuLzBnD,qBOnLe,SAAU,WAAY,cAClC,SAACoD,MAAOC,SAAUK,aACd,GAAMC,sBAAuBZ,mBAAKa,OAAO,gBAAiB,uBACpDC,iBAAmBd,mBAAKa,OAAO,YACrCV,sBAAqBS,qBAAqBG,MAAOV,MAAOC,UACxDM,qBAAqBI,GAAG,SAAU,SAAUC,GACxCd,qBAAqBc,EAAEb,KAAKG,YAAaF,MAAOC,YAGpDQ,iBAAiBE,GAAG,SAAU,SAACC,GAC3BR,iBAAiBQ,EAAEb,KAAKG,YAAaF,MAAOC,YAGhDD,MAAMa,qBAAuB,WACzB,IAAIb,MAAMK,UAAW,QACrB,IAAMS,cAAc,EAAAlB,iBAAAmB,gCACpB,OAAOf,OAAMK,UAAUW,OAAO,SAACC,GAAD,MAAOH,aAAYI,QAAQD,EAAEnE,WAG/DkD,MAAMmB,MAAQb,YAAYc,aAAavB,uBACnCG,YACAqB,UAAW,SAGfrB,MAAMsB,gBAAkB,WACpBtB,MAAMmB,MAAMI,QAGhBvB,MAAMwB,WAAa,WACfxB,MAAMmB,MAAMM,QAGhBzB,MAAM0B,eAAiB,SAAC5E,IACpB,GAAM6E,aAAchC,mBAAKa,QAAQ,gBAAiB,QAC5CoB,YAAcD,YAAYjB,KAChCiB,aAAYE,IAAID,YAAYZ,OAAO,SAACc,GAAD,MAAOA,IAAKhF,OAC/C,EAAA8C,iBAAAmC,kCAAiCjF,KAGrCkD,MAAMgC,YAAc,SAACC,UACjBtC,mBAAKuC,MAAM,gBAAiB,OAAQD,SAASnF,KAC7C,EAAA8C,iBAAAuC,6BAA4BF,SAASnF,IACrCkD,MAAMmB,MAAMM,WP4LlB,SAAS5E,OAAQD,QAASH,qBAE/B,YAcA,SAASW,wBAAuBC,KAAO,MAAOA,MAAOA,IAAIC,WAAaD,KAAQE,UAASF,KAZvFqB,OAAOC,eAAe/B,QAAS,cAC3BgC,OAAO,GQ/PZ,IAAAwD,SAAA3F,oBAAA,GACA4F,kBAAA5F,oBAAA,GRqQK6F,mBAAqBlF,uBAAuBiF,mBQpQjDE,SAAA9F,oBAAA,IACI+F,OAAS/F,oBAAQ,IAEfgG,KAAO,GAAID,SACbnC,aAGAqC,eACIC,IAAK7E,OAAO8E,aAAaC,QAAQ,mBAC1BC,KAAKC,MAAMjF,OAAO8E,aAAaC,QAAQ,oBADzCT,QAAAY,sBAGLjD,QACAkD,oBAAAX,iCAGAY,WAAW,GRuQlBtG,oBQrQc6F,MAEf,EAAAF,SAAAY,kBAAiBC,KAAK,SAACC,QACnBZ,KAAKZ,IAAI,YAAawB,WR2QpB,SAASxG,OAAQD,SAEtB,YAEA8B,QAAOC,eAAe/B,QAAS,cAC7BgC,OAAO,GStSGhC,SAAAoG,0BT4SP,SAASnG,OAAQD,QAASH,qBAE/B,YAUA,SAASW,wBAAuBC,KAAO,MAAOA,MAAOA,IAAIC,WAAaD,KAAQE,UAASF,KARvFqB,OAAOC,eAAe/B,QAAS,cAC3BgC,OAAO,GU9SZ,IAAAyD,mBAAA5F,oBAAA,GVmTK6F,mBAAqBlF,uBAAuBiF,mBUrT7CG,OAAS/F,oBAAQ,IACjB6G,OAASd,OAAOc,MV0TnB1G,oBUxTc0G,QACXC,SACIZ,KAAM,gBAAiB,OACvB5C,MAAO,gBAAiB,SAE5BW,IAAK,SAAUtB,OACX,GAAMiE,QAASjE,MAAMuD,IAAIa,IAAI,SAAC1G,IAC1B,GAAIiD,MAAOX,MAAMW,KAAKjD,GACtB,OAAOiD,QAAUjD,MAAI2G,SAAS,IAGlC,QADA,EAAAnB,+BAAkBe,OAAOrC,OAAO,SAAC0C,GAAD,MAAOA,GAAED,WAClCJ,WVgUT,SAASxG,OAAQD,QAASH,qBAE/B,YAYA,SAASW,wBAAuBC,KAAO,MAAOA,MAAOA,IAAIC,WAAaD,KAAQE,UAASF,KAVvFqB,OAAOC,eAAe/B,QAAS,cAC3BgC,OAAO,GWpVZ,IAAA+E,QAAAlH,oBAAA,GXyVKmH,QAAUxG,uBAAuBuG,QWxVtCpB,SAAA9F,oBAAA,GX8VCG,oBW7Vc,SAAC+F,KACZ,GAAkB,GAAdA,IAAIkB,OACJ,MAAO,KACX,IAAIC,cAAeF,mBAAKpD,OAAO,gBAAiB,SAChD,EAAA+B,SAAAwB,oBAAmBpB,KAClBS,KAAK,SAACrD,MACCA,KAAKiE,QAAQ,SAAC/C,GACV6C,aAAajC,IAAIZ,EAAEnE,GAAImE,SXkWjC,SAASpE,OAAQD,QAASH,qBAE/B,YAWA,SAASW,wBAAuBC,KAAO,MAAOA,MAAOA,IAAIC,WAAaD,KAAQE,UAASF,KATvFqB,OAAOC,eAAe/B,QAAS,cAC3BgC,OAAO,IAEXhC,QAAQuG,eAAiBvG,QAAQmH,mBAAqBE,MYlXvD,IAAAC,SAAAzH,oBAAA,IACM0H,eZqXU/G,uBAAuB8G,SYrXjBzH,oBAAQ,KACxB4D,UAAY5D,oBAAQ,GACbG,SAAAmH,mBAAqB,SAACpB,KAC/B,MAAO,IAAIyB,SAAQ,SAACC,SAChBA,QAAQF,kBAIHvH,QAAAuG,eAAiB,WAC1B,MAAO,IAAIiB,SAAQ,SAACC,SAChBA,QAAQhE,eZ+XV,SAASxD,OAAQD,SAEtB,YAEA8B,QAAOC,eAAe/B,QAAS,cAC3BgC,OAAO,IAEXhC,oBahZG0H,OAAQ,2BbsZN,SAASzH,OAAQD,SAEtB,YczZDC,QAAOD,UAECE,GAAM,EACNmF,SAAY,WACZsC,KAAQ,QACRC,KAAQ,QACRC,cAAiB,IACjBC,KAAQ,MACRC,KAAQ,SACRC,cAAiB,MAGjB9H,GAAM,EACNmF,SAAY,QACZsC,KAAQ,QACRC,KAAQ,QACRC,cAAiB,IACjBC,KAAQ,MACRC,KAAQ,SACRC,cAAiB,MAGjB9H,GAAM,EACNmF,SAAY,UACZsC,KAAQ,QACRC,KAAQ,QACRC,cAAiB,IACjBC,KAAQ,MACRC,KAAQ,aACRC,cAAiB,MAGjB9H,GAAM,EACNmF,SAAY,UACZsC,KAAQ,QACRC,KAAQ,QACRC,cAAiB,IACjBC,KAAQ,MACRC,KAAQ,aACRC,cAAiB,Od4ZnB,SAAS/H,OAAQD,SAEtB,YercDC,QAAOD,UAAYE,GAAK,EAAEiC,KAAO,aAAajC,GAAM,EAAGiC,KAAO,UAAUjC,GAAM,EAAGiC,KAAO,YAAYjC,GAAM,EAAGiC,KAAQ,af2c/G,SAASlC,OAAQD,QAASH,qBgBrchC,YAUA,SAAAoI,yBAAAxH,KAAuC,GAAAA,SAAAC,WAA6B,MAAAD,IAAqB,IAAAyH,UAAiB,UAAAzH,IAAmB,OAAA0H,OAAA1H,KAAuBqB,OAAAsG,UAAAC,eAAAjI,KAAAK,IAAA0H,OAAAD,OAAAC,KAAA1H,IAAA0H,KAAyG,OAAzBD,QAAA,WAAAzH,IAAyByH,OAE7P,QAAA1H,wBAAAC,KAAsC,MAAAA,UAAAC,WAAAD,KAAuCE,UAAAF,KAE7E,QAAA6H,iBAAAC,SAAAC,aAAiD,KAAAD,mBAAAC,cAA0C,SAAAC,WAAA,qCAE3F,QAAAC,WAAAC,SAAAC,YAA0C,qBAAAA,aAAA,OAAAA,WAA+D,SAAAH,WAAA,iEAAAG,YAAuGD,UAAAP,UAAAtG,OAAA+G,OAAAD,uBAAAR,WAAyEU,aAAe9G,MAAA2G,SAAAI,YAAA,EAAAC,UAAA,EAAAC,cAAA,KAA6EL,aAAA9G,OAAAoH,eAAApH,OAAAoH,eAAAP,SAAAC,YAAAD,SAAAQ,UAAAP,YA4ErX,QAAAQ,UAAAC,MACA,UAAAA,KAAAzC,IAAA,SAAA0C,MACA,MAAAC,QAAA,uBAAAD,OAAAC,OAAA,WAAAC,OAAAF,MAAA,IAAAG,SAAA,IAEAH,OACGI,KAAA,KA/FH5H,OAAAC,eAAA/B,QAAA,cACAgC,OAAA,GAGA,IAAA2H,cAAA,WAAiC,QAAAC,kBAAAC,OAAAC,OAA2C,OAAAC,GAAA,EAAgBA,EAAAD,MAAA7C,OAAkB8C,IAAA,CAAO,GAAAC,YAAAF,MAAAC,EAA2BC,YAAAjB,WAAAiB,WAAAjB,aAAA,EAAwDiB,WAAAf,cAAA,EAAgC,SAAAe,yBAAAhB,UAAA,GAAuDlH,OAAAC,eAAA8H,OAAAG,WAAA7B,IAAA6B,aAA+D,gBAAAxB,YAAAyB,WAAAC,aAA2L,MAAlID,aAAAL,iBAAApB,YAAAJ,UAAA6B,YAAqEC,aAAAN,iBAAApB,YAAA0B,aAA6D1B,gBAEzhB2B,KAAA,SAAAC,IAAAC,IAAAC,KAA2D,IAAnB,GAAAC,SAAA,EAAmBA,QAAA,CAA4B,GAAAf,QAAAY,IAAAI,SAAAH,IAAAI,SAAAH,GAAkDC,SAAA,EAAgB,OAAAf,gBAAAkB,SAAAtC,UAAkD,IAAAuC,MAAA7I,OAAA8I,yBAAApB,OAAAgB,SAA8D,IAAAnD,SAAAsD,KAAA,CAAwO,YAAAA,MAA4B,MAAAA,MAAA3I,KAA4B,IAAA6I,QAAAF,KAAA7G,GAAuB,IAAAuD,SAAAwD,OAA4B,MAAoB,OAAAA,QAAAzK,KAAAqK,UAA7U,GAAAK,QAAAhJ,OAAAiJ,eAAAvB,OAA4C,WAAAsB,OAAuB,MAA2BV,KAAAU,OAAcT,IAAAG,SAAgBF,IAAAG,SAAgBF,QAAA,EAAeI,KAAAG,OAAAzD,SAU9b2D,QAAAnL,oBAAA,IAEAoL,SAAAzK,uBAAAwK,SAEAE,QAAArL,oBAAA,IAEAsL,SAAA3K,uBAAA0K,SAEAE,QAAAvL,oBAAA,IAEAwL,SAAAxL,oBAAA,IAEAyL,UAAA9K,uBAAA6K,UAEAE,MAAA1L,oBAAA,IAEA0J,OAAA/I,uBAAA+K,OAEAC,SAAA3L,oBAAA,IAEA4L,SAAAjL,uBAAAgL,UAEAE,SAAA7L,oBAAA,IAEA8L,QAAA1D,wBAAAyD,UAEAE,UAAAD,QAAAC,UACAC,WAAAF,QAAAE,WACAC,WAAAH,QAAAG,WACAC,MAAAJ,QAAAI,MACAC,UAAAL,QAAAK,UACAC,UAAAN,QAAAM,UACAC,UAAAP,QAAAO,UACAC,aAAAR,QAAAQ,aACAC,aAAAT,QAAAS,aACA3C,OAAAkC,QAAAlC,OAKA4C,UAGAC,YAAA,EAGAC,cAAA,EAGAjG,WAAA,EAGAkG,aAAA,EAGAC,YAAA,EAGAC,MAAA,EAGAC,SAAA,KAGAC,mBAAA,YAkCAhH,OAAA,SAAAiH,UAGA,QAAAjH,QAAAkH,YAAAC,MACA,GAAAC,OAAAC,IAUA,IARA3E,gBAAA2E,KAAArH,QAEAuE,KAAArI,OAAAiJ,eAAAnF,OAAAwC,WAAA,cAAA6E,MAAA7M,KAAA6M,MAGAC,UAAAjG,OAAA,IAAA6F,iBAGAvD,OAAA,WAAAC,OAAAsD,eAAAvD,OAAA,WAAA4D,MAAAL,aAAA,KAAAd,WAAA,yBAAmI7I,KAAA2J,aAGnIG,MAAAG,QAAAhB,gBAAkCC,SAAAU,MAGlCE,KAAAG,QAAAX,aACAQ,KAAAG,QAAA9G,WAAA,EACA2G,KAAAG,QAAAV,MAAA,GAIAO,KAAAI,UAAA,kBACAJ,KAAAK,YACAL,KAAAM,QAAA,KACAN,KAAAO,gBACAP,KAAAQ,uBACAR,KAAAS,YACAT,KAAAU,cAAA,KACAV,KAAAW,MAAAd,YAGAG,KAAAY,KAAA,GAAA1C,UAAA,WAAA8B,QAAA,WACAA,MAAAY,KAAAC,QAGAb,KAAAG,QAAA9G,WAAAwF,WAAAmB,KAAAW,MAGA,IAAAG,WAAA,SAAA5L,MACA6K,MAAA7K,MAAA,WACA,GAAA2E,GAAAmG,KAAAY,KAAA1L,MAAA6L,MAAAf,KAAAY,KAAAX,UACA,OAAApG,aAAAqE,UAAA,WAAA8B,KAAAnG,KAIA,qJAAAM,QAAA2G,WAGAd,KAAAgB,iBAGA,IAAAC,iBAAAjB,KAAAN,UAEA,IAAAuB,gBAAA,KAAAC,OAAA,yBAA+DC,MAAAF,kBAyY/D,MAlcAxF,WAAA9C,OAAAiH,UA4EAlD,aAAA/D,SACAuC,IAAA,kBACAnG,MAAA,SAAAqM,KAAAhF,KAAAiF,WACA,GAAAC,QAAAtB,KAEAuB,MAAA,QAAAA,OAAArL,MACA,GAAA5C,GAAA2M,UAAAjG,QAAA,GAAAI,SAAA6F,UAAA,MAAAA,UAAA,EAEA,IAAA/J,eAAAiI,SAAAqD,OAQA,MAPAtL,MAAA2K,eACA,EAAArC,SAAA,YAAA8C,OAAAb,SAAAnN,GAAwDmO,KAAA,UACxDpI,WAAA,EACAmG,YAAA,EACAC,MAAA,GAMA,IAAAnD,OAAA,WAAAC,OAAArG,MACA,OAAAwL,KAAAxL,MACAqL,MAAArL,KAAAwL,GAAApO,EAAAqO,OAAAD,KAKAE,KAAA,QAAAA,MAAA1L,MACA,GAAA5C,GAAA2M,UAAAjG,QAAA,GAAAI,SAAA6F,UAAA,MAAAA,UAAA,EAGA,IAAA/J,eAAAiI,SAAA0D,kBAAA3L,eAAAiI,SAAAqD,OAAA,CACA,GAAAM,gBAAA,GAAA3D,SAAAqD,OAAAF,OAAAhO,EAAA4C,eAAAiI,SAAAqD,OAAAtL,KAAA6L,WAAA7L,KAQA,aANA,EAAAsI,SAAA,YAAA8C,OAAAb,SAAAnN,GAAwDmO,KAAA,MAAA1M,MAAA+M,iBACxDzI,WAAA,EACAmG,YAAA,EACAC,MAAA,IAOA,GAAAnD,OAAA,WAAAC,OAAArG,MACA,OAAAwL,KAAAxL,MACA0L,KAAA1L,KAAAwL,GAAApO,EAAAqO,OAAAD,IAMA,IAAAzB,UAAAjG,OAEO,CACP,GAAAgI,aAAAlD,MAAAkB,KAAAS,SAAArE,MAAAlG,IAGA8L,cAAAT,MAAAS,YAAA5F,MAGA,UAAAiF,WACAO,KAAAR,KAAAhF,UATAwF,MAAA5B,KAAAW,MAaA,OAAAX,SASA9E,IAAA,WACAnG,MAAA,QAAA2K,UAAAuC,eACA,GAAAC,UAAAlC,KAAAG,QACAT,SAAAwC,SAAAxC,SACAyC,SAAAD,SAAAvC,kBAEA,sBAAAD,UAAA,WAEA,IAAAyB,OAAAzB,SAAAvM,KAAA6M,UAAAU,cAAAV,KAAAW,MAAAsB,oBAEA,OAAAd,iBAAAD,QAEA,aAAAiB,WACAnC,KAAAW,MAAAX,KAAAU,cACAV,KAAAQ,uBACAR,KAAAO,gBACAP,KAAAU,cAAAV,KAAAW,OAGAX,KAAAoC,KAAA,WAA8BjB,cAE9BA,OAGA,QAgBAjG,IAAA,SACAnG,MAAA,SAAAqH,MASA,GANAA,cAGA6D,UAAAjG,OAAA,IAAAoC,KAAAuC,UAAAsB,aAGA3D,OAAA,WAAAF,WAAA,KAAA2C,WAAA,gCAA0F3C,WAG1FA,SAAAuF,OAAAvF,KAIA,IAAAiG,MAAAlG,SAAAC,MAIAkG,OAAAtC,KAAAK,SAAAgC,KASA,OAPAC,UACAA,OAAA,GAAApE,UAAA,WAAA8B,KAAA5D,KAAAiG,MACArC,KAAAK,SAAAgC,MAAAC,QAIAtC,KAAAoC,KAAA,UAA2BhG,UAAAkG,gBAC3BA,UAcApH,IAAA,SACAnG,MAAA,SAAAqH,KAAAiF,WACA,GAAAkB,QAAAvC,IAKA,IAFA5D,KAAAwC,WAAAxC,OAEAE,OAAA,WAAAkG,cAAAnB,UAAAI,MAAA,KAAA1C,WAAA,0CAAAsC,UAAAI,KAAA,MAAgJJ,qBAIhJ,IAAAoB,QAAA3D,MAAAkB,KAAAW,MAAAvE,MAEAsG,WAAAD,OAAAC,WACAC,OAAAF,OAAAE,MAGA,KAAAD,WAAA,KAAA3D,WAAA,kDACA3C,KAAAsG,YAIA,IAAAE,YAAAtG,OAAA,WAAAsG,WAAA5C,KAAAS,SAAAiC,WACA,IAAAE,YAAAF,WAAA1I,OAAA4I,WAAA5I,OAAA,KAAA+E,WAAA,yDACA3C,KAAAsG,YAIA,cAAArB,UAAAI,MAAAkB,OAAA,CAGA,GAAAE,eAAAxB,SACA,aAAAyB,KAAAzB,UAAAI,MAAA,CACA,GAAAO,aAAAlD,MAAAkB,KAAAS,SAAAiC,YAAAxM,IAEA,IAAAoG,OAAA,WAAAC,OAAAyF,aAAA,CAGAa,cAAA3D,aAAA2D,cAGA,IAAAE,aAAAjE,MAAAkB,KAAAW,MAAA+B,YAAAxM,IAEA,SAAA4M,KAAAD,cAAApB,MAAAoB,cAAA9N,MAAAkK,aAAkFA,aAAc8D,YAAA/D,UAAAgD,cAAAa,cAAA9N,OAA6D8N,cAAA9N,MAAAoK,gBAA0CF,aAAc8D,YAAA/D,UAAAgD,cAAAa,cAAA9N,QAKrNiL,KAAAO,aAAAvG,SAAAgG,KAAAU,cAAAV,KAAAW,MAGA,IAAAnH,SAAA,EAAAgF,SAAA,YAAAwB,KAAAW,MAAA+B,WAAAG,cAAA7C,KAAAG,SAEAjK,KAAAsD,OAAAtD,KACAkL,KAAA5H,OAAA4H,IAGA,cAAA5H,SAAA,MAAA4H,KAGA,IAAA4B,cAAAN,WAAAf,OAAA,SAAAN,UAAAI,KAAAL,KAAApH,OAAA,MAEAqI,KAAAlG,SAAA6G,aAcA,OAXAhD,MAAAW,MAAAzK,KACA8J,KAAAQ,oBAAA6B,OAAA,EACArC,KAAAO,aAAAlI,KAAA8G,gBAA4CkC,WAAcjF,KAAA4G,gBAG1DhD,KAAAgB,gBAAAI,KAAAsB,WAAArB,UAAAI,MAGAzB,KAAAoC,KAAA,SAA0BhG,KAAA4G,eAG1BhD,KAAAG,QAAAd,WAGAW,KAAAG,QAAAb,cAMAU,KAAAM,UAAAN,KAAAM,QAAA2C,WAAA,WACA,MAAAV,QAAAW,UACO,IAGP9B,OAVApB,KAAAkD,SACA9B,MALAA,SAuBAlG,IAAA,SACAnG,MAAA,WAGA,IAAAiL,KAAAO,aAAAvG,OAAA,MAAAgG,KAGAA,MAAAM,UAAAN,KAAAM,QAAA6C,aAAAnD,KAAAM,SAEA,IAAA2B,eAAApN,OAAAuO,KAAApD,KAAAQ,qBAAA7G,IAAA,SAAA0J,GACA,YAAAA,IAAAC,MAAA,KAAAC,MAAA,QAIAtC,gBAAAjB,KAAAN,SAAAuC,cAEA,IAAAhB,gBAAA,MAAAjB,KAGA,IAAAwD,aAAAxD,KAAAO,aACAkD,aAAAzD,KAAAU,aAcA,OAZAV,MAAAQ,uBACAR,KAAAO,gBACAP,KAAAU,cAAAV,KAAAW,MAGAX,KAAAoC,KAAA,UACAsB,MAAAzB,cACA5L,YAAA2J,KAAAW,MACA6C,wBACAC,4BAGAzD,QAUA9E,IAAA,YACAnG,MAAA,SAAAqH,MACAA,KAAAwC,WAAAxC,KAEA,IAAA3C,QAAAqF,MAAAkB,KAAAS,YAAAkB,OAAAvF,OAAAlG,IAEA,OAAAuD,kBAAA0E,SAAAqD,OAAA/H,OAEA,QAWAyB,IAAA,QACAnG,MAAA,SAAA4O,SACA,UAAAtF,WAAA,WAAA2B,KAAA2D,YAOAzI,IAAA,UACAnG,MAAA,WACA,GAAA2M,GAAAtH,MAEA4F,MAAAoC,KAAA,iBAEApC,MAAAY,WAEAZ,MAAAW,YACAX,MAAAU,oBACAV,MAAAO,mBACAP,MAAAQ,0BACAR,MAAAS,QAGA,KAAAiB,IAAA1B,MAAAK,SAAAL,KAAAK,SAAAqB,GAAAb,gBACAb,MAAAK,SAGAL,KAAA4D,UASA1I,IAAA,SACAnG,MAAA,WACA,MAAAiL,MAAA6D,eASA3I,IAAA,WACAnG,MAAA,WACA,MAAAiL,MAAAI,cAIAzH,QACCqF,SAAA,WAEDjL,SAAA,WAAA4F,OACAA,OAAAc,OAAA,WACA,OAAAqK,MAAA7D,UAAAjG,OAAA+J,KAAAC,MAAAF,MAAAG,KAAA,EAAiEA,KAAAH,KAAaG,OAC9EF,KAAAE,MAAAhE,UAAAgE,KAGA,KAAAF,KAAA/J,OAAA,SAAAkH,OAAA,qCAEA,YAAA6C,KAAA/J,QAAA,kBAAA+J,MAAA,MAAA5F,SAAA0D,iBAAAkC,KAAA,IAEA,GAAA5F,SAAA0D,iBAAAkC,OAEApL,OAAAuL,YAAAvL,OAAAc,OAKAd,OAAAwL,OAAAjG,SAAA,WACAvF,OAAAkJ,iBAAA1D,QAAA0D,iBACAlJ,OAAA6I,OAAArD,QAAAqD,OACA7I,OAAA8I,KAAAnF,OAAA,WACA3D,OAAA+F,gBAKA/F,OAAAyL,QAAA,QACApR,OAAAD,gBAAA,YhBidM,SAASC,OAAQD,QAASH,sBiB5iChC,WACA,YAwBA,SAAAuM,cAAAkF,GAAAC,IACA,GACA5C,GADA6C,IAGA,KAAA7C,IAAA2C,IAAAE,EAAA7C,GAAA2C,GAAA3C,EACA,KAAAA,IAAA4C,IAAAC,EAAA7C,GAAA4C,GAAA5C,EAEA,OAAA6C,GASA,QAAAC,eAAAC,GACA,MAAAA,IACA,gBAAAA,KACAT,MAAAU,QAAAD,MACAA,YAAAhH,cACAgH,YAAAE,SAUA,QAAAC,OAAArI,OAAAsI,GAAA1O,OACA,GAAA2O,SACApD,EACA5E,EACA7E,CAEA,KAAAyJ,IAAAnF,QACAsI,GAAA1R,KAAAgD,OAAA,KAAAuL,EAAAnF,OAAAmF,GAEA,IAAA7M,OAAAkQ,sBAGA,IAFAD,QAAAjQ,OAAAkQ,sBAAAxI,QAEAO,EAAA,EAAA7E,EAAA6M,QAAA9K,OAAqC8C,EAAA7E,EAAO6E,IAC5C+H,GAAA1R,KAAAgD,OAAA,KAAA2O,QAAAhI,GAAAP,OAAAuI,QAAAhI,KAkPA,QAAA3F,QAAAyF,OAAAiI,IACAjI,iBAEA,IACA3E,GACA6E,EAFAkI,IAIA,KAAAlI,EAAA,EAAA7E,EAAA2E,OAAA5C,OAAkC8C,EAAA7E,EAAO6E,IACzCF,OAAAE,GAAA+H,SACAG,EAAA3M,KAAAuE,OAAAE,GAEA,OAAAkI,GA3TA,GAAAC,mBACAC,KAAA,UACA/O,MAAA,UAMAgP,QAAA,EAmEAC,QAAA,WACApF,KAAAqF,UAAA,EAGArF,KAAAsF,YAeAF,SAAAjK,UAAAmK,UAAA,WAMA,MAJAtF,MAAAuF,aACAvF,KAAAwF,gBACAxF,KAAAyF,oBAEAzF,MA0EAoF,QAAAjK,UAAArE,GAAA,SAAAkO,EAAAU,EAAArS,GACA,GAAAyJ,GACA7E,EACAyJ,EACAiE,MACAC,OACAC,aACAC,aAGA,IAAAtB,cAAAQ,GAKA,MAJAJ,OAAAI,EAAA,SAAA9P,KAAA2P,IACA7E,KAAAlJ,GAAA5B,KAAA2P,GAAAa,IACO1F,MAEPA,IAYA,KARA,kBAAAgF,KACA3R,EAAAqS,EACAA,EAAAV,EACAA,EAAA,MAGAY,UAAAjE,OAAAqD,GAEAlI,EAAA,EAAA7E,EAAA2N,OAAA5L,OAAkC8C,EAAA7E,EAAO6E,IAAA,CASzC,GARA6I,MAAAC,OAAA9I,GAEAgJ,eACAC,MAAAZ,UACAN,GAAAa,GAIA,gBAAAC,QAAA,gBAAAA,OACA3F,KAAAuF,UAAAI,SACA3F,KAAAuF,UAAAI,WACAE,aAAA7F,KAAAuF,UAAAI,OACAG,cAAArE,KAAAkE,UAEA,IAAAA,gBAAAhB,QACAkB,aAAA7F,KAAAyF,iBACAK,cAAAE,QAAAL,UAEA,WAAAA,MAIA,KAAAzE,OAAA,6BAHA2E,cAAA7F,KAAAwF,aAOA,IAAA9D,IAAArO,OACA4R,iBAAAvD,KACAoE,cAAApE,GAAArO,EAAAqO,GAEAmE,cAAAxN,KAAAyN,eAGA,MAAA9F,OAUAoF,QAAAjK,UAAA+J,KAAA,WACA,GAAAnB,MAAAC,MAAA7I,UAAAoI,MAAApQ,KAAA8M,WACAgG,GAAAlC,KAAA/J,OAAA,CAOA,OALAwK,eAAAT,KAAAkC,MAAAlC,KAAA/J,OAAA,EACA+J,KAAAkC,IAAA9G,aAAA4E,KAAAkC,KAAyCf,MAAA,IAEzCnB,KAAA1L,MAAiB6M,MAAA,IAEjBlF,KAAAlJ,GAAAiK,MAAAf,KAAA+D,OAgEAqB,QAAAjK,UAAA+K,IAAA,SAAAC,OAAAtB,IACA,GAAA/H,GACAsJ,EACA1E,EACAiE,KAGA,QAAA1F,UAAAjG,QAAA,kBAAAmM,QAAA,CACAtB,GAAA5E,UAAA,EAGA,KAAAyB,IAAA1B,MAAAuF,UACAvF,KAAAuF,UAAA7D,GAAAvK,OAAA6I,KAAAuF,UAAA7D,GAAAmD,IAEA,IAAA7E,KAAAuF,UAAA7D,GAAA1H,cACAgG,MAAAuF,UAAA7D,EAIA1B,MAAAwF,aAAArO,OAAA6I,KAAAwF,aAAAX,IAGA7E,KAAAyF,iBAAAtO,OAAA6I,KAAAyF,iBAAAZ,QAIA,QAAA5E,UAAAjG,QACA,gBAAAmM,SAAA,gBAAAA,QAKA,OAAAlG,UAAAjG,OAAA,CACA,GAAA4L,WAAAjE,OAAAwE,OAEA,KAAArJ,EAAA,EAAAsJ,EAAAR,OAAA5L,OAAoC8C,EAAAsJ,EAAOtJ,IAC3C6I,MAAAC,OAAA9I,GAEAkD,KAAAuF,UAAAI,OAAAxO,OAAA6I,KAAAuF,UAAAI,OAAAd,IAEA,KAAA7E,KAAAuF,UAAAI,YAAA3L,cACAgG,MAAAuF,UAAAI,WAKAnB,eAAA2B,SACAvB,MAAAuB,OAAAnG,KAAAkG,IAAAlG,iBAnBAA,MAAAuF,UAAAY,OAsBA,OAAAnG,OASAoF,QAAAjK,UAAAkL,UAAA,SAAAV,OACA,GAEAtC,GACAvG,EACA7E,EAJAqO,SAAAtG,KAAAwF,iBACAe,SAAA,CAKA,KAAAZ,MACA,KAAAzE,OAAA,wCAIA,KAFAoF,kBAAA3E,OAAA3B,KAAAuF,UAAAI,YAEA7I,EAAA,EAAA7E,EAAA+H,KAAAyF,iBAAAzL,OAAiD8C,EAAA7E,EAAO6E,IACxDuG,EAAArD,KAAAyF,iBAAA3I,IAEA6I,MAAAa,OAAAnD,EAAA2C,WACAO,SAAA,EACAD,SAAAjO,KAAAgL,GAKA,OAAArD,MAAAwF,aAAAxL,QAAAuM,QACAD,SAAAG,KAAA,SAAAzB,EAAAU,GACA,MAAAV,GAAAe,MAAAL,EAAAK,QAGAO,SAAA/C,MAAA,IAmBA6B,QAAAjK,UAAAiH,KAAA,SAAA+D,OAAAjQ,MAGA,IAAA8J,KAAAqF,SACA,MAAArF,KAGA,IAAAwE,cAAA2B,QAEA,MADAvB,OAAAuB,OAAAnG,KAAAoC,KAAApC,MACAA,IAGA,IAEA2F,OACA9H,OACAyI,SACAI,QACA5J,EACA6J,EACA1O,EACA7E,EATAwS,UAAAjE,OAAAwE,QACAS,QAUA,KAAA9J,EAAA,EAAA7E,EAAA2N,OAAA5L,OAAkC8C,EAAA7E,EAAO6E,IAAA,CAGzC,IAFAwJ,SAAAtG,KAAAqG,UAAAT,OAAA9I,IAEA6J,EAAA,EAAAvT,EAAAkT,SAAAtM,OAAsC2M,EAAAvT,EAAOuT,IAC7CD,QAAAJ,SAAAK,GACAhB,OACAlE,KAAAmE,OAAA9I,GACAF,OAAAoD,MAGAC,UAAAjG,OAAA,IACA2L,MAAAzP,WAEAwQ,QAAA7B,GAAA1R,KAAA,SAAAuT,iBAAAvQ,MAAA6J,KAAA2F,OAEAe,QAAAxB,MACA0B,MAAAvO,KAAAqO,QAIA,KAAAC,EAAAC,MAAA5M,OAAA,EAAgC2M,GAAA,EAAQA,IACxC9I,OAAA+I,MAAAD,GAAAlF,KACAzB,KAAAuF,UAAAqB,MAAAD,GAAAlF,MACAmF,MAAAD,GAAAX,QACAhG,KAAAyF,iBACAzF,KAAAwF,aAEA3H,OAAAgJ,OAAAhJ,OAAAxG,QAAAuP,MAAAD,IAAA,GAIA,MAAA3G,OAQAoF,QAAAjK,UAAAyI,KAAA,WAEA5D,KAAAsF,YACAtF,KAAAuF,UAAA,KACAvF,KAAAwF,aAAA,KACAxF,KAAAyF,iBAAA,KACAzF,KAAAqF,UAAA,EAGArF,KAAAsF,UACAtF,KAAAlJ,GACAkJ,KAAAkF,KACAlF,KAAAkG,IACAlG,KAAAoC,KACApC,KAAAqG,UAAA5I,SAAAtC,WAUAiK,QAAAjK,UAAA2L,QAAA,WAGA,MAFA9G,MAAAqF,UAAA,EAEArF,MASAoF,QAAAjK,UAAA4L,OAAA,WAGA,MAFA/G,MAAAqF,UAAA,EAEArF,MAOAoF,QAAA4B,QAAA,QAKA,mBAAAhU,gBAAAD,UACAA,QAAAC,OAAAD,QAAAqS,SACArS,QAAAqS,kBAOCjS,KAAA6M,OjBmjCK,SAAShN,OAAQD,QAASH,qBkBrlDhC,YAUA,SAAAW,wBAAAC,KAAsC,MAAAA,UAAAC,WAAAD,KAAuCE,UAAAF,KAE7E,QAAA6H,iBAAAC,SAAAC,aAAiD,KAAAD,mBAAAC,cAA0C,SAAAC,WAAA,qCAE3F,QAAAC,WAAAC,SAAAC,YAA0C,qBAAAA,aAAA,OAAAA,WAA+D,SAAAH,WAAA,iEAAAG,YAAuGD,UAAAP,UAAAtG,OAAA+G,OAAAD,uBAAAR,WAAyEU,aAAe9G,MAAA2G,SAAAI,YAAA,EAAAC,UAAA,EAAAC,cAAA,KAA6EL,aAAA9G,OAAAoH,eAAApH,OAAAoH,eAAAP,SAAAC,YAAAD,SAAAQ,UAAAP,YAqBrX,QAAAsL,oCAAAC,OAAAxE,YACA,IAAAA,WAAA,QAAAjE,SAAAM,WAAA,iBAAAmI,OAAA,oBAAAA,OAAA,oCAAmJ9K,KAAAsG,aAswBnJ,QAAAyE,YAAAjS,KAAAkS,aAqBAjD,OAAAhJ,UAAAjG,MAAA,SAAAkH,KAAArH,OAGA,GAAAkL,UAAAjG,OAAA,UAAAyE,SAAAM,WAAA,iBAAA7J,KAAA,wBAYA,IATA,IAAA+K,UAAAjG,QAAAqN,qBAAAnS,QACAH,MAAAqH,KACAA,SAIAA,MAAA,EAAAqC,SAAAG,YAAAxC,OAGAE,OAAA,WAAAF,WAAA,QAAAqC,SAAAM,WAAA,iBAAA7J,KAAA,mBAAmHkH,WAGnH,IAAAgL,0BAAArS,OAAA,QAAA0J,SAAAM,WAAA,iBAAA7J,KAAA,oBAAyHkH,UAAArH,aAGzH,KAAAiL,KAAA0C,WAAA,QAAAjE,SAAAM,WAAA,iBAAA7J,KAAA,sDAAyIkH,KAAA4D,KAAA5D,MAEzI,IAAAkL,UAAAtH,KAAA0C,WAAAf,OAAAvF,KAGA,OAAA4D,MAAApH,KAAA2O,OAAAD,UACA7F,KAAAvM,KACAH,eAz1BAF,OAAAC,eAAA/B,QAAA,cACAgC,OAAA,GAGA,IAAA2H,cAAA,WAAiC,QAAAC,kBAAAC,OAAAC,OAA2C,OAAAC,GAAA,EAAgBA,EAAAD,MAAA7C,OAAkB8C,IAAA,CAAO,GAAAC,YAAAF,MAAAC,EAA2BC,YAAAjB,WAAAiB,WAAAjB,aAAA,EAAwDiB,WAAAf,cAAA,EAAgC,SAAAe,yBAAAhB,UAAA,GAAuDlH,OAAAC,eAAA8H,OAAAG,WAAA7B,IAAA6B,aAA+D,gBAAAxB,YAAAyB,WAAAC,aAA2L,MAAlID,aAAAL,iBAAApB,YAAAJ,UAAA6B,YAAqEC,aAAAN,iBAAApB,YAAA0B,aAA6D1B,gBAEzhB2B,KAAA,SAAAC,IAAAC,IAAAC,KAA2D,IAAnB,GAAAC,SAAA,EAAmBA,QAAA,CAA4B,GAAAf,QAAAY,IAAAI,SAAAH,IAAAI,SAAAH,GAAkDC,SAAA,EAAgB,OAAAf,gBAAAkB,SAAAtC,UAAkD,IAAAuC,MAAA7I,OAAA8I,yBAAApB,OAAAgB,SAA8D,IAAAnD,SAAAsD,KAAA,CAAwO,YAAAA,MAA4B,MAAAA,MAAA3I,KAA4B,IAAA6I,QAAAF,KAAA7G,GAAuB,IAAAuD,SAAAwD,OAA4B,MAAoB,OAAAA,QAAAzK,KAAAqK,UAA7U,GAAAK,QAAAhJ,OAAAiJ,eAAAvB,OAA4C,WAAAsB,OAAuB,MAA2BV,KAAAU,OAAcT,IAAAG,SAAgBF,IAAAG,SAAgBF,QAAA,EAAeI,KAAAG,OAAAzD,SAQ9b2D,QAAAnL,oBAAA,IAEAoL,SAAAzK,uBAAAwK,SAEAI,QAAAvL,oBAAA,IAEA0L,MAAA1L,oBAAA,IAEA0J,OAAA/I,uBAAA+K,OAEAG,SAAA7L,oBAAA,IAsBAuR,OAAA,SAAAvE,UAGA,QAAAuE,QAAAvL,KAAAwD,KAAAiG,MACA,GAAAtC,OAAAC,IAEA3E,iBAAA2E,KAAAmE,QAEAjH,KAAArI,OAAAiJ,eAAAqG,OAAAhJ,WAAA,cAAA6E,MAAA7M,KAAA6M,MAGA5D,cAGA4D,KAAAI,UAAA,kBACAJ,KAAAwH,SAAA,KAGAxH,KAAApH,UACAoH,KAAA5D,UACA4D,KAAAqC,UAGArC,KAAAzK,OACAkS,QAAA,EACAC,WAAA,EACAC,SAAA,GAIA3H,KAAA4H,aAAAtL,OAAA,WAAAuL,YAAA7H,KAAA5D,MAGA4D,KAAA8H,YAAAxL,OAAA,WAAAsG,WAAA5C,KAAApH,KAAA6H,SAAAT,KAAA5D,MAEA4D,KAAA4H,aAAwD5H,KAAA0C,YAAA,EAAAjE,SAAAK,OAAAkB,KAAApH,KAAA+H,MAAAX,KAAA5D,MAAAsG,WAAxD1C,KAAA0C,WAAA1C,KAAA5D,KAQA4D,KAAA+H,cAAA,SAAAC,MACA,GAAA9R,MAAA8R,KAAA9R,MAEA6J,MAAAxK,MAAAkS,SAAA,EAAAhJ,SAAAwJ,cAAA/R,KAAAkG,MAAA2D,MAAAmI,uBAEAnI,MAAA2C,YAAA,EAAAjE,SAAAK,OAAAiB,MAAAnH,KAAA+H,MAAAZ,MAAA3D,MAAAsG,YAYA,IAAAyF,YAAA,SAAA1E,cACA,GAAA2E,MAAArI,MAEAsI,UAAAxT,OAAA8H,qBACA8G,cACA5M,IAAA,WACA,SAAA4H,SAAAK,OAAA2E,aAAA2E,KAAA1F,YAAAxM,MAEA8F,cAAA,EACAF,YAAA,GAEAzF,aACAQ,IAAA,WACA,MAAAuR,MAAAvR,OAEAmF,cAAA,EACAF,YAAA,IAQA,OAJAiE,OAAAxK,MAAAmS,YAAA3H,MAAAxK,MAAAoS,SAAA5H,MAAAuI,QAAAC,IAAAF,UAAA5E,cAEA1D,MAAAxK,MAAAoS,SAAA,EAEA5H,MAAAqC,KAAA,SAAAiG,WAaArI,MAAAwI,eAAA,SAAA7C,OACA,IAAA5F,MAAAxK,MAAAkS,OAAA,CAEA,GAAAgB,aAAA9C,MAAAzP,KACAwN,MAAA+E,YAAA/E,MACAD,aAAAgF,YAAAhF,aACA8D,OAAAY,WAAAO,KAAA3I,MAAA0D,cACAkF,cAAA5I,MAAAmI,mBAEA,UAAAzJ,SAAAwJ,aAAAvE,MAAAiF,eAAApB,SAAA,QAIA,IAAAqB,QAAA,CACA5I,MAAA6I,UAAA,WACA,IAAAD,MAMA,MAJAA,QAAA,EAEA7I,MAAA6H,cAAA7H,MAAAnH,KAAA9B,GAAA,QAAAiJ,MAAAgI,eAEAhI,MAAAnH,KAAA9B,GAAA,SAAAiJ,MAAAyI,iBAIAxI,KAAA4H,aACA5H,KAAA6I,aAIA7I,KAAAlJ,IAAA,EAAA2H,SAAAqK,QAAA9I,KAAA6I,UAAA7I,KAAAlJ,GAAA4R,KAAA1I,OACAA,KAAAkF,MAAA,EAAAzG,SAAAqK,QAAA9I,KAAA6I,UAAA7I,KAAAkF,KAAAwD,KAAA1I,QAskBA,MArsBAvE,WAAA0I,OAAAvE,UAuJAlD,aAAAyH,SACAjJ,IAAA,oBACAnG,MAAA,WAGA,GAAAgU,iBAAA/I,KAAA8H,aAAA,EAAArJ,SAAAK,OAAAkB,KAAApH,KAAA6H,SAAAT,KAAA8H,aAAA5R,KAAA8S,iBAEA,QAAAhJ,KAAA0C,YAAAf,OAAAoH,oBAcA7N,IAAA,SACAnG,MAAA,WACA,OAAAiL,KAAA5D,KAAApC,UASAkB,IAAA,SACAnG,MAAA,WACA,MAAAuH,QAAA,WAAA2M,UAAAjJ,KAAA9C,OAAAhH,SASAgF,IAAA,WACAnG,MAAA,WACA,OAAAiL,KAAAkJ,WAAAlJ,KAAAmJ,YAcAjO,IAAA,OACAnG,MAAA,WACA,MAAAiL,MAAApH,KAAAjC,YAeAuE,IAAA,SACAnG,MAAA,SAAAqH,MAGA,MAFA6D,WAAAjG,OAAA,IAAAoC,MAAA,EAAAqC,SAAAE,WAAAsB,YAEAD,KAAApH,KAAAjC,OAAAqJ,KAAA5D,KAAAuF,OAAAvF,UAUAlB,IAAA,KACAnG,MAAA,WACA,MAAAiL,MAAAkJ,SAEA,KAFAlJ,KAAApH,KAAAjC,OAAAqJ,KAAA5D,KAAAmH,MAAA,UAWArI,IAAA,OACAnG,MAAA,WAGA,GAFAkS,mCAAA,OAAAjH,KAAA0C,cAEA1C,KAAA9C,OAAAhH,eAAA8N,QAAA,KAAA9C,OAAA,yDAEA,OAAAlB,MAAApH,KAAAjC,OAAAqJ,KAAA0C,WAAAf,OAAA,OAUAzG,IAAA,OACAnG,MAAA,WACAkS,mCAAA,OAAAjH,KAAA0C,WAEA,IAAA0G,OAAApJ,KAAA0C,WAAA1C,KAAA0C,WAAA1I,OAAA,EAEA,IAAAqP,MAAAD,MAAA,KAAAlI,OAAA,yDAEA,OAAAkI,MAAApJ,KAAApH,KAAAjC,OAAAqJ,KAAA0C,WAAAa,MAAA,MAAA5B,OAAAyH,KAAA,YAUAlO,IAAA,QACAnG,MAAA,WACAkS,mCAAA,QAAAjH,KAAA0C,WAEA,IAAA0G,OAAApJ,KAAA0C,WAAA1C,KAAA0C,WAAA1I,OAAA,EAEA,IAAAqP,MAAAD,MAAA,KAAAlI,OAAA,2DAEA,OAAAkI,MAAA,IAAApJ,KAAAsJ,KAAApM,OAAAhH,KAAA8D,OAAA,KAEAgG,KAAApH,KAAAjC,OAAAqJ,KAAA0C,WAAAa,MAAA,MAAA5B,OAAAyH,KAAA,OAUAlO,IAAA,WACAnG,MAAA,WACAkS,mCAAA,WAAAjH,KAAA0C,WAEA,IAAA0G,OAAApJ,KAAA0C,WAAA1C,KAAA0C,WAAA1I,OAAA,EAEA,IAAAqP,MAAAD,MAAA,KAAAlI,OAAA,6DAEA,OAAAlB,MAAApH,KAAAjC,OAAAqJ,KAAA0C,WAAAa,MAAA,MAAA5B,OAAA,OAUAzG,IAAA,YACAnG,MAAA,WACAkS,mCAAA,YAAAjH,KAAA0C,WAEA,IAAA0G,OAAApJ,KAAA0C,WAAA1C,KAAA0C,WAAA1I,OAAA,EAEA,IAAAqP,MAAAD,MAAA,KAAAlI,OAAA,+DAEA,IAAAqI,MAAAvJ,KAAAsJ,KAAApM,OAAAhH,IAEA,OAAA8J,MAAApH,KAAAjC,OAAAqJ,KAAA0C,WAAAa,MAAA,MAAA5B,OAAA4H,KAAAvP,OAAA,OAWAkB,IAAA,MACAnG,MAAA,SAAA8P,GAAA1O,OACA8Q,mCAAA,MAAAjH,KAAA0C,WAEA,IAAAxC,OAAAF,KAAA9C,OAAAhH,KACA+B,EAAAgI,UAAAjG,MAEA,KAAAsC,OAAA,WAAA4D,aAAA,KAAAgB,OAAA,iDAEA,OAAAhB,OAAAvG,IAAA,SAAA6P,KAAA1M,GACA,MAAA+H,IAAA1R,KAAA8E,EAAA,EAAA9B,MAAA6J,UAAArJ,OAAAmG,KAAAoD,QACOF,SAmBP9E,IAAA,OACAnG,MAAA,WACA,GAAAqH,MAAA6D,UAAAjG,QAAA,GAAAI,SAAA6F,UAAA,MAAAA,UAAA,EAEA,KAAA3D,OAAA,WAAAF,WAAA,QAAAqC,SAAAM,WAAA,wCAAgH3C,WAEhH,OAAA4D,MAAA0C,YAEA,EAAAjE,SAAAK,OAAAkB,KAAApH,KAAA+H,MAAAX,KAAA0C,WAAAf,OAAAvF,QAFoClG,KAAAkE,OAAAsI,WAAA,KAAAC,QAAA,MAkBpCzH,IAAA,SACAnG,MAAA,SAAAqH,MAKA,MAJAA,OAAA,EAAAqC,SAAAG,YAAAxC,MAEA6D,UAAAjG,OAAA,IAAAoC,MAAA,EAAAqC,SAAAE,WAAAsB,YAEAD,KAAA9C,KAAAd,MAAAuG,UAiBAzH,IAAA,MACAnG,MAAA,SAAAqH,MACAA,MAAA,EAAAqC,SAAAG,YAAAxC,MAEA6D,UAAAjG,OAAA,IAAAoC,MAAA,EAAAqC,SAAAE,WAAAsB,WAEA,IAAAwJ,OAAAzJ,KAAA9C,KAAAd,MAEAlG,KAAAuT,MAAAvT,KACAwM,WAAA+G,MAAA/G,UAKA,OAFA1C,MAAApH,KAAAwJ,KAAA,OAA6BlM,UAAAwM,sBAAAtG,KAAA4D,KAAA5D,KAAAuF,OAAAvF,QAE7BlG,QAeAgF,IAAA,QACAnG,MAAA,WACA,GAAAmB,MAAA8J,KAAAnJ,IAAAkK,MAAAf,KAAAC,UAEA,UAAAxB,SAAAS,cAAAhJ,SAeAgF,IAAA,YACAnG,MAAA,WACA,GAAAmB,MAAA8J,KAAAnJ,IAAAkK,MAAAf,KAAAC,UAEA,UAAAxB,SAAAO,WAAA9I,SAmBAgF,IAAA,YACAnG,MAAA,SAAAqH,MAKA,GAJAA,MAAA,EAAAqC,SAAAG,YAAAxC,MAEA6D,UAAAjG,OAAA,IAAAoC,MAAA,EAAAqC,SAAAE,WAAAsB,aAEA3D,OAAA,WAAAF,WAAA,QAAAqC,SAAAM,WAAA,wCAAgH3C,WAEhH,IAAA4D,KAAA0C,WAAA,CAEA,GAAA4E,UAAAtH,KAAA0C,WAAAf,OAAAvF,MAEAlG,MAAA,EAAAuI,SAAAO,YAAA,EAAAP,SAAAK,OAAAkB,KAAApH,KAAA+H,MAAA2G,UAAApR,MACAwT,SAAA,EAAAjL,SAAAK,OAAAkB,KAAApH,KAAA6H,SAAA6G,UAAApR,KAEAyT,iBAAA,QAAAA,kBAAAvS,EAAAhE,GACA,GAAAkJ,OAAA,WAAAC,OAAAnJ,IAAAkJ,OAAA,WAAAC,OAAAnF,GAEA,OAAAsK,KAAAtO,GACAA,EAAAsO,YAAAvD,SAAAqD,aAAApK,GAAAsK,GAA0DiI,iBAAAvS,EAAAsK,GAAAtO,EAAAsO,IAK1D,OADAiI,kBAAAzT,KAAAwT,SACAxT,SAUAgF,IAAA,UACAnG,MAAA,SAAA6U,YACA,GAAAtN,OAAA,WAAAC,OAAAqN,YAAA,CACA,GAAA1T,QAEA,QAAAwL,KAAAkI,YACA1T,KAAAwL,GAAA1B,KAAAnJ,IAAA+S,WAAAlI;AACS,MAAAxL,MACF,GAAAoG,OAAA,WAAA4D,MAAA0J,YAAA,CAGP,OAFA1T,SAEA4G,EAAA,EAAA7E,EAAA2R,WAAA5P,OAA8C8C,EAAA7E,EAAO6E,IACrD5G,KAAAmC,KAAA2H,KAAAnJ,IAAA+S,WAAA9M,IACS,OAAA5G,MAGT,QAAAuI,SAAAM,WAAA,4CAAiF6K,2BAiBjF1O,IAAA,iBACAnG,MAAA,SAAA8U,YAGA,GAFAA,uBAAAC,IAEAD,WAAA,UAAApL,SAAAM,WAAA,sDACAhK,MAAA8U,YAKA,OAFA7J,MAAAzK,MAAAmS,WAAA,EAEA1H,KAAAsI,QAAAtI,MAGAA,KAAA6I,YAEA7I,KAAAsI,QAAA,GAAA7J,UAAAsL,QAAAF,YACA7J,SASA9E,IAAA,gBACAnG,MAAA,WAEA,MADAiL,MAAAzK,MAAAmS,WAAA,EACA1H,QAUA9E,IAAA,OACAnG,MAAA,WACA,GAAAiV,OAAA/J,UAAAjG,QAAA,GAAAI,SAAA6F,UAAA,KAAAA,UAAA,EAEA,KAAAD,KAAAzK,MAAAmS,UAAA,SAAAxG,OAAA,+CAEA,IAAA+I,QAAAjK,KAAAsI,QAAA4B,KAAAF,MAEA,KAAAC,OAAA,KAAA/I,OAAA,qDAKA,OAHAlB,MAAAzK,MAAAoS,SAAA,EACA3H,KAAAhI,IAAAiS,QAEAjK,QASA9E,IAAA,aACAnG,MAAA,WACA,SAAAiL,KAAAsI,UAAAtI,KAAAsI,QAAAzR,MAAAmD,WASAkB,IAAA,aACAnG,MAAA,WACA,MAAAiL,MAAAsI,QAAAtI,KAAAsI,QAAAzR,YASAqE,IAAA,eACAnG,MAAA,WAEA,MADAiL,MAAAsI,SAAAtI,KAAAsI,QAAA6B,QACAnK,QAYA9E,IAAA,UACAnG,MAAA,WAGAiL,KAAA4H,cAAA5H,KAAApH,KAAAsN,IAAA,QAAAlG,KAAA+H,eAEA/H,KAAApH,KAAAsN,IAAA,SAAAlG,KAAAwI,gBAGAxI,KAAAqC,YAAArC,MAAApH,KAAAyH,SAAAL,KAAAqC,YAGArC,MAAApH,WACAoH,MAAA5D,WACA4D,MAAA0C,iBACA1C,MAAAsI,QAGAtI,KAAA4D,OACA5D,KAAAzK,MAAAkS,QAAA,KAcAvM,IAAA,SACAnG,MAAA,WACA,MAAAiL,MAAA6D,eASA3I,IAAA,WACAnG,MAAA,WACA,MAAAiL,MAAAI,cAIA+D,QACCnG,SAAA,WAEDjL,SAAA,WAAAoR,OACA,kBAAAiG,SAAA,mBAAAA,QAAAC,WACAlG,OAAAhJ,UAAAiP,OAAAC,UAAA,WACA,GAAAnK,OAAAF,KAAA9C,OAAAhH,IAEA,KAAAoG,OAAA,WAAA4D,aAAA,KAAAgB,OAAA,2DAEA,IAAApE,GAAA,EAEAwF,OAAAtC,KACAhG,OAAAkG,MAAAlG,MAEA,QACAsQ,KAAA,WACA,MAAAxN,GAAA9C,QAEAjF,MAAAuN,OAAA3L,OAAAmG,OAKAyN,MAAA,MAeA,IAAAlD,uBACAmD,OAAA,EACAC,KAAA,EACAC,OAAA,EAmEAvD,YAAA,OACAA,WAAA,SACAA,WAAA,QAAA7K,OAAA,wBACA6K,WAAA,QACAA,WAAA,SAAA7K,OAAA,WAAA4D,OACAiH,WAAA,WACAA,WAAA,OACAA,WAAA,SACAA,WAAA,SAAA7K,OAAA,WAAAqO,SACAxD,WAAA,QAAA7K,OAAA,WAAAC,QACA4K,WAAA,YAAA7K,OAAA,WAAAC,QACAvJ,OAAAD,gBAAA,YlBimDM,SAASC,OAAQD,QAASH,qBmB/8EhC,YAQA,SAAAW,wBAAAC,KAAsC,MAAAA,UAAAC,WAAAD,KAAuCE,UAAAF,KAE7E,QAAA6H,iBAAAC,SAAAC,aAAiD,KAAAD,mBAAAC,cAA0C,SAAAC,WAAA,qCAR3F3G,OAAAC,eAAA/B,QAAA,cACAgC,OAAA,GAGA,IAAA2H,cAAA,WAAiC,QAAAC,kBAAAC,OAAAC,OAA2C,OAAAC,GAAA,EAAgBA,EAAAD,MAAA7C,OAAkB8C,IAAA,CAAO,GAAAC,YAAAF,MAAAC,EAA2BC,YAAAjB,WAAAiB,WAAAjB,aAAA,EAAwDiB,WAAAf,cAAA,EAAgC,SAAAe,yBAAAhB,UAAA,GAAuDlH,OAAAC,eAAA8H,OAAAG,WAAA7B,IAAA6B,aAA+D,gBAAAxB,YAAAyB,WAAAC,aAA2L,MAAlID,aAAAL,iBAAApB,YAAAJ,UAAA6B,YAAqEC,aAAAN,iBAAApB,YAAA0B,aAA6D1B,gBAMzhB+C,MAAA1L,oBAAA,IAEA0J,OAAA/I,uBAAA+K,OAEAC,SAAA3L,oBAAA,IAEA4L,SAAAjL,uBAAAgL,UAEAE,SAAA7L,oBAAA,IAWAiP,iBAAA,QAAAA,kBAAAE,YACA,GAAAhC,OAAAC,IAEA3E,iBAAA2E,KAAA6B,iBAEA,IAAA+I,YAAAtO,OAAA,WAAAuO,iBAAA9I,WAEA,KAAA6I,WAAA,QAAAnM,SAAAM,WAAA,sCAAwFgD,uBAIxF,IAFA/B,KAAAyB,KAAAmJ,WAEA,WAAA5K,KAAAyB,KACAzB,KAAApC,OAAAmE,WAAAlL,IACAmJ,KAAA4J,WAAA7H,WAAArI,YACAsG,KAAA0D,MAAA7O,OAAAuO,KAAApD,KAAA4J,YAAAjQ,IAAA,SAAA+H,GACA,MAAA3B,OAAA6J,WAAAlI,KAEA1B,KAAAG,QAAA4B,WAAA5B,gBACG,CACH,GAAA2K,QAAA,EACA3K,UAEA7D,QAAA,WAAAC,OAAAwF,sBAAA/H,OAAA,MACA8Q,SACA3K,QAAA4B,sBAAA/H,OAAA,IAGAgG,KAAApC,OAAAmE,sBAAA/H,OAAA8Q,QACA9K,KAAA4J,WAAA7H,WAAAwB,MAAA,GAAAuH,QACA9K,KAAA0D,MAAA1D,KAAA4J,WACA5J,KAAAG,gBAIAH,KAAA0D,MAAA1D,KAAA0D,MAAA/J,IAAA,SAAArG,GACA,SAAAqO,OAAArO,KAIA0M,KAAA+K,gBAAA/K,KAAA0D,MAAAsH,KAAA1O,OAAA,WAAAuL,aAYA9U,SAAA8O,iCAEA,IAAAL,QAAA,WACA,QAAAA,QAAA5I,KAAAqS,WAAAlJ,YACA,GAAAT,QAAAtB,IAEA3E,iBAAA2E,KAAAwB,QAGAxB,KAAApH,UACAoH,KAAA5D,KAAA6O,WACAjL,KAAA+B,qBAGA,IAAA6H,YAAA7H,WAAA6H,WACAsB,SAAAzM,SAAA0M,kBAAAzC,KAAA,KAAAuC,WAAA1H,MAAA,MAEA,YAAAxB,WAAAN,MACAzB,KAAA4J,WAAA/U,OAAAuO,KAAAwG,YAAAwB,OAAA,SAAAC,IAAA3J,GAEA,MADA2J,KAAA3J,GAAAwJ,SAAAtB,WAAAlI,IACA2J,SAEArL,KAAAsL,SAAAzW,OAAAuO,KAAApD,KAAA4J,YAAAjQ,IAAA,SAAA+H,GACA,MAAAJ,QAAAsI,WAAAlI,OAGA1B,KAAA4J,sBAAAjQ,IAAAuR,UACAlL,KAAAsL,SAAAtL,KAAA4J,YAIA5J,KAAAzK,OACAkS,QAAA,GAUAzH,KAAAuL,cAAA,SAAAvD,MACA,GAAA5L,MAAA4L,KAAA9R,KAAAkG,IAEA,KAAAkF,OAAA/L,MAAAkS,OAAA,CAGA,GAAA+D,YAAA,EAAA/M,SAAAwJ,cAAA7L,MAAAkF,OAAA0H,eAEAwC,YAAAlK,OAAAiG,WAUAvH,KAAAyL,kBAAA,SAAAC,OACA,GAAAC,YAAAD,MAAAxV,KACAuD,OAAAkS,WAAAlS,OACA2C,KAAAuP,WAAAvP,IAEA,KAAAkF,OAAA/L,MAAAkS,QAGAnG,SAAA7H,OAAA,CAGA,GAAA+R,YAAA,EAAA/M,SAAAwJ,cAAA7L,MAAAkF,OAAA0H,cAAA,GAEAwC,YAAAlK,OAAAiG,WAIAvH,KAAApH,KAAA9B,GAAA,QAAAkJ,KAAAuL,eACAvL,KAAApH,KAAA9B,GAAA,UAAAkJ,KAAAyL,mBAGAzL,KAAAuH,SAqHA,MA3GA7K,cAAA8E,SACAtG,IAAA,eACAnG,MAAA,WACA,GAAAwN,QAAAvC,KAEA4L,UAAA3L,UAAAjG,QAAA,GAAAI,SAAA6F,UAAA,IAAAA,UAAA,GAEAyD,MAAAtJ,MAEAsJ,OAAA1D,KAAA+B,WAAAgJ,gBAAA/K,KAAAsL,SAAA3R,IAAA,SAAArG,GACA,SAAAmL,SAAAK,OAAAyD,OAAA3J,KAAA+H,MAAArN,GAAAoP,aACS1C,KAAAsL,QAET,IAAAO,aAAAD,WAAA5L,KAAAsL,SAAAN,KAAA,SAAA1X,GACA,QAAAgJ,OAAA,WAAAsG,WAAAL,OAAA3J,KAAA6H,SAAAnN,IAGA,OAAAuY,aAEAnI,MAAA0H,OAAA,SAAAU,iBAAA1P,MACA,GAAAwG,YAAAtG,OAAA,WAAAsG,WAAAL,OAAA3J,KAAA6H,SAAArE,KAEA,KAAAwG,WAAA,MAAAkJ,kBAAAnK,QAAAvF,MAGA,IAAA2P,gBAAA,EAAAtN,SAAAK,OAAAyD,OAAA3J,KAAA6H,SAAAmC,YAAA1M,IAEA,OAAA4V,kBAAAnK,OAAAoK,cAAA/C,qBAVAtF,SAqBAxI,IAAA,SACAnG,MAAA,WACA,GAAAiX,MAAAhM,KAAApH,KAAAqT,QAAAjM,KAAA4J,YAEAsC,WAAA,SAAAtT,KAAAuT,IAAAjW,MACA,GAAAkW,OAAA,KACAC,iBAAA,CAEA,mBAUA,MARAA,mBACAD,MAAAD,IAAAvO,OAAAmD,MAAAnI,KAAA,WAAAuT,IAAA1K,MAAAvL,YAEA0C,KAAAuH,QAAA9G,WAAA8S,IAAAhM,QAAA9G,aAAA,MAAAoF,SAAAI,YAAAuN,OAEAC,iBAAA,GAGAD,QAEOpM,KAAApH,KAAAoH,KAAA+B,WAAAiK,KAKP,IAHAE,WAAAI,cAAA,EAGAtM,KAAApH,KAAAuH,QAAAZ,YACAS,KAAApH,KAAA+H,OAAA,EAAAnC,SAAA,YAAAwB,KAAApH,KAAA+H,MAAAX,KAAA5D,MACAqF,KAAA,SACA1M,MAAAmX,YACSlM,KAAApH,KAAAuH,SAAAjK,SACF,CACP,GAAAsD,SAAA,EAAAgF,SAAA,YAAAwB,KAAApH,KAAA+H,MAAAX,KAAA5D,MACAqF,KAAA,MACA1M,MAAAmX,aACA/L,SACAoM,aAAAvM,KAAA+B,WAAA5B,QAAA9G,YAES2G,KAAApH,KAAAuH,QAET,SAAA3G,UAAAwG,KAAApH,KAAA+H,MAAAnH,OAAAtD,MAMA,MAFA8J,MAAApH,KAAAwJ,KAAA,WAAiC3I,OAAAuG,KAAA5D,KAAA4D,KAAA5D,OAEjC4D,QAOA9E,IAAA,UACAnG,MAAA,WAGAiL,KAAApH,KAAAsN,IAAA,QAAAlG,KAAAuL,eACAvL,KAAApH,KAAAsN,IAAA,UAAAlG,KAAAwM,gBACAxM,KAAAzK,MAAAkS,QAAA,QAKAzH,MAAA4J,iBACA5J,MAAAsL,eACAtL,MAAApH,SAIA4I,SAGAzO,SAAAyO,enB29EM,SAASxO,OAAQD,QAASH,qBoBpvFhC,YAwBA,SAAA6Z,OAAA7P,OAAA8P,SACA,MAAAA,SAAA1B,KAAA,SAAA2B,GACA,MAAAlL,MAAAkL,GAAA/P,UAxBA/H,OAAAC,eAAA/B,QAAA,cACAgC,OAAA,GAGA,IAAAoJ,SAAAvL,oBAAA,IAEA6O,OAiCAA,MAAAvB,MAAA,SAAAtD,QACA,MAAAoH,OAAAU,QAAA9H,SASA6E,KAAAlF,OAAA,SAAAK,QACA,MAAAA,SAAA,gBAAAA,UAAAoH,MAAAU,QAAA9H,4BAAAgQ,UAAAhQ,iBAAA+H,YAAA,kBAAAkI,MAAAjQ,iBAAAiQ,SAAA,kBAAAC,MAAAlQ,iBAAAkQ,OASArL,KAAAsL,OAAA,SAAAnQ,QACA,sBAAAA,SASA6E,KAAAuL,OAAA,SAAApQ,QACA,sBAAAA,SASA6E,KAAA,qBAAA7E,QACA,wBAAAA,SASA6E,KAAAwH,UAAA,SAAArM,QACA,MAAAA,UAAA/H,OAAA+H,SAeA6E,KAAAkJ,QAAA,SAAA/N,QACA,SAAA6E,KAAAvB,MAAAtD,gBAAA5C,OAAA,KAEAyS,MAAA7P,OAAA,oCAAA6E,KAAAuL,OAAApQ,OAAA,KAYA,IAAAqQ,mBAAA,sCAEAxL,MAAArF,KAAA,SAAAQ,QACA,SAAAA,QAAA,IAAAA,QAAA,KAAAA,YAEA+E,OAAA/E,QAAAsQ,MAAA,SAAA7Q,MACA,MAAAoQ,OAAApQ,KAAA4Q,qBAUAxL,KAAAoG,YAAA,SAAAzL,MACA,MAAAA,MAAA4O,KAAA,SAAA3O,MACA,MAAAoF,MAAA,YAAApF,OAAAoF,KAAAlF,OAAAF,SAYAoF,KAAAmB,WAAA,SAAA1M,KAAAkG,MACA,GAAA+Q,YAEA9Z,EAAA6C,KACA4G,EAAA1C,OACAnC,EAAAmC,MAEA,KAAA0C,EAAA,EAAA7E,EAAAmE,KAAApC,OAA8B8C,EAAA7E,EAAO6E,IAAA,CAGrC,GAFAqQ,QAAA9U,KAAA+D,KAAAU,IAEA,gBAAAzJ,GAAA,WAIA,IAFAA,IAAA+I,KAAAU,IAEAzJ,YAAA8K,SAAAqD,OAAA,MAAA2L,SAGA,aAUA1L,KAAAyK,WAAA,SAAA3H,EAAA6I,aACA,GAAArQ,YAAAlI,OAAA8I,yBAAA4G,EAAA6I,YAEA,OAAArQ,wBAAAlG,KAAAkG,WAAAlG,IAAAyV,gBAAA,GASA7K,KAAAoJ,iBAAA,SAAA9I,YAEA,GAAAN,KAAAlF,OAAAwF,YACA,MAAAN,MAAA,YAAAM,WAAAlL,QAAAkL,WAAArI,SAAA+H,KAAAlF,OAAAwF,WAAArI,UAAA7E,OAAAuO,KAAArB,WAAArI,SAAAwT,MAAA,SAAAxL,GACA,MAAAD,MAAArF,KAAA2F,WAAArI,QAAAgI,OAGA,SAFK,IAGF,IAAAD,KAAAvB,MAAA6B,YAAA,CACH,GAAA+I,QAAA,CAIA,OAFArJ,MAAAlF,OAAAwF,sBAAA/H,OAAA,KAAA8Q,SAEArJ,KAAA,YAAAM,sBAAA/H,OAAA8Q,UAAA/I,WAAAwB,MAAA,GAAAuH,QAAAoC,MAAA,SAAA5Z,GACA,MAAAmO,MAAArF,KAAA9I,KAGA,QAFK,KAKL,aASAmO,KAAA4L,eAAA,SAAAtL,YACA,MAAAN,MAAAlF,OAAAwF,aAAAlN,OAAAuO,KAAArB,YAAAmL,MAAA,SAAAxL,GACA,MAAAD,MAAArF,KAAA2F,WAAAL,MAYA,IAAA4L,mBAAA,2FAEA7L,MAAAe,cAAA,SAAAuK,QACA,sBAAAA,YAAAO,iBAAAjW,QAAA0V,SAGAha,QAAA,WAAA0O,KACAzO,OAAAD,gBAAA,YpBkwFM,SAASC,OAAQD,QAASH,qBqBr/FhC,YAOA,SAAAW,wBAAAC,KAAsC,MAAAA,UAAAC,WAAAD,KAAuCE,UAAAF,KAE7E,QAAA+Z,oBAAAC,KAAkC,GAAAxJ,MAAAU,QAAA8I,KAAA,CAA0B,OAAA1Q,GAAA,EAAA2Q,KAAAzJ,MAAAwJ,IAAAxT,QAA0C8C,EAAA0Q,IAAAxT,OAAgB8C,IAAA2Q,KAAA3Q,GAAA0Q,IAAA1Q,EAAuB,OAAA2Q,MAAsB,MAAAzJ,OAAA0J,KAAAF,KAQnK,QAAAG,KAAAtM,UAAAuM,eAAAxR,MACA,SAAAqC,SAAAM,WAAA,oCAAAsC,UAAA,kBAAAuM,eAAA,YAAAxR,KAAAK,KAAA,YAAiKL,YAcjK,QAAAmL,QAAArR,KAAAkG,KAAAiF,WACA,GAAAvB,MAAAG,UAAAjG,QAAA,GAAAI,SAAA6F,UAAA,MAAqEA,UAAA,GACrEuC,cAAAnB,UAAAI,KACA1M,MAAAsM,UAAAtM,MACA8Y,mBAAAxM,UAAAlB,QACA2N,iBAAA1T,SAAAyT,sBAA8DA,mBAG9DE,OAAenN,KAAA1K,MACf8X,WAAA,QAAArM,OAAA4L,mBAAAnR,OACA6R,eAGA3a,EAAAya,MACAjR,EAAA1C,OACAnC,EAAAmC,OACA8T,EAAA9T,MAEA,KAAA0C,EAAA,EAAA7E,EAAA+V,UAAAhU,OAAmC8C,EAAA7E,EAAO6E,IAAA,CAW1C,GANAoR,EAAAF,UAAAlR,GAGAA,EAAA,GAAAmR,YAAA5V,KAAA6V,GAGApR,IAAA7E,EAAA,GAKA,WAAAuK,cAAA,CAGA,GAAA1C,KAAAL,MAAAnM,EAAA4a,KAAAnZ,MAAA,OAAiDqM,KAAA9N,EAAA4a,GAEjD5R,QAAA,WAAA4P,WAAA5Y,EAAA4a,GACArZ,OAAAC,eAAAxB,EAAA4a,GACAnZ,YACA+G,YAAA,EACAE,cAAA,IAES8D,KAAAN,aAAAsO,iBAAAvB,YACTjZ,EAAA4a,IAAA,EAAAzP,SAAAS,cAAAnK,OAEAzB,EAAA4a,GAAAnZ,UAOA,eAAAyN,cACA3N,OAAAC,eAAAxB,EAAA4a,GACArX,IAAA9B,MACA+G,YAAA,EACAE,cAAA,QAOA,cAAAwG,cAAA,CACA,GAAAhJ,QAAAzE,MAAAzB,EAAA4a,GAGA,IAAApO,KAAAL,MAAAnM,EAAA4a,KAAA1U,OAAA,OAAsD4H,KAAA9N,EAAA4a,GAEtD5R,QAAA,WAAA4P,WAAA5Y,EAAA4a,GACArZ,OAAAC,eAAAxB,EAAA4a,GACAnZ,MAAAyE,OACAsC,YAAA,EACAE,cAAA,IAEa8D,KAAAN,WACblM,EAAA4a,IAAA,EAAAzP,SAAAS,cAAA1F,QAEAlG,EAAA4a,GAAA1U,WAOA,aAAAgJ,cAAA,CACA,IAAAlG,OAAA,WAAA4D,MAAA5M,EAAA4a,IAAA,KAAAP,KAAA,eAAAM,YAEAnO,MAAAN,WAAAlM,EAAA4a,GAAA5a,EAAA4a,GAAAvM,QAAA5M,QAA+DzB,EAAA4a,GAAA7V,KAAAtD,WAM/D,gBAAAyN,cAAA,CACA,IAAAlG,OAAA,WAAA4D,MAAA5M,EAAA4a,IAAA,KAAAP,KAAA,kBAAAM,YAEAnO,MAAAN,WAAAlM,EAAA4a,IAAAnZ,OAAA4M,OAAArO,EAAA4a,IAAiE5a,EAAA4a,GAAAC,QAAApZ,WAMjE,eAAAyN,cAAA,CACA,IAAAlG,OAAA,WAAA4D,MAAA5M,EAAA4a,IAAA,KAAAP,KAAA,iBAAAM,YAEAnO,MAAAN,WAAAlM,EAAA4a,GAAA5a,EAAA4a,GAAAvM,OAAA5M,OAAiEzB,EAAA4a,GAAA7V,KAAA0I,MAAAzN,EAAA4a,GAAAnZ,WAMjE,eAAAyN,cAAA,CACA,IAAAlG,OAAA,WAAA4D,MAAA5M,EAAA4a,IAAA,KAAAP,KAAA,iBAAAM,YAEAnO,MAAAN,WAAAlM,EAAA4a,GAAAzP,SAAAoI,OAAA9F,MAAA,MAAAzN,EAAA4a,IAAAvM,OAAA5M,QAAkGzB,EAAA4a,GAAArH,OAAA9F,MAAAzN,EAAA4a,GAAAnZ,WAMlG,YAAAyN,cAAA,CACA,IAAAlG,OAAA,WAAA4D,MAAA5M,EAAA4a,IAAA,KAAAP,KAAA,cAAAM,YAEAnO,MAAAN,WAAAlM,EAAA4a,IAAA,EAAAzP,SAAAoI,QAAAvT,EAAA4a,MAAA,GAAoF5a,EAAA4a,GAAAzD,UAMpF,cAAAjI,cAAA,CACA,IAAAlG,OAAA,WAAA4D,MAAA5M,EAAA4a,IAAA,KAAAP,KAAA,gBAAAM,YAEAnO,MAAAN,WAAAlM,EAAA4a,IAAA,EAAAzP,SAAAoI,QAAAvT,EAAA4a,GAAA,KAAqF5a,EAAA4a,GAAAxD,YAMrF,cAAAlI,cACAlG,OAAA,WAAAC,OAAAjJ,YAAA4a,GAAuE5R,OAAA,WAAA4D,MAAA5M,MAAAuT,OAAAqH,EAAA,OAMvE,cAAA1L,cAAA,CACA,IAAAlG,OAAA,WAAAC,OAAAjJ,EAAA4a,IAAA,KAAAP,KAAA,iBAAAM,YAEAnO,MAAAN,WAAAlM,EAAA4a,IAAA,EAAAzP,SAAAU,iBAAqF7L,EAAA4a,GAAAnZ,OAAezB,EAAA4a,IAAA,EAAAzP,SAAAU,cAAA7L,EAAA4a,GAAAnZ,WAMpG,kBAAAyN,cAAA,CACA,IAAAlG,OAAA,WAAAC,OAAAjJ,EAAA4a,IAAA,KAAAP,KAAA,qBAAAM,YAEAnO,MAAAN,WAAAlM,EAAA4a,IAAA,EAAAzP,SAAAQ,cAAoF3L,EAAA4a,GAAAnZ,OAAezB,EAAA4a,IAAA,EAAAzP,SAAAQ,WAAA3L,EAAA4a,GAAAnZ,OAInG+K,KAAAzG,YAAAyU,iBAAAvB,cAAA,EAAA9N,SAAAI,YAAAvL,EAEA,OAIAgJ,OAAA,WAAA2M,UAAA3V,EAAA4a,IACA5a,EAAA4a,MAIApO,KAAAN,aACAlM,EAAA4a,IAAA,EAAAzP,SAAAS,cAAA5L,EAAA4a,KAIApO,KAAAzG,WAAApB,EAAA,MAAAwG,SAAA2P,QAAA9a,GAEAA,IAAA4a,GAIA,MAAA5R,QAAA,WAAA4P,WAAA5Y,EAAA4a,IAAkDhY,KAAA6X,MAAAnN,OAGxC1K,KAAA6X,MAAAnN,KAAAQ,KAAA9N,EAAA4a,IA5NVrZ,OAAAC,eAAA/B,QAAA,cACAgC,OAAA,IAEAhC,QAAA,WAAAwU,MAMA,IAAAjJ,OAAA1L,oBAAA,IAEA0J,OAAA/I,uBAAA+K,OAEAG,SAAA7L,oBAAA,GAkNAI,QAAAD,gBAAA,YrBigGM,SAASC,OAAQD,QAASH,sBsBxuGhC,SAAAyb,QAQA,YAiBA,SAAA9a,wBAAAC,KAAsC,MAAAA,UAAAC,WAAAD,KAAuCE,UAAAF,KAE7E,QAAA6H,iBAAAC,SAAAC,aAAiD,KAAAD,mBAAAC,cAA0C,SAAAC,WAAA,qCAqB3F,QAAA8S,OAAAtJ,EAAAH,IACA,GAAA/H,GAAA1C,OACAnC,EAAAmC,MACA,KAAA0C,EAAA,EAAA7E,EAAA+M,EAAAhL,OAA2B8C,EAAA7E,EAAO6E,IAClC,GAAA+H,GAAAG,EAAAlI,IAAA,MAAAA,EAEA,UASA,QAAAyG,OAAArD,OACA,GAAAqO,UAAA,GAAAvK,OAAA9D,MAAAlG,QAEA8C,EAAA1C,OACAnC,EAAAmC,MAEA,KAAA0C,EAAA,EAAA7E,EAAAiI,MAAAlG,OAA+B8C,EAAA7E,EAAO6E,IAAAyR,SAAAzR,GAAAoD,MAAApD,EAEtC,OAAAyR,UAwFA,QAAA5P,WAAA6P,SACA,MAAAjL,OAAAiL,SAYA,QAAA1F,QAAA2F,UAAA5J,IACA,kBACA4J,UAAA1N,MAAA,KAAAd,WACA4E,GAAA9D,MAAA,KAAAd,YAWA,QAAAyO,aAAAC,IACA,GAAA3I,SAAA2I,GAAAC,OAEAC,MAAA,EAQA,OANAF,IAAAN,SAAAQ,OAAA,KACAF,GAAAG,YAAAD,OAAA,KACAF,GAAAI,aAAAF,OAAA,KACAF,GAAAK,SAAAH,OAAA,KACAF,GAAAM,UAAAJ,OAAA,KAEA,GAAAlK,QAAAqB,QAAA6I,OAYA,QAAAK,QAAAC,KAAA3F,MACA,IAAAA,MAAA,gBAAAA,sBAAAtI,QAAAsI,eAAArL,SAAA0D,kBAAA2H,eAAArL,SAAAqD,QAAA,eAAA6M,SAAA7E,eAAA4F,aAAA,MAAA5F,KAGA,IAAAlN,OAAA,WAAA4D,MAAAsJ,MAAA,CACA,GAAA2F,KAAA,CACA,GAAAnK,MAEAlI,EAAA1C,OACAnC,EAAAmC,MAEA,KAAA0C,EAAA,EAAA7E,EAAAuR,KAAAxP,OAAkC8C,EAAA7E,EAAO6E,IAAAkI,EAAA3M,KAAA6W,QAAA,EAAA1F,KAAA1M,IACzC,OAAAkI,GAGA,MAAAzB,OAAAiG,MAIA,GAAAA,eAAAoD,MAAA,UAAAA,MAAApD,KAAA6F,UAGA,IAAA7F,eAAA7E,QAAA,MAAA+J,aAAAlF,KAGA,IAAAlN,OAAA,WAAAC,OAAAiN,MAAA,CACA,GAAAjF,MAEA7C,EAAAtH,MAGA,KAAAsH,IAAA8H,MACAlN,OAAA,WAAA4P,WAAA1C,KAAA9H,GACA7M,OAAAC,eAAAyP,EAAA7C,GACA7K,IAAAhC,OAAA8I,yBAAA6L,KAAA9H,GAAA7K,IACAiF,YAAA,EACAE,cAAA,IAEOwN,KAAApO,eAAAsG,KACP6C,EAAA7C,GAAAyN,KAAAD,QAAA,EAAA1F,KAAA9H,IAAA8H,KAAA9H,GAGA,OAAA6C,GAGA,MAAAiF,MAmBA,QAAA5K,YAAAhC,QACA,MAAAA,SAAA,IAAAA,QAAA,KAAAA,iBAYA,QAAA0S,SAAA/S,OAAAgT,aACA,GAAAC,KAAA,EACA9N,EAAAtH,MAIA,KAAAmC,OAAA,QAEA,KAAAmF,IAAA6N,aACA,GAAAjT,OAAA,WAAAC,OAAAgT,YAAA7N,IACA8N,OAAAF,QAAA/S,OAAAmF,GAAA6N,YAAA7N,QACK,IAAApF,OAAA,WAAA4D,MAAAqP,YAAA7N,IACL8N,UAAAD,YAAA7N,GAAArK,QAAAkF,OAAAmF,QAEA,IAAAnF,OAAAmF,KAAA6N,YAAA7N,GAAA,QAIA,OAAA8N,IAUA,QAAAC,SAAAN,KAAA5K,GACA,qBAAAA,IAAA,OAAAA,eAAApG,SAAAqD,UAEA3M,OAAAuZ,OAAA7J,GAEA4K,MAEA,GAAAnL,MAAAU,QAAAH,GAAA,CAGA,GAAAzH,GAAA1C,OACAnC,EAAAmC,MAEA,KAAA0C,EAAA,EAAA7E,EAAAsM,EAAAvK,OAA6B8C,EAAA7E,EAAO6E,IAAA2S,SAAA,EAAAlL,EAAAzH,QACjC,CACH,GAAAxJ,GAAA8G,OACAsH,EAAAtH,MAEA,KAAAsH,IAAA6C,GACAjI,OAAA,WAAA4P,WAAA3H,EAAA7C,KAEApO,EAAAiR,EAAA7C,GAEApO,GAAAiR,EAAAnJ,eAAAsG,IAAA,gBAAApO,KAAAuB,OAAA6a,SAAApc,IAEAmc,SAAA,EAAAnc,KAkCA,QAAAwL,OAAAvC,OAAAH,MACA,IAAAA,KAAA,MAAAuT,iBAEA,IAAAjN,eAEAC,QAAA,EACAtP,EAAAkJ,OACAqT,IAAAxV,OACA0C,EAAA1C,OACAnC,EAAAmC,MAEA,KAAA0C,EAAA,EAAA7E,EAAAmE,KAAApC,OAA8B8C,EAAA7E,EAAO6E,IAAA,CACrC,IAAAzJ,EAAA,OACA6C,KAAAkE,OACAsI,sBAAAf,OAAAvF,KAAAmH,MAAAzG,IACA6F,QAAA,EAGA,sBAAAvG,MAAAU,GAAA,CACA,IAAAR,OAAA,WAAA4D,MAAA7M,GAAA,MAAAsc,iBAGA,IADAC,IAAAtB,MAAAjb,EAAA+I,KAAAU,MACA8S,IAAA,MAAAD,iBAEAjN,YAAArK,KAAAuX,KACAvc,IAAAuc,SACK,oBAAAxT,MAAAU,GAAA,CACL,IAAAR,OAAA,WAAA4D,MAAA7M,GAAA,MAAAsc,iBAKA,IAHAC,IAAAtB,MAAAjb,EAAA,SAAA0D,GACA,MAAAuY,SAAAvY,EAAAqF,KAAAU,QAEA8S,IAAA,MAAAD,iBAEAjN,YAAArK,KAAAuX,KACAvc,IAAAuc,SAEAlN,YAAArK,KAAA+D,KAAAU,IACA6F,OAAA,gBAAAtP,IAAA+I,KAAAU,IAAAzJ,GACAA,IAAA+I,KAAAU,IAIA,OAAU5G,KAAA7C,EAAAqP,sBAAAC,eAWV,QAAA5D,WAAA8Q,QAAA3Z,MACA,GAAAyX,KAAA,GAAAzM,OAAA2O,QAEA,QAAAnO,KAAAxL,MACAyX,IAAAjM,GAAAxL,KAAAwL,EACG,OAAAiM,KAaH,QAAAmC,QAAAX,MACA,OAAArL,MAAA7D,UAAAjG,OAAA+V,QAAA/L,MAAAF,KAAA,EAAAA,KAAA,KAAAG,KAAA,EAAuFA,KAAAH,KAAaG,OACpG8L,QAAA9L,KAAA,GAAAhE,UAAAgE,KAGA,IAAAM,GAAAwL,QAAA,GAEApD,EAAAvS,OACA0C,EAAA1C,OACAnC,EAAAmC,OACAsH,EAAAtH,MAEA,KAAA0C,EAAA,EAAA7E,EAAA8X,QAAA/V,OAAiC8C,EAAA7E,EAAO6E,IAAA,CACxC6P,EAAAoD,QAAAjT,EAEA,KAAA4E,IAAAiL,IACAwC,OAAA7S,OAAA,WAAAC,OAAAoQ,EAAAjL,KAAAiL,EAAAjL,YAAAvD,SAAAqD,OAGA+C,EAAA7C,GAAAiL,EAAAjL,GAFA6C,EAAA7C,GAAAoO,QAAA,EAAAvL,EAAA7C,OAAsCiL,EAAAjL,IAOtC,MAAA6C,GAoBA,QAAA4G,mBAAA6E,KAAAC,IACA,GAAAvN,cAGAuN,OAAAtO,OAAAsO,GAEA,QAAAnT,GAAA,EAAA7E,EAAAgY,GAAAjW,OAAgC8C,EAAA7E,EAAO6E,IAAA,CACvC,GAAAT,MAAA4T,GAAAnT,EAEA,OAAAT,KACAS,IAAA4F,WAAAsN,KAAAzM,MAAA,IACK,OAAAlH,KACLqG,YAAA5F,EAAA4F,WAAAsN,MAAAzM,MAAA,MAEAb,WAAArK,KAAAgE,MAIA,MAAAqG,YAsBA,QAAAuF,aAAAhG,cAAA0G,eACA,GAAA7L,GAAA1C,OACAuM,EAAAvM,OACAsH,EAAAtH,OACAnC,EAAAmC,OACAhH,EAAAgH,OACAgM,EAAAhM,OACA9G,EAAA8G,OACA/G,EAAA+G,OACA8T,EAAA9T,MAGA,KAAA0C,EAAA,EAAA7E,EAAAgK,cAAAjI,OAAuC8C,EAAA7E,EAAO6E,IAAA,CAG9C,GAFAxJ,EAAA2O,cAAAnF,IAEAxJ,EAAA0G,OAAA,QAGA,KAAA2M,EAAA,EAAAvT,EAAAuV,cAAA3O,OAAyC2M,EAAAvT,EAAOuT,IAAA,CAGhD,GAFAtT,EAAAsV,cAAAhC,IAEAtT,MAAA2G,OAAA,QAGA,KAAA0H,EAAA,EAAA0E,EAAA/S,EAAA2G,OAA+B0H,EAAA0E,IAC/B8H,EAAA7a,EAAAqO,GAIAwM,GAAA5a,EAAAoO,IALsCA,IAQtC,GAAAA,EAAA,IAAA0E,GAAA1E,EAAA,IAAApO,EAAA0G,OAAA,UAKA,SAaA,QAAA6M,QAAA3G,MAAAgQ,WAAAC,IACAA,GAAAC,KAAAC,IAAA,EAAAF,IAGA7T,OAAA,uBAAA4T,yBAAA5B,MAAApO,MAAAgQ,aACA5T,OAAA,WAAAC,OAAA2T,yBAAA5B,MAAApO,MAAA,SAAAnJ,GACA,MAAAuY,SAAAvY,EAAAmZ,cAKA,QAAAI,OAAArQ,UAAAjG,OAAAuW,SAAAvM,MAAAsM,MAAA,EAAAA,MAAA,KAAAE,MAAA,EAA4FA,MAAAF,MAAeE,QAC3GD,SAAAC,MAAA,GAAAvQ,UAAAuQ,MAGA,OAAAN,aAAA,EAAAhQ,MAAAqD,MAAA,EAAA2M,YAAAvO,OAAA4O,UAAA5O,OAAAzB,MAAAqD,MAAA2M,WAAAC,KAGAjQ,MAAAqD,MAAA,EAAArD,MAAAlG,OAAAkW,YAAAvO,OAAA4O,UAAA5O,OAAAzB,MAAAqD,MAAArD,MAAAlG,OAAAkW,WAAAC,KA3kBAtb,OAAAC,eAAA/B,QAAA,cACAgC,OAAA,GAGA,IAAA2H,cAAA,WAAiC,QAAAC,kBAAAC,OAAAC,OAA2C,OAAAC,GAAA,EAAgBA,EAAAD,MAAA7C,OAAkB8C,IAAA,CAAO,GAAAC,YAAAF,MAAAC,EAA2BC,YAAAjB,WAAAiB,WAAAjB,aAAA,EAAwDiB,WAAAf,cAAA,EAAgC,SAAAe,yBAAAhB,UAAA,GAAuDlH,OAAAC,eAAA8H,OAAAG,WAAA7B,IAAA6B,aAA+D,gBAAAxB,YAAAyB,WAAAC,aAA2L,MAAlID,aAAAL,iBAAApB,YAAAJ,UAAA6B,YAAqEC,aAAAN,iBAAApB,YAAA0B,aAA6D1B,eAEzhBxI,SAAA4L,oBACA5L,QAAA+V,cACA/V,QAAA6L,sBACA7L,QAAA+L,YACA/L,QAAAgM,oBACAhM,QAAAoY,oCACApY,QAAAkV,wBACAlV,QAAA8T,aAMA,IAAA1I,SAAAvL,oBAAA,IAEA0L,MAAA1L,oBAAA,IAEA0J,OAAA/I,uBAAA+K,OAKAmS,KAAAhT,SAAAtC,UA2CA4O,QAAA,WACA,QAAAA,SAAA2G,MACArV,gBAAA2E,KAAA+J,SAEA/J,KAAA0Q,UACA1Q,KAAA2Q,WAoEA,MAnDAjU,cAAAqN,UACA7O,IAAA,MACAnG,MAAA,WACA,MAAAiL,MAAA2Q,WAUAzV,IAAA,MACAnG,MAAA,SAAAkV,QAMA,MALAjK,MAAA2Q,QAAAxC,QAAAlE,QAGAjK,KAAA2Q,QAAA3W,OAAAgG,KAAA0Q,OAAA1Q,KAAA2Q,QAAA3W,OAAAgG,KAAA0Q,MAEA1Q,QASA9E,IAAA,QACAnG,MAAA,WAEA,MADAiL,MAAA2Q,WACA3Q,QAUA9E,IAAA,OACAnG,MAAA,SAAAiV,OACA,GAAAC,QAAAjK,KAAA2Q,QAAA3G,MAAA,EAGA,OADAC,UAAAjK,KAAA2Q,QAAA3Q,KAAA2Q,QAAApN,MAAAyG,QACAC,WAIAF,UAGAhX,SAAAgX,eAuGA,IAAA7K,cAAAgQ,OAAAxG,KAAA,SACA1J,UAAAkQ,OAAAxG,KAAA,QAEA3V,SAAAmM,0BACAnM,QAAAiM,mBAqFA,IAAA4R,mBAAA,kBAAA/b,QAAAuZ,OAEAA,OAAAwC,kBAAAnB,QAAA/G,KAAA,SAAA+H,KACA5R,WAAA+R,kBAAAnB,QAAA/G,KAAA,SAAA+H,IAEA1d,SAAAqb,cACArb,QAAA8L,qBAgBA,IAAA8Q,mBAAwBzZ,KAAAkE,OAAAsI,WAAA,KAAAC,QAAA,GAwGxBxD,aAAA2Q,OAAApH,KAAA,SACAzJ,UAAA6Q,OAAApH,KAAA,QAEA3V,SAAAoM,0BACApM,QAAAkM,mBA8HA,IAAAzC,QAAA,WACA,GAAAM,GAAA,CAEA,mBACA,MAAAA,QAIA/J,SAAAyJ,gBtB2uG8BrJ,KAAKJ,QAAU,WAAa,MAAOiN,WAI3D,SAAShN,OAAQD,QAASH,qBuB70HhC,YAUA,SAAAW,wBAAAC,KAAsC,MAAAA,UAAAC,WAAAD,KAAuCE,UAAAF,KAE7E,QAAA6H,iBAAAC,SAAAC,aAAiD,KAAAD,mBAAAC,cAA0C,SAAAC,WAAA,qCAE3F,QAAAC,WAAAC,SAAAC,YAA0C,qBAAAA,aAAA,OAAAA,WAA+D,SAAAH,WAAA,iEAAAG,YAAuGD,UAAAP,UAAAtG,OAAA+G,OAAAD,uBAAAR,WAAyEU,aAAe9G,MAAA2G,SAAAI,YAAA,EAAAC,UAAA,EAAAC,cAAA,KAA6EL,aAAA9G,OAAAoH,eAAApH,OAAAoH,eAAAP,SAAAC,YAAAD,SAAAQ,UAAAP,YAZrX9G,OAAAC,eAAA/B,QAAA,cACAgC,OAAA,GAGA,IAAA2H,cAAA,WAAiC,QAAAC,kBAAAC,OAAAC,OAA2C,OAAAC,GAAA,EAAgBA,EAAAD,MAAA7C,OAAkB8C,IAAA,CAAO,GAAAC,YAAAF,MAAAC,EAA2BC,YAAAjB,WAAAiB,WAAAjB,aAAA,EAAwDiB,WAAAf,cAAA,EAAgC,SAAAe,yBAAAhB,UAAA,GAAuDlH,OAAAC,eAAA8H,OAAAG,WAAA7B,IAAA6B,aAA+D,gBAAAxB,YAAAyB,WAAAC,aAA2L,MAAlID,aAAAL,iBAAApB,YAAAJ,UAAA6B,YAAqEC,aAAAN,iBAAApB,YAAA0B,aAA6D1B,gBAEzhB2B,KAAA,SAAA2T,GAAAC,IAAA3T,KAA0D,IAAnB,GAAAG,SAAA,EAAmBA,QAAA,CAA4B,GAAAf,QAAAsU,GAAAtT,SAAAuT,IAAAtT,SAAAL,GAAiDG,SAAA,EAAgB,OAAAf,gBAAAkB,SAAAtC,UAAkD,IAAAuC,MAAA7I,OAAA8I,yBAAApB,OAAAgB,SAA8D,IAAAnD,SAAAsD,KAAA,CAAuO,YAAAA,MAA4B,MAAAA,MAAA3I,KAA4B,IAAA6I,QAAAF,KAAA7G,GAAuB,IAAAuD,SAAAwD,OAA4B,MAAoB,OAAAA,QAAAzK,KAAAqK,UAA5U,GAAAK,QAAAhJ,OAAAiJ,eAAAvB,OAA4C,WAAAsB,OAAuB,MAA2BgT,IAAAhT,OAAaiT,IAAAvT,SAAgBJ,IAAAK,SAAgBF,QAAA,EAAeI,KAAAG,OAAAzD,SAQ3b2D,QAAAnL,oBAAA,IAEAoL,SAAAzK,uBAAAwK,SAEAE,QAAArL,oBAAA,IAEAsL,SAAA3K,uBAAA0K,SAEAK,MAAA1L,oBAAA,IAEA0J,OAAA/I,uBAAA+K,OAEAG,SAAA7L,oBAAA,IAUAme,QAAA,SAAAnR,UAGA,QAAAmR,SAAAnY,KAAA+K,SACA,GAAA5D,OAAAC,IAEA3E,iBAAA2E,KAAA+Q,SAEA7T,KAAArI,OAAAiJ,eAAAiT,QAAA5V,WAAA,cAAA6E,MAAA7M,KAAA6M,MAGAA,KAAApH,UACAoH,KAAA2D,QAAA,KAEA3D,KAAAzK,OACAkS,QAAA,GAIAzH,KAAAgR,QAAArN,SAGA3D,KAAA0G,QAAA,SAAA3P,GACA,IAAAgJ,MAAAxK,MAAAkS,OAAA,CAEA,GAAAwJ,cAAAlR,MAAAmR,iBAEA,UAAAzS,SAAAwJ,aAAAlR,EAAAb,KAAAwN,MAAAuN,cAAAlR,MAAAqC,KAAA,mBAGApC,KAAApH,KAAA9B,GAAA,SAAAkJ,KAAA0G,SAkGA,MA/HAjL,WAAAsV,QAAAnR,UAsCAlD,aAAAqU,UACA7V,IAAA,kBACAnG,MAAA,WACA,GAAAuM,QAAAtB,KAEAmR,SAAAtc,OAAAuO,KAAApD,KAAA2D,SAAAhK,IAAA,SAAA+H,GACA,GAAA+C,GAAAnD,OAAAqC,QAAAjC,EAGA,OAAA+C,aAAAvG,UAAA,WAAAuG,EAAA/B,WAEApB,OAAAqC,QAAAjC,IAGA,OAAAyP,UAAA/F,OAAA,SAAAgG,GAAA9d,GAQA,GALAA,KAAAqO,OAAArO,GAGAgJ,OAAA,WAAAuL,YAAAvU,QAAA,EAAAmL,SAAAK,OAAAwC,OAAA1I,KAAA+H,MAAArN,GAAAoP,aAEApP,EAAA,MAAA8d,GAGA,IAAAxO,YAAAtG,OAAA,WAAAsG,WAAAtB,OAAA1I,KAAA6H,SAAAnN,EAEA,OAAAsP,YAAAwO,GAAAzP,QAAA,EAAAlD,SAAAK,OAAAwC,OAAA1I,KAAA6H,SAAAmC,YAAA1M,KAAA8S,gBAEAoI,GAAAzP,QAAArO,YAUA4H,IAAA,aACAnG,MAAA,WACA,GAAAwN,QAAAvC,KAEAtG,UAQA,OANA7E,QAAAuO,KAAApD,KAAA2D,SAAAxJ,QAAA,SAAAuH,GACA,GAAAtF,MAAAmG,OAAAoB,QAAAjC,EAEAtF,gBAAA8B,UAAA,WAAAxE,QAAAgI,GAAAtF,KAAmE1C,QAAAgI,GAAAa,OAAA3J,KAAAjC,OAAAyF,QAGnE1C,WAUAwB,IAAA,UACAnG,MAAA,SAAA4O,SAEA,IAAArH,OAAA,WAAA+Q,eAAA1J,SAAA,QAAAlF,SAAAM,WAAA,kCAAuH4E,iBAEvH3D,MAAA2D,eAGA,IAAAiG,cAEA,QAAAlI,KAAAiC,SACAiG,WAAAlI,GAAAiC,QAAAjC,YAAAxD,UAAA,WAAAyF,QAAAjC,GAAAtF,KAAAuH,QAAAjC,EACO1B,MAAAnJ,IAAAmJ,KAAApH,KAAAqT,QAAAvD,KAAA1I,KAAApH,KAAAgR,eAOP1O,IAAA,UACAnG,MAAA,WAEAiL,KAAApH,KAAAsN,IAAA,SAAAlG,KAAA0G,SACA1G,KAAAzK,MAAAkS,QAAA,EACAzH,KAAA4D,WAIAmN,SACC/S,SAAA,WAEDjL,SAAA,WAAAge,QACA/d,OAAAD,gBAAA,YvB01HM,SAASC,OAAQD,SAEtB,YAEA8B,QAAOC,eAAe/B,QAAS,cAC3BgC,OAAO,GwBhhIChC,SAAAuF,4BAA8B,SAACrF,IACxC,GAAIoe,2BACApd,QAAO8E,aAAaC,QAAQ,qBAC5BqY,wBAA0BpY,KAAKC,MAAMjF,OAAO8E,aAAaC,QAAQ,qBAErEqY,wBAAwBhZ,KAAKpF,IAC7BgB,OAAO8E,aAAauY,QAAQ,kBAAmBrY,KAAKsY,UAAUF,2BAIrDte,QAAAmF,iCAAmC,SAACjF,IAC7C,GAAIoe,2BACApd,QAAO8E,aAAaC,QAAQ,qBAC5BqY,wBAA0BpY,KAAKC,MAAMjF,OAAO8E,aAAaC,QAAQ,qBAErEqY,wBAA0BA,wBAAwBla,OAAO,SAACc,GAAD,MAAOA,IAAKhF,KAErEgB,OAAO8E,aAAauY,QAAQ,kBAAmBrY,KAAKsY,UAAUF,2BAIrDte,QAAAmE,8BAAgC,WACzC,MAAIjD,QAAO8E,aAAaC,QAAQ,mBACrBC,KAAKC,MAAMjF,OAAO8E,aAAaC,QAAQ,yBxByhIhD,SAAShG,OAAQD,SyBhjIvBC,OAAAD,QAAA,mWzBsjIM,SAASC,OAAQD,S0BtjIvBC,OAAAD,QAAA,8gE1B4jIM,SAASC,OAAQD,QAASH,qB2BzjIhC,GAAA4e,SAAA5e,oBAAA,GACA,iBAAA4e,qBAAAxe,OAAAC,GAAAue,QAAA,KAEA5e,qBAAA,IAAA4e,WACAA,SAAAC,SAAAze,OAAAD,QAAAye,QAAAC,S3B+kIM,SAASze,OAAQD,QAASH,qB4BtlIhCG,QAAAC,OAAAD,QAAAH,oBAAA,MAKAG,QAAAsF,MAAArF,OAAAC,GAAA,4hBAAmjB,M5B+lI7iB,SAASD,OAAQD,S6B/lIvBC,OAAAD,QAAA,WACA,GAAAwW,QA0CA,OAvCAA,MAAAmI,SAAA,WAEA,OADAlY,WACAsD,EAAA,EAAgBA,EAAAkD,KAAAhG,OAAiB8C,IAAA,CACjC,GAAA0M,MAAAxJ,KAAAlD,EACA0M,MAAA,GACAhQ,OAAAnB,KAAA,UAAAmR,KAAA,OAAwCA,KAAA,QAExChQ,OAAAnB,KAAAmR,KAAA,IAGA,MAAAhQ,QAAAiD,KAAA,KAIA8M,KAAAzM,EAAA,SAAAnK,QAAAgf,YACA,gBAAAhf,WACAA,UAAA,KAAAA,QAAA,KAEA,QADAif,2BACA9U,EAAA,EAAgBA,EAAAkD,KAAAhG,OAAiB8C,IAAA,CACjC,GAAA7J,IAAA+M,KAAAlD,GAAA,EACA,iBAAA7J,MACA2e,uBAAA3e,KAAA,GAEA,IAAA6J,EAAA,EAAYA,EAAAnK,QAAAqH,OAAoB8C,IAAA,CAChC,GAAA0M,MAAA7W,QAAAmK,EAKA,iBAAA0M,MAAA,IAAAoI,uBAAApI,KAAA,MACAmI,aAAAnI,KAAA,GACAA,KAAA,GAAAmI,WACKA,aACLnI,KAAA,OAAAA,KAAA,aAAAmI,WAAA,KAEApI,KAAAlR,KAAAmR,SAIAD,O7B4mIM,SAASvW,OAAQD,QAASH,qB8B/lIhC,QAAAif,gBAAAC,OAAA3R,SACA,OAAArD,GAAA,EAAeA,EAAAgV,OAAA9X,OAAmB8C,IAAA,CAClC,GAAA0M,MAAAsI,OAAAhV,GACAiV,SAAAC,YAAAxI,KAAAvW,GACA,IAAA8e,SAAA,CACAA,SAAAE,MACA,QAAAtL,GAAA,EAAiBA,EAAAoL,SAAAG,MAAAlY,OAA2B2M,IAC5CoL,SAAAG,MAAAvL,GAAA6C,KAAA0I,MAAAvL,GAEA,MAAQA,EAAA6C,KAAA0I,MAAAlY,OAAuB2M,IAC/BoL,SAAAG,MAAA7Z,KAAA8Z,SAAA3I,KAAA0I,MAAAvL,GAAAxG,cAEG,CAEH,OADA+R,UACAvL,EAAA,EAAiBA,EAAA6C,KAAA0I,MAAAlY,OAAuB2M,IACxCuL,MAAA7Z,KAAA8Z,SAAA3I,KAAA0I,MAAAvL,GAAAxG,SAEA6R,aAAAxI,KAAAvW,KAA2BA,GAAAuW,KAAAvW,GAAAgf,KAAA,EAAAC,eAK3B,QAAAE,cAAA7I,MAGA,OAFAuI,WACAO,aACAvV,EAAA,EAAeA,EAAAyM,KAAAvP,OAAiB8C,IAAA,CAChC,GAAA0M,MAAAD,KAAAzM,GACA7J,GAAAuW,KAAA,GACA8I,IAAA9I,KAAA,GACA+I,MAAA/I,KAAA,GACAgJ,UAAAhJ,KAAA,GACAiJ,MAAcH,QAAAC,YAAAC,oBACdH,WAAApf,IAGAof,UAAApf,IAAAif,MAAA7Z,KAAAoa,MAFAX,OAAAzZ,KAAAga,UAAApf,KAAgCA,MAAAif,OAAAO,QAIhC,MAAAX,QAGA,QAAAY,oBAAAvS,QAAAwS,cACA,GAAAC,MAAAC,iBACAC,8BAAAC,sDAAA/Y,OAAA,EACA,YAAAmG,QAAA6S,SACAF,8BAEGA,8BAAAG,YACHL,KAAAM,aAAAP,aAAAG,8BAAAG,aAEAL,KAAAO,YAAAR,cAJAC,KAAAM,aAAAP,aAAAC,KAAAQ,YAMAL,2BAAA1a,KAAAsa,kBACE,eAAAxS,QAAA6S,SAGF,SAAA9R,OAAA,qEAFA0R,MAAAO,YAAAR,eAMA,QAAAU,oBAAAV,cACAA,aAAAW,WAAAC,YAAAZ,aACA,IAAA/C,KAAAmD,2BAAA1b,QAAAsb,aACA/C,MAAA,GACAmD,2BAAAlM,OAAA+I,IAAA,GAIA,QAAA4D,oBAAArT,SACA,GAAAwS,cAAAc,SAAAC,cAAA,QAGA,OAFAf,cAAAlR,KAAA,WACAiR,mBAAAvS,QAAAwS,cACAA,aAGA,QAAAgB,mBAAAxT,SACA,GAAAyT,aAAAH,SAAAC,cAAA,OAGA,OAFAE,aAAAC,IAAA,aACAnB,mBAAAvS,QAAAyT,aACAA,YAGA,QAAAzB,UAAA3e,IAAA2M,SACA,GAAAwS,cAAApL,OAAAuM,MAEA,IAAA3T,QAAA4T,UAAA,CACA,GAAAC,YAAAC,kBACAtB,cAAAuB,oCAAAV,mBAAArT;AACAoH,OAAA4M,oBAAAzL,KAAA,KAAAiK,aAAAqB,YAAA,GACAF,OAAAK,oBAAAzL,KAAA,KAAAiK,aAAAqB,YAAA,OACExgB,KAAAgf,WACF,kBAAA4B,MACA,kBAAAA,KAAAC,iBACA,kBAAAD,KAAAE,iBACA,kBAAAC,OACA,kBAAAC,OACA7B,aAAAgB,kBAAAxT,SACAoH,OAAAkN,WAAA/L,KAAA,KAAAiK,cACAmB,OAAA,WACAT,mBAAAV,cACAA,aAAA+B,MACAN,IAAAE,gBAAA3B,aAAA+B,SAGA/B,aAAAa,mBAAArT,SACAoH,OAAAoN,WAAAjM,KAAA,KAAAiK,cACAmB,OAAA,WACAT,mBAAAV,eAMA,OAFApL,QAAA/T,KAEA,SAAAyH,QACA,GAAAA,OAAA,CACA,GAAAA,OAAAqX,MAAA9e,IAAA8e,KAAArX,OAAAsX,QAAA/e,IAAA+e,OAAAtX,OAAAuX,YAAAhf,IAAAgf,UACA,MACAjL,QAAA/T,IAAAyH,YAEA6Y,WAcA,QAAAK,qBAAAxB,aAAArE,MAAAwF,OAAAtgB,KACA,GAAA8e,KAAAwB,OAAA,GAAAtgB,IAAA8e,GAEA,IAAAK,aAAAiC,WACAjC,aAAAiC,WAAAC,QAAAC,YAAAxG,MAAAgE,SACE,CACF,GAAAyC,SAAAtB,SAAAuB,eAAA1C,KACA2C,WAAAtC,aAAAsC,UACAA,YAAA3G,QAAAqE,aAAAY,YAAA0B,WAAA3G,QACA2G,WAAAjb,OACA2Y,aAAAO,aAAA6B,QAAAE,WAAA3G,QAEAqE,aAAAQ,YAAA4B,UAKA,QAAAJ,YAAAhC,aAAAnf,KACA,GAAA8e,KAAA9e,IAAA8e,IACAC,MAAA/e,IAAA+e,KAMA,IAJAA,OACAI,aAAAuC,aAAA,QAAA3C,OAGAI,aAAAiC,WACAjC,aAAAiC,WAAAC,QAAAvC,QACE,CACF,KAAAK,aAAAS,YACAT,aAAAY,YAAAZ,aAAAS,WAEAT,cAAAQ,YAAAM,SAAAuB,eAAA1C,OAIA,QAAAmC,YAAAb,YAAApgB,KACA,GAAA8e,KAAA9e,IAAA8e,IACAE,UAAAhf,IAAAgf,SAEAA,aAEAF,KAAA,uDAAuDkC,KAAAW,SAAAC,mBAAAnc,KAAAsY,UAAAiB,cAAA,MAGvD,IAAA6C,MAAA,GAAAd,OAAAjC,MAA6B7Q,KAAA,aAE7B6T,OAAA1B,YAAAc,IAEAd,aAAAc,KAAAN,IAAAC,gBAAAgB,MAEAC,QACAlB,IAAAE,gBAAAgB,QAhPA,GAAAtD,gBACAuD,QAAA,SAAA1Q,IACA,GAAA2Q,KACA,mBAEA,MADA,mBAAAA,aAAA3Q,GAAA9D,MAAAf,KAAAC,YACAuV,OAGAC,QAAAF,QAAA,WACA,qBAAAzS,KAAA7O,OAAAyhB,UAAAC,UAAAC,iBAEA/C,eAAA0C,QAAA,WACA,MAAA9B,UAAAb,MAAAa,SAAAoC,qBAAA,aAEA3B,iBAAA,KACAD,iBAAA,EACAlB,6BAEA/f,QAAAD,QAAA,SAAAwW,KAAApJ,SAEA,mBAAAsT,UAAA,SAAAvS,OAAA,+DAGAf,qBAGA,mBAAAA,SAAA4T,YAAA5T,QAAA4T,UAAA0B,WAGA,mBAAAtV,SAAA6S,WAAA7S,QAAA6S,SAAA,SAEA,IAAAlB,QAAAM,aAAA7I,KAGA,OAFAsI,gBAAAC,OAAA3R,SAEA,SAAA2V,SAEA,OADAC,cACAjZ,EAAA,EAAgBA,EAAAgV,OAAA9X,OAAmB8C,IAAA,CACnC,GAAA0M,MAAAsI,OAAAhV,GACAiV,SAAAC,YAAAxI,KAAAvW,GACA8e,UAAAE,OACA8D,UAAA1d,KAAA0Z,UAEA,GAAA+D,QAAA,CACA,GAAAzD,WAAAD,aAAA0D,QACAjE,gBAAAQ,UAAAlS,SAEA,OAAArD,GAAA,EAAgBA,EAAAiZ,UAAA/b,OAAsB8C,IAAA,CACtC,GAAAiV,UAAAgE,UAAAjZ,EACA,QAAAiV,SAAAE,KAAA,CACA,OAAAtL,GAAA,EAAkBA,EAAAoL,SAAAG,MAAAlY,OAA2B2M,IAC7CoL,SAAAG,MAAAvL,WACAqL,aAAAD,SAAA9e,OAiIA,IAAA6hB,aAAA,WACA,GAAAkB,aAEA,iBAAA1H,MAAA2H,aAEA,MADAD,WAAA1H,OAAA2H,YACAD,UAAA7e,OAAA+e,SAAAzZ,KAAA,W9B2tIM,SAASzJ,OAAQD,QAASH,qBAE/B,YAEAiC,QAAOC,eAAe/B,QAAS,cAC3BgC,OAAO,IAGXhC,mB+Bh6Ic,SAAC2B,eAAgBC,oBAC5BD,eAGKa,MAAM,OACHC,IAAK,OACL2gB,YAAU,EACVxgB,SAAU/C,oBAAQ,Q/Bs6IxB,SAASI,OAAQD,SgC76IvBC,OAAAD,QAAA,wfhCm7IM,SAASC,OAAQD,QAASH,qBiCh7IhC,GAAA4e,SAAA5e,oBAAA,GACA,iBAAA4e,qBAAAxe,OAAAC,GAAAue,QAAA,KAEA5e,qBAAA,IAAA4e,WACAA,SAAAC,SAAAze,OAAAD,QAAAye,QAAAC,SjCs8IM,SAASze,OAAQD,QAASH,qBkC78IhCG,QAAAC,OAAAD,QAAAH,oBAAA,MAKAG,QAAAsF,MAAArF,OAAAC,GAAA,kEAAyF,MlCs9InF,SAASD,OAAQD,QAASH,qBmCx9IhC,GAAA4e,SAAA5e,oBAAA,GACA,iBAAA4e,qBAAAxe,OAAAC,GAAAue,QAAA,KAEA5e,qBAAA,IAAA4e,WACAA,SAAAC,SAAAze,OAAAD,QAAAye,QAAAC,SnC8+IM,SAASze,OAAQD,QAASH,qBoCr/IhCG,QAAAC,OAAAD,QAAAH,oBAAA,MAKAG,QAAAsF,MAAArF,OAAAC,GAAA","file":"bundle.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _components = __webpack_require__(1);\n\t\n\tvar _components2 = _interopRequireDefault(_components);\n\t\n\t__webpack_require__(33);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tangular.module('app', ['ionic', _components2.default]).run(function ($ionicPlatform) {\n\t    $ionicPlatform.ready(function () {\n\t        // Hide the accessory bar by default (remove this to show the accessory bar above the keyboard\n\t        // for form inputs)\n\t        if (window.cordova && window.cordova.plugins && window.cordova.plugins.Keyboard) {\n\t            cordova.plugins.Keyboard.hideKeyboardAccessoryBar(true);\n\t            cordova.plugins.Keyboard.disableScroll(true);\n\t        }\n\t        if (window.StatusBar) {\n\t            // org.apache.cordova.statusbar required\n\t            StatusBar.styleDefault();\n\t        }\n\t    });\n\t}).config(function ($stateProvider, $urlRouterProvider) {\n\t    $urlRouterProvider.otherwise('/tab/dash');\n\t});\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _tabs = __webpack_require__(2);\n\t\n\tvar _tabs2 = _interopRequireDefault(_tabs);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = angular.module('app.components', [_tabs2.default]).name;\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _dashboard = __webpack_require__(3);\n\t\n\tvar _dashboard2 = _interopRequireDefault(_dashboard);\n\t\n\tvar _tabs = __webpack_require__(29);\n\t\n\tvar _tabs2 = _interopRequireDefault(_tabs);\n\t\n\t__webpack_require__(31);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = angular.module('app.components.tabs', [_dashboard2.default]).config(_tabs2.default).name;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _dashboard = __webpack_require__(4);\n\t\n\tvar _dashboard2 = _interopRequireDefault(_dashboard);\n\t\n\t__webpack_require__(25);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = angular.module('app.components.tabs.dashboard', []).config(_dashboard2.default).name;\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _dashboard = __webpack_require__(5);\n\t\n\tvar _dashboard2 = _interopRequireDefault(_dashboard);\n\t\n\tvar _dashboard3 = __webpack_require__(24);\n\t\n\tvar _dashboard4 = _interopRequireDefault(_dashboard3);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = function ($stateProvider, $urlRouterProvider) {\n\t    $stateProvider.state('tab.dash', {\n\t        url: '/dash',\n\t        views: {\n\t            'tab-dash': {\n\t                template: _dashboard4.default,\n\t                controller: _dashboard2.default\n\t            }\n\t        }\n\t    });\n\t};\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _store = __webpack_require__(6);\n\t\n\tvar _store2 = _interopRequireDefault(_store);\n\t\n\tvar _subscriptionIds = __webpack_require__(22);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar locationModalTemplate = __webpack_require__(23);\n\t\n\tvar connectSubscriptions = function connectSubscriptions(data, scope, $timeout) {\n\t    $timeout(function () {\n\t        scope.currentData = scope.forecastData = data;\n\t    });\n\t};\n\t\n\tvar connectLocations = function connectLocations(data, scope, $timeout) {\n\t    $timeout(function () {\n\t        scope.locations = data;\n\t    });\n\t};\n\t\n\texports.default = ['$scope', '$timeout', '$ionicModal', function (scope, $timeout, $ionicModal) {\n\t    var subscriptionSelector = _store2.default.select('subscriptions', 'subscribedLocations');\n\t    var locationSelector = _store2.default.select('locations');\n\t    connectSubscriptions(subscriptionSelector.get(), scope, $timeout);\n\t    subscriptionSelector.on('update', function (e) {\n\t        connectSubscriptions(e.data.currentData, scope, $timeout);\n\t    });\n\t\n\t    locationSelector.on('update', function (e) {\n\t        connectLocations(e.data.currentData, scope, $timeout);\n\t    });\n\t\n\t    scope.getLocationsForModal = function () {\n\t        if (!scope.locations) return [];\n\t        var existingIds = (0, _subscriptionIds.getSubscriptionIdsFromStorage)();\n\t        return scope.locations.filter(function (d) {\n\t            return existingIds.indexOf(d.id) == -1;\n\t        });\n\t    };\n\t\n\t    scope.modal = $ionicModal.fromTemplate(locationModalTemplate, {\n\t        scope: scope,\n\t        animation: 'none'\n\t    });\n\t\n\t    scope.showAddLocation = function () {\n\t        scope.modal.show();\n\t    };\n\t\n\t    scope.closeModal = function () {\n\t        scope.modal.hide();\n\t    };\n\t\n\t    scope.removeLocation = function (id) {\n\t        var idsSelector = _store2.default.select([\"subscriptions\", \"ids\"]);\n\t        var existingIDs = idsSelector.get();\n\t        idsSelector.set(existingIDs.filter(function (l) {\n\t            return l != id;\n\t        }));\n\t        (0, _subscriptionIds.removeFromSubscriptionIdsStorage)(id);\n\t    };\n\t\n\t    scope.addLocation = function (location) {\n\t        _store2.default.push([\"subscriptions\", \"ids\"], location.id);\n\t        (0, _subscriptionIds.addToSubscriptionIdsStorage)(location.id);\n\t        scope.modal.hide();\n\t    };\n\t}];\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _consts = __webpack_require__(7);\n\t\n\tvar _subscriptionData = __webpack_require__(8);\n\t\n\tvar _subscriptionData2 = _interopRequireDefault(_subscriptionData);\n\t\n\tvar _mockApi = __webpack_require__(10);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar Baobab = __webpack_require__(14);\n\t\n\tvar tree = new Baobab({\n\t    locations: {},\n\t    subscriptions: {\n\t        ids: window.localStorage.getItem(\"subscriptionIds\") ? JSON.parse(window.localStorage.getItem(\"subscriptionIds\")) : _consts.default_subscriptions,\n\t        data: [],\n\t        subscribedLocations: _subscriptionData2.default\n\t    }\n\t}, {\n\t    immutable: false\n\t});\n\texports.default = tree;\n\t\n\t\n\t(0, _mockApi.fetchLocations)().then(function (result) {\n\t    tree.set(\"locations\", result);\n\t});\n\n/***/ },\n/* 7 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\tvar default_subscriptions = exports.default_subscriptions = [];\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _subscriptionData = __webpack_require__(9);\n\t\n\tvar _subscriptionData2 = _interopRequireDefault(_subscriptionData);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar Baobab = __webpack_require__(14);\n\tvar monkey = Baobab.monkey;\n\texports.default = monkey({\n\t    cursors: {\n\t        ids: ['subscriptions', 'ids'],\n\t        data: ['subscriptions', 'data']\n\t    },\n\t    get: function get(state) {\n\t        var result = state.ids.map(function (id) {\n\t            var data = state.data[id];\n\t            return data || { id: id, loading: true };\n\t        });\n\t        (0, _subscriptionData2.default)(result.filter(function (r) {\n\t            return r.loading;\n\t        }));\n\t        return result;\n\t    }\n\t});\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _index = __webpack_require__(6);\n\t\n\tvar _index2 = _interopRequireDefault(_index);\n\t\n\tvar _mockApi = __webpack_require__(10);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = function (ids) {\n\t    if (ids.length == 0) return null;\n\t    var dataSelector = _index2.default.select('subscriptions', 'data');\n\t    (0, _mockApi.fetchLocationsData)(ids).then(function (data) {\n\t        data.forEach(function (d) {\n\t            dataSelector.set(d.id, d);\n\t        });\n\t    });\n\t};\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.fetchLocations = exports.fetchLocationsData = undefined;\n\t\n\tvar _config = __webpack_require__(11);\n\t\n\tvar _config2 = _interopRequireDefault(_config);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar locationsData = __webpack_require__(12);\n\tvar locations = __webpack_require__(13);\n\tvar fetchLocationsData = exports.fetchLocationsData = function fetchLocationsData(ids) {\n\t    return new Promise(function (resolve) {\n\t        resolve(locationsData);\n\t    });\n\t};\n\t\n\tvar fetchLocations = exports.fetchLocations = function fetchLocations() {\n\t    return new Promise(function (resolve) {\n\t        resolve(locations);\n\t    });\n\t};\n\n/***/ },\n/* 11 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.default = {\n\t    apiUrl: 'http://some.url.to.api'\n\t};\n\n/***/ },\n/* 12 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tmodule.exports = [{\n\t    \"id\": 1,\n\t    \"location\": \"tel-aviv\",\n\t    \"time\": \"08:00\",\n\t    \"wind\": \"8 Kts\",\n\t    \"windDirection\": \"N\",\n\t    \"temp\": \"28\",\n\t    \"wave\": \"0.5/7s\",\n\t    \"waveDirection\": \"N\"\n\t}, {\n\t    \"id\": 2,\n\t    \"location\": \"haifa\",\n\t    \"time\": \"08:00\",\n\t    \"wind\": \"8 Kts\",\n\t    \"windDirection\": \"N\",\n\t    \"temp\": \"28\",\n\t    \"wave\": \"0.5/7s\",\n\t    \"waveDirection\": \"N\"\n\t}, {\n\t    \"id\": 3,\n\t    \"location\": \"kineret\",\n\t    \"time\": \"08:00\",\n\t    \"wind\": \"8 Kts\",\n\t    \"windDirection\": \"N\",\n\t    \"temp\": \"28\",\n\t    \"wave\": \"0.5 / 7sec\",\n\t    \"waveDirection\": \"N\"\n\t}, {\n\t    \"id\": 4,\n\t    \"location\": \"bat-yam\",\n\t    \"time\": \"08:00\",\n\t    \"wind\": \"8 Kts\",\n\t    \"windDirection\": \"N\",\n\t    \"temp\": \"28\",\n\t    \"wave\": \"0.5 / 7sec\",\n\t    \"waveDirection\": \"N\"\n\t}];\n\n/***/ },\n/* 13 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tmodule.exports = [{ \"id\": 1, \"name\": \"tel-aviv\" }, { \"id\": 2, \"name\": \"haifa\" }, { \"id\": 3, \"name\": \"kineret\" }, { \"id\": 4, \"name\": \"bat-yam\" }];\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Baobab Data Structure\n\t * ======================\n\t *\n\t * A handy data tree with cursors.\n\t */\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\t\n\tvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\t\n\tvar _get = function get(_x3, _x4, _x5) { var _again = true; _function: while (_again) { var object = _x3, property = _x4, receiver = _x5; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x3 = parent; _x4 = property; _x5 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar _emmett = __webpack_require__(15);\n\t\n\tvar _emmett2 = _interopRequireDefault(_emmett);\n\t\n\tvar _cursor = __webpack_require__(16);\n\t\n\tvar _cursor2 = _interopRequireDefault(_cursor);\n\t\n\tvar _monkey = __webpack_require__(17);\n\t\n\tvar _watcher = __webpack_require__(21);\n\t\n\tvar _watcher2 = _interopRequireDefault(_watcher);\n\t\n\tvar _type = __webpack_require__(18);\n\t\n\tvar _type2 = _interopRequireDefault(_type);\n\t\n\tvar _update2 = __webpack_require__(19);\n\t\n\tvar _update3 = _interopRequireDefault(_update2);\n\t\n\tvar _helpers = __webpack_require__(20);\n\t\n\tvar helpers = _interopRequireWildcard(_helpers);\n\t\n\tvar arrayFrom = helpers.arrayFrom;\n\tvar coercePath = helpers.coercePath;\n\tvar deepFreeze = helpers.deepFreeze;\n\tvar getIn = helpers.getIn;\n\tvar makeError = helpers.makeError;\n\tvar deepClone = helpers.deepClone;\n\tvar deepMerge = helpers.deepMerge;\n\tvar shallowClone = helpers.shallowClone;\n\tvar shallowMerge = helpers.shallowMerge;\n\tvar uniqid = helpers.uniqid;\n\t\n\t/**\n\t * Baobab defaults\n\t */\n\tvar DEFAULTS = {\n\t\n\t  // Should the tree handle its transactions on its own?\n\t  autoCommit: true,\n\t\n\t  // Should the transactions be handled asynchronously?\n\t  asynchronous: true,\n\t\n\t  // Should the tree's data be immutable?\n\t  immutable: true,\n\t\n\t  // Should the monkeys be lazy?\n\t  lazyMonkeys: true,\n\t\n\t  // Should the tree be persistent?\n\t  persistent: true,\n\t\n\t  // Should the tree's update be pure?\n\t  pure: true,\n\t\n\t  // Validation specifications\n\t  validate: null,\n\t\n\t  // Validation behavior 'rollback' or 'notify'\n\t  validationBehavior: 'rollback'\n\t};\n\t\n\t/**\n\t * Function returning a string hash from a non-dynamic path expressed as an\n\t * array.\n\t *\n\t * @param  {array}  path - The path to hash.\n\t * @return {string} string - The resultant hash.\n\t */\n\tfunction hashPath(path) {\n\t  return '' + path.map(function (step) {\n\t    if (_type2['default']['function'](step) || _type2['default'].object(step)) return '#' + uniqid() + '#';\n\t\n\t    return step;\n\t  }).join('');\n\t}\n\t\n\t/**\n\t * Baobab class\n\t *\n\t * @constructor\n\t * @param {object|array} [initialData={}]    - Initial data passed to the tree.\n\t * @param {object}       [opts]              - Optional options.\n\t * @param {boolean}      [opts.autoCommit]   - Should the tree auto-commit?\n\t * @param {boolean}      [opts.asynchronous] - Should the tree's transactions\n\t *                                             handled asynchronously?\n\t * @param {boolean}      [opts.immutable]    - Should the tree be immutable?\n\t * @param {boolean}      [opts.persistent]   - Should the tree be persistent?\n\t * @param {boolean}      [opts.pure]         - Should the tree be pure?\n\t * @param {function}     [opts.validate]     - Validation function.\n\t * @param {string}       [opts.validationBehaviour] - \"rollback\" or \"notify\".\n\t */\n\t\n\tvar Baobab = (function (_Emitter) {\n\t  _inherits(Baobab, _Emitter);\n\t\n\t  function Baobab(initialData, opts) {\n\t    var _this = this;\n\t\n\t    _classCallCheck(this, Baobab);\n\t\n\t    _get(Object.getPrototypeOf(Baobab.prototype), 'constructor', this).call(this);\n\t\n\t    // Setting initialData to an empty object if no data is provided by use\n\t    if (arguments.length < 1) initialData = {};\n\t\n\t    // Checking whether given initial data is valid\n\t    if (!_type2['default'].object(initialData) && !_type2['default'].array(initialData)) throw makeError('Baobab: invalid data.', { data: initialData });\n\t\n\t    // Merging given options with defaults\n\t    this.options = shallowMerge({}, DEFAULTS, opts);\n\t\n\t    // Disabling immutability & persistence if persistence if disabled\n\t    if (!this.options.persistent) {\n\t      this.options.immutable = false;\n\t      this.options.pure = false;\n\t    }\n\t\n\t    // Privates\n\t    this._identity = '[object Baobab]';\n\t    this._cursors = {};\n\t    this._future = null;\n\t    this._transaction = [];\n\t    this._affectedPathsIndex = {};\n\t    this._monkeys = {};\n\t    this._previousData = null;\n\t    this._data = initialData;\n\t\n\t    // Properties\n\t    this.root = new _cursor2['default'](this, [], '');\n\t    delete this.root.release;\n\t\n\t    // Does the user want an immutable tree?\n\t    if (this.options.immutable) deepFreeze(this._data);\n\t\n\t    // Bootstrapping root cursor's getters and setters\n\t    var bootstrap = function bootstrap(name) {\n\t      _this[name] = function () {\n\t        var r = this.root[name].apply(this.root, arguments);\n\t        return r instanceof _cursor2['default'] ? this : r;\n\t      };\n\t    };\n\t\n\t    ['apply', 'clone', 'concat', 'deepClone', 'deepMerge', 'exists', 'get', 'push', 'merge', 'pop', 'project', 'serialize', 'set', 'shift', 'splice', 'unset', 'unshift'].forEach(bootstrap);\n\t\n\t    // Registering the initial monkeys\n\t    this._refreshMonkeys();\n\t\n\t    // Initial validation\n\t    var validationError = this.validate();\n\t\n\t    if (validationError) throw Error('Baobab: invalid data.', { error: validationError });\n\t  }\n\t\n\t  /**\n\t   * Monkey helper.\n\t   */\n\t\n\t  /**\n\t   * Internal method used to refresh the tree's monkey register on every\n\t   * update.\n\t   * Note 1) For the time being, placing monkeys beneath array nodes is not\n\t   * allowed for performance reasons.\n\t   *\n\t   * @param  {mixed}   node      - The starting node.\n\t   * @param  {array}   path      - The starting node's path.\n\t   * @param  {string}  operation - The operation that lead to a refreshment.\n\t   * @return {Baobab}            - The tree instance for chaining purposes.\n\t   */\n\t\n\t  _createClass(Baobab, [{\n\t    key: '_refreshMonkeys',\n\t    value: function _refreshMonkeys(node, path, operation) {\n\t      var _this2 = this;\n\t\n\t      var clean = function clean(data) {\n\t        var p = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];\n\t\n\t        if (data instanceof _monkey.Monkey) {\n\t          data.release();\n\t          (0, _update3['default'])(_this2._monkeys, p, { type: 'unset' }, {\n\t            immutable: false,\n\t            persistent: false,\n\t            pure: false\n\t          });\n\t\n\t          return;\n\t        }\n\t\n\t        if (_type2['default'].object(data)) {\n\t          for (var k in data) {\n\t            clean(data[k], p.concat(k));\n\t          }\n\t        }\n\t      };\n\t\n\t      var walk = function walk(data) {\n\t        var p = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];\n\t\n\t        // Should we sit a monkey in the tree?\n\t        if (data instanceof _monkey.MonkeyDefinition || data instanceof _monkey.Monkey) {\n\t          var monkeyInstance = new _monkey.Monkey(_this2, p, data instanceof _monkey.Monkey ? data.definition : data);\n\t\n\t          (0, _update3['default'])(_this2._monkeys, p, { type: 'set', value: monkeyInstance }, {\n\t            immutable: false,\n\t            persistent: false,\n\t            pure: false\n\t          });\n\t\n\t          return;\n\t        }\n\t\n\t        // Object iteration\n\t        if (_type2['default'].object(data)) {\n\t          for (var k in data) {\n\t            walk(data[k], p.concat(k));\n\t          }\n\t        }\n\t      };\n\t\n\t      // Walking the whole tree\n\t      if (!arguments.length) {\n\t        walk(this._data);\n\t      } else {\n\t        var monkeysNode = getIn(this._monkeys, path).data;\n\t\n\t        // Is this required that we clean some already existing monkeys?\n\t        if (monkeysNode) clean(monkeysNode, path);\n\t\n\t        // Let's walk the tree only from the updated point\n\t        if (operation !== 'unset') {\n\t          walk(node, path);\n\t        }\n\t      }\n\t\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Method used to validate the tree's data.\n\t     *\n\t     * @return {boolean} - Is the tree valid?\n\t     */\n\t  }, {\n\t    key: 'validate',\n\t    value: function validate(affectedPaths) {\n\t      var _options = this.options;\n\t      var validate = _options.validate;\n\t      var behavior = _options.validationBehavior;\n\t\n\t      if (typeof validate !== 'function') return null;\n\t\n\t      var error = validate.call(this, this._previousData, this._data, affectedPaths || [[]]);\n\t\n\t      if (error instanceof Error) {\n\t\n\t        if (behavior === 'rollback') {\n\t          this._data = this._previousData;\n\t          this._affectedPathsIndex = {};\n\t          this._transaction = [];\n\t          this._previousData = this._data;\n\t        }\n\t\n\t        this.emit('invalid', { error: error });\n\t\n\t        return error;\n\t      }\n\t\n\t      return null;\n\t    }\n\t\n\t    /**\n\t     * Method used to select data within the tree by creating a cursor. Cursors\n\t     * are kept as singletons by the tree for performance and hygiene reasons.\n\t     *\n\t     * Arity (1):\n\t     * @param {path}    path - Path to select in the tree.\n\t     *\n\t     * Arity (*):\n\t     * @param {...step} path - Path to select in the tree.\n\t     *\n\t     * @return {Cursor}      - The resultant cursor.\n\t     */\n\t  }, {\n\t    key: 'select',\n\t    value: function select(path) {\n\t\n\t      // If no path is given, we simply return the root\n\t      path = path || [];\n\t\n\t      // Variadic\n\t      if (arguments.length > 1) path = arrayFrom(arguments);\n\t\n\t      // Checking that given path is valid\n\t      if (!_type2['default'].path(path)) throw makeError('Baobab.select: invalid path.', { path: path });\n\t\n\t      // Casting to array\n\t      path = [].concat(path);\n\t\n\t      // Computing hash (done here because it would be too late to do it in the\n\t      // cursor's constructor since we need to hit the cursors' index first).\n\t      var hash = hashPath(path);\n\t\n\t      // Creating a new cursor or returning the already existing one for the\n\t      // requested path.\n\t      var cursor = this._cursors[hash];\n\t\n\t      if (!cursor) {\n\t        cursor = new _cursor2['default'](this, path, hash);\n\t        this._cursors[hash] = cursor;\n\t      }\n\t\n\t      // Emitting an event to notify that a part of the tree was selected\n\t      this.emit('select', { path: path, cursor: cursor });\n\t      return cursor;\n\t    }\n\t\n\t    /**\n\t     * Method used to update the tree. Updates are simply expressed by a path,\n\t     * dynamic or not, and an operation.\n\t     *\n\t     * This is where path solving should happen and not in the cursor.\n\t     *\n\t     * @param  {path}   path      - The path where we'll apply the operation.\n\t     * @param  {object} operation - The operation to apply.\n\t     * @return {mixed} - Return the result of the update.\n\t     */\n\t  }, {\n\t    key: 'update',\n\t    value: function update(path, operation) {\n\t      var _this3 = this;\n\t\n\t      // Coercing path\n\t      path = coercePath(path);\n\t\n\t      if (!_type2['default'].operationType(operation.type)) throw makeError('Baobab.update: unknown operation type \"' + operation.type + '\".', { operation: operation });\n\t\n\t      // Solving the given path\n\t\n\t      var _getIn = getIn(this._data, path);\n\t\n\t      var solvedPath = _getIn.solvedPath;\n\t      var exists = _getIn.exists;\n\t\n\t      // If we couldn't solve the path, we throw\n\t      if (!solvedPath) throw makeError('Baobab.update: could not solve the given path.', {\n\t        path: solvedPath\n\t      });\n\t\n\t      // Read-only path?\n\t      var monkeyPath = _type2['default'].monkeyPath(this._monkeys, solvedPath);\n\t      if (monkeyPath && solvedPath.length > monkeyPath.length) throw makeError('Baobab.update: attempting to update a read-only path.', {\n\t        path: solvedPath\n\t      });\n\t\n\t      // We don't unset irrelevant paths\n\t      if (operation.type === 'unset' && !exists) return;\n\t\n\t      // If we merge data, we need to acknowledge monkeys\n\t      var realOperation = operation;\n\t      if (/merge/i.test(operation.type)) {\n\t        var monkeysNode = getIn(this._monkeys, solvedPath).data;\n\t\n\t        if (_type2['default'].object(monkeysNode)) {\n\t\n\t          // Cloning the operation not to create weird behavior for the user\n\t          realOperation = shallowClone(realOperation);\n\t\n\t          // Fetching the existing node in the current data\n\t          var currentNode = getIn(this._data, solvedPath).data;\n\t\n\t          if (/deep/i.test(realOperation.type)) realOperation.value = deepMerge({}, deepMerge({}, currentNode, deepClone(monkeysNode)), realOperation.value);else realOperation.value = shallowMerge({}, deepMerge({}, currentNode, deepClone(monkeysNode)), realOperation.value);\n\t        }\n\t      }\n\t\n\t      // Stashing previous data if this is the frame's first update\n\t      if (!this._transaction.length) this._previousData = this._data;\n\t\n\t      // Applying the operation\n\t      var result = (0, _update3['default'])(this._data, solvedPath, realOperation, this.options);\n\t\n\t      var data = result.data;\n\t      var node = result.node;\n\t\n\t      // If because of purity, the update was moot, we stop here\n\t      if (!('data' in result)) return node;\n\t\n\t      // If the operation is push, the affected path is slightly different\n\t      var affectedPath = solvedPath.concat(operation.type === 'push' ? node.length - 1 : []);\n\t\n\t      var hash = hashPath(affectedPath);\n\t\n\t      // Updating data and transaction\n\t      this._data = data;\n\t      this._affectedPathsIndex[hash] = true;\n\t      this._transaction.push(shallowMerge({}, operation, { path: affectedPath }));\n\t\n\t      // Updating the monkeys\n\t      this._refreshMonkeys(node, solvedPath, operation.type);\n\t\n\t      // Emitting a `write` event\n\t      this.emit('write', { path: affectedPath });\n\t\n\t      // Should we let the user commit?\n\t      if (!this.options.autoCommit) return node;\n\t\n\t      // Should we update asynchronously?\n\t      if (!this.options.asynchronous) {\n\t        this.commit();\n\t        return node;\n\t      }\n\t\n\t      // Updating asynchronously\n\t      if (!this._future) this._future = setTimeout(function () {\n\t        return _this3.commit();\n\t      }, 0);\n\t\n\t      // Finally returning the affected node\n\t      return node;\n\t    }\n\t\n\t    /**\n\t     * Method committing the updates of the tree and firing the tree's events.\n\t     *\n\t     * @return {Baobab} - The tree instance for chaining purposes.\n\t     */\n\t  }, {\n\t    key: 'commit',\n\t    value: function commit() {\n\t\n\t      // Do not fire update if the transaction is empty\n\t      if (!this._transaction.length) return this;\n\t\n\t      // Clearing timeout if one was defined\n\t      if (this._future) this._future = clearTimeout(this._future);\n\t\n\t      var affectedPaths = Object.keys(this._affectedPathsIndex).map(function (h) {\n\t        return h !== '' ? h.split('').slice(1) : [];\n\t      });\n\t\n\t      // Is the tree still valid?\n\t      var validationError = this.validate(affectedPaths);\n\t\n\t      if (validationError) return this;\n\t\n\t      // Caching to keep original references before we change them\n\t      var transaction = this._transaction,\n\t          previousData = this._previousData;\n\t\n\t      this._affectedPathsIndex = {};\n\t      this._transaction = [];\n\t      this._previousData = this._data;\n\t\n\t      // Emitting update event\n\t      this.emit('update', {\n\t        paths: affectedPaths,\n\t        currentData: this._data,\n\t        transaction: transaction,\n\t        previousData: previousData\n\t      });\n\t\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Method returning a monkey at the given path or else `null`.\n\t     *\n\t     * @param  {path}        path - Path of the monkey to retrieve.\n\t     * @return {Monkey|null}      - The Monkey instance of `null`.\n\t     */\n\t  }, {\n\t    key: 'getMonkey',\n\t    value: function getMonkey(path) {\n\t      path = coercePath(path);\n\t\n\t      var monkey = getIn(this._monkeys, [].concat(path)).data;\n\t\n\t      if (monkey instanceof _monkey.Monkey) return monkey;\n\t\n\t      return null;\n\t    }\n\t\n\t    /**\n\t     * Method used to watch a collection of paths within the tree. Very useful\n\t     * to bind UI components and such to the tree.\n\t     *\n\t     * @param  {object} mapping - Mapping of paths to listen.\n\t     * @return {Cursor}         - The created watcher.\n\t     */\n\t  }, {\n\t    key: 'watch',\n\t    value: function watch(mapping) {\n\t      return new _watcher2['default'](this, mapping);\n\t    }\n\t\n\t    /**\n\t     * Method releasing the tree and its attached data from memory.\n\t     */\n\t  }, {\n\t    key: 'release',\n\t    value: function release() {\n\t      var k = undefined;\n\t\n\t      this.emit('release');\n\t\n\t      delete this.root;\n\t\n\t      delete this._data;\n\t      delete this._previousData;\n\t      delete this._transaction;\n\t      delete this._affectedPathsIndex;\n\t      delete this._monkeys;\n\t\n\t      // Releasing cursors\n\t      for (k in this._cursors) this._cursors[k].release();\n\t      delete this._cursors;\n\t\n\t      // Killing event emitter\n\t      this.kill();\n\t    }\n\t\n\t    /**\n\t     * Overriding the `toJSON` method for convenient use with JSON.stringify.\n\t     *\n\t     * @return {mixed} - Data at cursor.\n\t     */\n\t  }, {\n\t    key: 'toJSON',\n\t    value: function toJSON() {\n\t      return this.serialize();\n\t    }\n\t\n\t    /**\n\t     * Overriding the `toString` method for debugging purposes.\n\t     *\n\t     * @return {string} - The baobab's identity.\n\t     */\n\t  }, {\n\t    key: 'toString',\n\t    value: function toString() {\n\t      return this._identity;\n\t    }\n\t  }]);\n\t\n\t  return Baobab;\n\t})(_emmett2['default']);\n\t\n\texports['default'] = Baobab;\n\tBaobab.monkey = function () {\n\t  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t    args[_key] = arguments[_key];\n\t  }\n\t\n\t  if (!args.length) throw new Error('Baobab.monkey: missing definition.');\n\t\n\t  if (args.length === 1 && typeof args[0] !== 'function') return new _monkey.MonkeyDefinition(args[0]);\n\t\n\t  return new _monkey.MonkeyDefinition(args);\n\t};\n\tBaobab.dynamicNode = Baobab.monkey;\n\t\n\t/**\n\t * Exposing some internals for convenience\n\t */\n\tBaobab.Cursor = _cursor2['default'];\n\tBaobab.MonkeyDefinition = _monkey.MonkeyDefinition;\n\tBaobab.Monkey = _monkey.Monkey;\n\tBaobab.type = _type2['default'];\n\tBaobab.helpers = helpers;\n\t\n\t/**\n\t * Version\n\t */\n\tBaobab.VERSION = '2.3.2';\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t(function() {\n\t  'use strict';\n\t\n\t  /**\n\t   * Here is the list of every allowed parameter when using Emitter#on:\n\t   * @type {Object}\n\t   */\n\t  var __allowedOptions = {\n\t    once: 'boolean',\n\t    scope: 'object'\n\t  };\n\t\n\t  /**\n\t   * Incremental id used to order event handlers.\n\t   */\n\t  var __order = 0;\n\t\n\t  /**\n\t   * A simple helper to shallowly merge two objects. The second one will \"win\"\n\t   * over the first one.\n\t   *\n\t   * @param  {object}  o1 First target object.\n\t   * @param  {object}  o2 Second target object.\n\t   * @return {object}     Returns the merged object.\n\t   */\n\t  function shallowMerge(o1, o2) {\n\t    var o = {},\n\t        k;\n\t\n\t    for (k in o1) o[k] = o1[k];\n\t    for (k in o2) o[k] = o2[k];\n\t\n\t    return o;\n\t  }\n\t\n\t  /**\n\t   * Is the given variable a plain JavaScript object?\n\t   *\n\t   * @param  {mixed}  v   Target.\n\t   * @return {boolean}    The boolean result.\n\t   */\n\t  function isPlainObject(v) {\n\t    return v &&\n\t           typeof v === 'object' &&\n\t           !Array.isArray(v) &&\n\t           !(v instanceof Function) &&\n\t           !(v instanceof RegExp);\n\t  }\n\t\n\t  /**\n\t   * Iterate over an object that may have ES6 Symbols.\n\t   *\n\t   * @param  {object}   object  Object on which to iterate.\n\t   * @param  {function} fn      Iterator function.\n\t   * @param  {object}   [scope] Optional scope.\n\t   */\n\t  function forIn(object, fn, scope) {\n\t    var symbols,\n\t        k,\n\t        i,\n\t        l;\n\t\n\t    for (k in object)\n\t      fn.call(scope || null, k, object[k]);\n\t\n\t    if (Object.getOwnPropertySymbols) {\n\t      symbols = Object.getOwnPropertySymbols(object);\n\t\n\t      for (i = 0, l = symbols.length; i < l; i++)\n\t        fn.call(scope || null, symbols[i], object[symbols[i]]);\n\t    }\n\t  }\n\t\n\t  /**\n\t   * The emitter's constructor. It initializes the handlers-per-events store and\n\t   * the global handlers store.\n\t   *\n\t   * Emitters are useful for non-DOM events communication. Read its methods\n\t   * documentation for more information about how it works.\n\t   *\n\t   * @return {Emitter}         The fresh new instance.\n\t   */\n\t  var Emitter = function() {\n\t    this._enabled = true;\n\t\n\t    // Dirty trick that will set the necessary properties to the emitter\n\t    this.unbindAll();\n\t  };\n\t\n\t  /**\n\t   * This method unbinds every handlers attached to every or any events. So,\n\t   * these functions will no more be executed when the related events are\n\t   * emitted. If the functions were not bound to the events, nothing will\n\t   * happen, and no error will be thrown.\n\t   *\n\t   * Usage:\n\t   * ******\n\t   * > myEmitter.unbindAll();\n\t   *\n\t   * @return {Emitter}      Returns this.\n\t   */\n\t  Emitter.prototype.unbindAll = function() {\n\t\n\t    this._handlers = {};\n\t    this._handlersAll = [];\n\t    this._handlersComplex = [];\n\t\n\t    return this;\n\t  };\n\t\n\t\n\t  /**\n\t   * This method binds one or more functions to the emitter, handled to one or a\n\t   * suite of events. So, these functions will be executed anytime one related\n\t   * event is emitted.\n\t   *\n\t   * It is also possible to bind a function to any emitted event by not\n\t   * specifying any event to bind the function to.\n\t   *\n\t   * Recognized options:\n\t   * *******************\n\t   *  - {?boolean} once   If true, the handlers will be unbound after the first\n\t   *                      execution. Default value: false.\n\t   *  - {?object}  scope  If a scope is given, then the listeners will be called\n\t   *                      with this scope as \"this\".\n\t   *\n\t   * Variant 1:\n\t   * **********\n\t   * > myEmitter.on('myEvent', function(e) { console.log(e); });\n\t   * > // Or:\n\t   * > myEmitter.on('myEvent', function(e) { console.log(e); }, { once: true });\n\t   *\n\t   * @param  {string}   event   The event to listen to.\n\t   * @param  {function} handler The function to bind.\n\t   * @param  {?object}  options Eventually some options.\n\t   * @return {Emitter}          Returns this.\n\t   *\n\t   * Variant 2:\n\t   * **********\n\t   * > myEmitter.on(\n\t   * >   ['myEvent1', 'myEvent2'],\n\t   * >   function(e) { console.log(e); }\n\t   * >);\n\t   * > // Or:\n\t   * > myEmitter.on(\n\t   * >   ['myEvent1', 'myEvent2'],\n\t   * >   function(e) { console.log(e); }\n\t   * >   { once: true }}\n\t   * >);\n\t   *\n\t   * @param  {array}    events  The events to listen to.\n\t   * @param  {function} handler The function to bind.\n\t   * @param  {?object}  options Eventually some options.\n\t   * @return {Emitter}          Returns this.\n\t   *\n\t   * Variant 3:\n\t   * **********\n\t   * > myEmitter.on({\n\t   * >   myEvent1: function(e) { console.log(e); },\n\t   * >   myEvent2: function(e) { console.log(e); }\n\t   * > });\n\t   * > // Or:\n\t   * > myEmitter.on({\n\t   * >   myEvent1: function(e) { console.log(e); },\n\t   * >   myEvent2: function(e) { console.log(e); }\n\t   * > }, { once: true });\n\t   *\n\t   * @param  {object}  bindings An object containing pairs event / function.\n\t   * @param  {?object}  options Eventually some options.\n\t   * @return {Emitter}          Returns this.\n\t   *\n\t   * Variant 4:\n\t   * **********\n\t   * > myEmitter.on(function(e) { console.log(e); });\n\t   * > // Or:\n\t   * > myEmitter.on(function(e) { console.log(e); }, { once: true});\n\t   *\n\t   * @param  {function} handler The function to bind to every events.\n\t   * @param  {?object}  options Eventually some options.\n\t   * @return {Emitter}          Returns this.\n\t   */\n\t  Emitter.prototype.on = function(a, b, c) {\n\t    var i,\n\t        l,\n\t        k,\n\t        event,\n\t        eArray,\n\t        handlersList,\n\t        bindingObject;\n\t\n\t    // Variant 3\n\t    if (isPlainObject(a)) {\n\t      forIn(a, function(name, fn) {\n\t        this.on(name, fn, b);\n\t      }, this);\n\t\n\t      return this;\n\t    }\n\t\n\t    // Variant 1, 2 and 4\n\t    if (typeof a === 'function') {\n\t      c = b;\n\t      b = a;\n\t      a = null;\n\t    }\n\t\n\t    eArray = [].concat(a);\n\t\n\t    for (i = 0, l = eArray.length; i < l; i++) {\n\t      event = eArray[i];\n\t\n\t      bindingObject = {\n\t        order: __order++,\n\t        fn: b\n\t      };\n\t\n\t      // Defining the list in which the handler should be inserted\n\t      if (typeof event === 'string' || typeof event === 'symbol') {\n\t        if (!this._handlers[event])\n\t          this._handlers[event] = [];\n\t        handlersList = this._handlers[event];\n\t        bindingObject.type = event;\n\t      }\n\t      else if (event instanceof RegExp) {\n\t        handlersList = this._handlersComplex;\n\t        bindingObject.pattern = event;\n\t      }\n\t      else if (event === null) {\n\t        handlersList = this._handlersAll;\n\t      }\n\t      else {\n\t        throw Error('Emitter.on: invalid event.');\n\t      }\n\t\n\t      // Appending needed properties\n\t      for (k in c || {})\n\t        if (__allowedOptions[k])\n\t          bindingObject[k] = c[k];\n\t\n\t      handlersList.push(bindingObject);\n\t    }\n\t\n\t    return this;\n\t  };\n\t\n\t\n\t  /**\n\t   * This method works exactly as the previous #on, but will add an options\n\t   * object if none is given, and set the option \"once\" to true.\n\t   *\n\t   * The polymorphism works exactly as with the #on method.\n\t   */\n\t  Emitter.prototype.once = function() {\n\t    var args = Array.prototype.slice.call(arguments),\n\t        li = args.length - 1;\n\t\n\t    if (isPlainObject(args[li]) && args.length > 1)\n\t      args[li] = shallowMerge(args[li], {once: true});\n\t    else\n\t      args.push({once: true});\n\t\n\t    return this.on.apply(this, args);\n\t  };\n\t\n\t\n\t  /**\n\t   * This method unbinds one or more functions from events of the emitter. So,\n\t   * these functions will no more be executed when the related events are\n\t   * emitted. If the functions were not bound to the events, nothing will\n\t   * happen, and no error will be thrown.\n\t   *\n\t   * Variant 1:\n\t   * **********\n\t   * > myEmitter.off('myEvent', myHandler);\n\t   *\n\t   * @param  {string}   event   The event to unbind the handler from.\n\t   * @param  {function} handler The function to unbind.\n\t   * @return {Emitter}          Returns this.\n\t   *\n\t   * Variant 2:\n\t   * **********\n\t   * > myEmitter.off(['myEvent1', 'myEvent2'], myHandler);\n\t   *\n\t   * @param  {array}    events  The events to unbind the handler from.\n\t   * @param  {function} handler The function to unbind.\n\t   * @return {Emitter}          Returns this.\n\t   *\n\t   * Variant 3:\n\t   * **********\n\t   * > myEmitter.off({\n\t   * >   myEvent1: myHandler1,\n\t   * >   myEvent2: myHandler2\n\t   * > });\n\t   *\n\t   * @param  {object} bindings An object containing pairs event / function.\n\t   * @return {Emitter}         Returns this.\n\t   *\n\t   * Variant 4:\n\t   * **********\n\t   * > myEmitter.off(myHandler);\n\t   *\n\t   * @param  {function} handler The function to unbind from every events.\n\t   * @return {Emitter}          Returns this.\n\t   *\n\t   * Variant 5:\n\t   * **********\n\t   * > myEmitter.off(event);\n\t   *\n\t   * @param  {string} event     The event we should unbind.\n\t   * @return {Emitter}          Returns this.\n\t   */\n\t  function filter(target, fn) {\n\t    target = target || [];\n\t\n\t    var a = [],\n\t        l,\n\t        i;\n\t\n\t    for (i = 0, l = target.length; i < l; i++)\n\t      if (target[i].fn !== fn)\n\t        a.push(target[i]);\n\t\n\t    return a;\n\t  }\n\t\n\t  Emitter.prototype.off = function(events, fn) {\n\t    var i,\n\t        n,\n\t        k,\n\t        event;\n\t\n\t    // Variant 4:\n\t    if (arguments.length === 1 && typeof events === 'function') {\n\t      fn = arguments[0];\n\t\n\t      // Handlers bound to events:\n\t      for (k in this._handlers) {\n\t        this._handlers[k] = filter(this._handlers[k], fn);\n\t\n\t        if (this._handlers[k].length === 0)\n\t          delete this._handlers[k];\n\t      }\n\t\n\t      // Generic Handlers\n\t      this._handlersAll = filter(this._handlersAll, fn);\n\t\n\t      // Complex handlers\n\t      this._handlersComplex = filter(this._handlersComplex, fn);\n\t    }\n\t\n\t    // Variant 5\n\t    else if (arguments.length === 1 &&\n\t             (typeof events === 'string' || typeof events === 'symbol')) {\n\t      delete this._handlers[events];\n\t    }\n\t\n\t    // Variant 1 and 2:\n\t    else if (arguments.length === 2) {\n\t      var eArray = [].concat(events);\n\t\n\t      for (i = 0, n = eArray.length; i < n; i++) {\n\t        event = eArray[i];\n\t\n\t        this._handlers[event] = filter(this._handlers[event], fn);\n\t\n\t        if ((this._handlers[event] || []).length === 0)\n\t          delete this._handlers[event];\n\t      }\n\t    }\n\t\n\t    // Variant 3\n\t    else if (isPlainObject(events)) {\n\t      forIn(events, this.off, this);\n\t    }\n\t\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * This method retrieve the listeners attached to a particular event.\n\t   *\n\t   * @param  {?string}    Name of the event.\n\t   * @return {array}      Array of handler functions.\n\t   */\n\t  Emitter.prototype.listeners = function(event) {\n\t    var handlers = this._handlersAll || [],\n\t        complex = false,\n\t        h,\n\t        i,\n\t        l;\n\t\n\t    if (!event)\n\t      throw Error('Emitter.listeners: no event provided.');\n\t\n\t    handlers = handlers.concat(this._handlers[event] || []);\n\t\n\t    for (i = 0, l = this._handlersComplex.length; i < l; i++) {\n\t      h = this._handlersComplex[i];\n\t\n\t      if (~event.search(h.pattern)) {\n\t        complex = true;\n\t        handlers.push(h);\n\t      }\n\t    }\n\t\n\t    // If we have any complex handlers, we need to sort\n\t    if (this._handlersAll.length || complex)\n\t      return handlers.sort(function(a, b) {\n\t        return a.order - b.order;\n\t      });\n\t    else\n\t      return handlers.slice(0);\n\t  };\n\t\n\t  /**\n\t   * This method emits the specified event(s), and executes every handlers bound\n\t   * to the event(s).\n\t   *\n\t   * Use cases:\n\t   * **********\n\t   * > myEmitter.emit('myEvent');\n\t   * > myEmitter.emit('myEvent', myData);\n\t   * > myEmitter.emit(['myEvent1', 'myEvent2']);\n\t   * > myEmitter.emit(['myEvent1', 'myEvent2'], myData);\n\t   * > myEmitter.emit({myEvent1: myData1, myEvent2: myData2});\n\t   *\n\t   * @param  {string|array} events The event(s) to emit.\n\t   * @param  {object?}      data   The data.\n\t   * @return {Emitter}             Returns this.\n\t   */\n\t  Emitter.prototype.emit = function(events, data) {\n\t\n\t    // Short exit if the emitter is disabled\n\t    if (!this._enabled)\n\t      return this;\n\t\n\t    // Object variant\n\t    if (isPlainObject(events)) {\n\t      forIn(events, this.emit, this);\n\t      return this;\n\t    }\n\t\n\t    var eArray = [].concat(events),\n\t        onces = [],\n\t        event,\n\t        parent,\n\t        handlers,\n\t        handler,\n\t        i,\n\t        j,\n\t        l,\n\t        m;\n\t\n\t    for (i = 0, l = eArray.length; i < l; i++) {\n\t      handlers = this.listeners(eArray[i]);\n\t\n\t      for (j = 0, m = handlers.length; j < m; j++) {\n\t        handler = handlers[j];\n\t        event = {\n\t          type: eArray[i],\n\t          target: this\n\t        };\n\t\n\t        if (arguments.length > 1)\n\t          event.data = data;\n\t\n\t        handler.fn.call('scope' in handler ? handler.scope : this, event);\n\t\n\t        if (handler.once)\n\t          onces.push(handler);\n\t      }\n\t\n\t      // Cleaning onces\n\t      for (j = onces.length - 1; j >= 0; j--) {\n\t        parent = onces[j].type ?\n\t          this._handlers[onces[j].type] :\n\t          onces[j].pattern ?\n\t            this._handlersComplex :\n\t            this._handlersAll;\n\t\n\t        parent.splice(parent.indexOf(onces[j]), 1);\n\t      }\n\t    }\n\t\n\t    return this;\n\t  };\n\t\n\t\n\t  /**\n\t   * This method will unbind all listeners and make it impossible to ever\n\t   * rebind any listener to any event.\n\t   */\n\t  Emitter.prototype.kill = function() {\n\t\n\t    this.unbindAll();\n\t    this._handlers = null;\n\t    this._handlersAll = null;\n\t    this._handlersComplex = null;\n\t    this._enabled = false;\n\t\n\t    // Nooping methods\n\t    this.unbindAll =\n\t    this.on =\n\t    this.once =\n\t    this.off =\n\t    this.emit =\n\t    this.listeners = Function.prototype;\n\t  };\n\t\n\t\n\t  /**\n\t   * This method disabled the emitter, which means its emit method will do\n\t   * nothing.\n\t   *\n\t   * @return {Emitter} Returns this.\n\t   */\n\t  Emitter.prototype.disable = function() {\n\t    this._enabled = false;\n\t\n\t    return this;\n\t  };\n\t\n\t\n\t  /**\n\t   * This method enables the emitter.\n\t   *\n\t   * @return {Emitter} Returns this.\n\t   */\n\t  Emitter.prototype.enable = function() {\n\t    this._enabled = true;\n\t\n\t    return this;\n\t  };\n\t\n\t\n\t  /**\n\t   * Version:\n\t   */\n\t  Emitter.version = '3.1.1';\n\t\n\t\n\t  // Export:\n\t  if (true) {\n\t    if (typeof module !== 'undefined' && module.exports)\n\t      exports = module.exports = Emitter;\n\t    exports.Emitter = Emitter;\n\t  } else if (typeof define === 'function' && define.amd)\n\t    define('emmett', [], function() {\n\t      return Emitter;\n\t    });\n\t  else\n\t    this.Emitter = Emitter;\n\t}).call(this);\n\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Baobab Cursors\n\t * ===============\n\t *\n\t * Cursors created by selecting some data within a Baobab tree.\n\t */\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\t\n\tvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\t\n\tvar _get = function get(_x3, _x4, _x5) { var _again = true; _function: while (_again) { var object = _x3, property = _x4, receiver = _x5; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x3 = parent; _x4 = property; _x5 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar _emmett = __webpack_require__(15);\n\t\n\tvar _emmett2 = _interopRequireDefault(_emmett);\n\t\n\tvar _monkey = __webpack_require__(17);\n\t\n\tvar _type = __webpack_require__(18);\n\t\n\tvar _type2 = _interopRequireDefault(_type);\n\t\n\tvar _helpers = __webpack_require__(20);\n\t\n\t/**\n\t * Traversal helper function for dynamic cursors. Will throw a legible error\n\t * if traversal is not possible.\n\t *\n\t * @param {string} method     - The method name, to create a correct error msg.\n\t * @param {array}  solvedPath - The cursor's solved path.\n\t */\n\tfunction checkPossibilityOfDynamicTraversal(method, solvedPath) {\n\t  if (!solvedPath) throw (0, _helpers.makeError)('Baobab.Cursor.' + method + ': ' + ('cannot use ' + method + ' on an unresolved dynamic path.'), { path: solvedPath });\n\t}\n\t\n\t/**\n\t * Cursor class\n\t *\n\t * @constructor\n\t * @param {Baobab} tree   - The cursor's root.\n\t * @param {array}  path   - The cursor's path in the tree.\n\t * @param {string} hash   - The path's hash computed ahead by the tree.\n\t */\n\t\n\tvar Cursor = (function (_Emitter) {\n\t  _inherits(Cursor, _Emitter);\n\t\n\t  function Cursor(tree, path, hash) {\n\t    var _this = this;\n\t\n\t    _classCallCheck(this, Cursor);\n\t\n\t    _get(Object.getPrototypeOf(Cursor.prototype), 'constructor', this).call(this);\n\t\n\t    // If no path were to be provided, we fallback to an empty path (root)\n\t    path = path || [];\n\t\n\t    // Privates\n\t    this._identity = '[object Cursor]';\n\t    this._archive = null;\n\t\n\t    // Properties\n\t    this.tree = tree;\n\t    this.path = path;\n\t    this.hash = hash;\n\t\n\t    // State\n\t    this.state = {\n\t      killed: false,\n\t      recording: false,\n\t      undoing: false\n\t    };\n\t\n\t    // Checking whether the given path is dynamic or not\n\t    this._dynamicPath = _type2['default'].dynamicPath(this.path);\n\t\n\t    // Checking whether the given path will meet a monkey\n\t    this._monkeyPath = _type2['default'].monkeyPath(this.tree._monkeys, this.path);\n\t\n\t    if (!this._dynamicPath) this.solvedPath = this.path;else this.solvedPath = (0, _helpers.getIn)(this.tree._data, this.path).solvedPath;\n\t\n\t    /**\n\t     * Listener bound to the tree's writes so that cursors with dynamic paths\n\t     * may update their solved path correctly.\n\t     *\n\t     * @param {object} event - The event fired by the tree.\n\t     */\n\t    this._writeHandler = function (_ref) {\n\t      var data = _ref.data;\n\t\n\t      if (_this.state.killed || !(0, _helpers.solveUpdate)([data.path], _this._getComparedPaths())) return;\n\t\n\t      _this.solvedPath = (0, _helpers.getIn)(_this.tree._data, _this.path).solvedPath;\n\t    };\n\t\n\t    /**\n\t     * Function in charge of actually trigger the cursor's updates and\n\t     * deal with the archived records.\n\t     *\n\t     * @note: probably should wrap the current solvedPath in closure to avoid\n\t     * for tricky cases where it would fail.\n\t     *\n\t     * @param {mixed} previousData - the tree's previous data.\n\t     */\n\t    var fireUpdate = function fireUpdate(previousData) {\n\t      var self = _this;\n\t\n\t      var eventData = Object.defineProperties({}, {\n\t        previousData: {\n\t          get: function get() {\n\t            return (0, _helpers.getIn)(previousData, self.solvedPath).data;\n\t          },\n\t          configurable: true,\n\t          enumerable: true\n\t        },\n\t        currentData: {\n\t          get: function get() {\n\t            return self.get();\n\t          },\n\t          configurable: true,\n\t          enumerable: true\n\t        }\n\t      });\n\t\n\t      if (_this.state.recording && !_this.state.undoing) _this.archive.add(eventData.previousData);\n\t\n\t      _this.state.undoing = false;\n\t\n\t      return _this.emit('update', eventData);\n\t    };\n\t\n\t    /**\n\t     * Listener bound to the tree's updates and determining whether the\n\t     * cursor is affected and should react accordingly.\n\t     *\n\t     * Note that this listener is lazily bound to the tree to be sure\n\t     * one wouldn't leak listeners when only creating cursors for convenience\n\t     * and not to listen to updates specifically.\n\t     *\n\t     * @param {object} event - The event fired by the tree.\n\t     */\n\t    this._updateHandler = function (event) {\n\t      if (_this.state.killed) return;\n\t\n\t      var _event$data = event.data;\n\t      var paths = _event$data.paths;\n\t      var previousData = _event$data.previousData;\n\t      var update = fireUpdate.bind(_this, previousData);\n\t      var comparedPaths = _this._getComparedPaths();\n\t\n\t      if ((0, _helpers.solveUpdate)(paths, comparedPaths)) return update();\n\t    };\n\t\n\t    // Lazy binding\n\t    var bound = false;\n\t    this._lazyBind = function () {\n\t      if (bound) return;\n\t\n\t      bound = true;\n\t\n\t      if (_this._dynamicPath) _this.tree.on('write', _this._writeHandler);\n\t\n\t      return _this.tree.on('update', _this._updateHandler);\n\t    };\n\t\n\t    // If the path is dynamic, we actually need to listen to the tree\n\t    if (this._dynamicPath) {\n\t      this._lazyBind();\n\t    } else {\n\t\n\t      // Overriding the emitter `on` and `once` methods\n\t      this.on = (0, _helpers.before)(this._lazyBind, this.on.bind(this));\n\t      this.once = (0, _helpers.before)(this._lazyBind, this.once.bind(this));\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Method used to allow iterating over cursors containing list-type data.\n\t   *\n\t   * e.g. for(let i of cursor) { ... }\n\t   *\n\t   * @returns {object} -  Each item sequentially.\n\t   */\n\t\n\t  /**\n\t   * Internal helpers\n\t   * -----------------\n\t   */\n\t\n\t  /**\n\t   * Method returning the paths of the tree watched over by the cursor and that\n\t   * should be taken into account when solving a potential update.\n\t   *\n\t   * @return {array} - Array of paths to compare with a given update.\n\t   */\n\t\n\t  _createClass(Cursor, [{\n\t    key: '_getComparedPaths',\n\t    value: function _getComparedPaths() {\n\t\n\t      // Checking whether we should keep track of some dependencies\n\t      var additionalPaths = this._monkeyPath ? (0, _helpers.getIn)(this.tree._monkeys, this._monkeyPath).data.relatedPaths() : [];\n\t\n\t      return [this.solvedPath].concat(additionalPaths);\n\t    }\n\t\n\t    /**\n\t     * Predicates\n\t     * -----------\n\t     */\n\t\n\t    /**\n\t     * Method returning whether the cursor is at root level.\n\t     *\n\t     * @return {boolean} - Is the cursor the root?\n\t     */\n\t  }, {\n\t    key: 'isRoot',\n\t    value: function isRoot() {\n\t      return !this.path.length;\n\t    }\n\t\n\t    /**\n\t     * Method returning whether the cursor is at leaf level.\n\t     *\n\t     * @return {boolean} - Is the cursor a leaf?\n\t     */\n\t  }, {\n\t    key: 'isLeaf',\n\t    value: function isLeaf() {\n\t      return _type2['default'].primitive(this._get().data);\n\t    }\n\t\n\t    /**\n\t     * Method returning whether the cursor is at branch level.\n\t     *\n\t     * @return {boolean} - Is the cursor a branch?\n\t     */\n\t  }, {\n\t    key: 'isBranch',\n\t    value: function isBranch() {\n\t      return !this.isRoot() && !this.isLeaf();\n\t    }\n\t\n\t    /**\n\t     * Traversal Methods\n\t     * ------------------\n\t     */\n\t\n\t    /**\n\t     * Method returning the root cursor.\n\t     *\n\t     * @return {Baobab} - The root cursor.\n\t     */\n\t  }, {\n\t    key: 'root',\n\t    value: function root() {\n\t      return this.tree.select();\n\t    }\n\t\n\t    /**\n\t     * Method selecting a subpath as a new cursor.\n\t     *\n\t     * Arity (1):\n\t     * @param  {path} path    - The path to select.\n\t     *\n\t     * Arity (*):\n\t     * @param  {...step} path - The path to select.\n\t     *\n\t     * @return {Cursor}       - The created cursor.\n\t     */\n\t  }, {\n\t    key: 'select',\n\t    value: function select(path) {\n\t      if (arguments.length > 1) path = (0, _helpers.arrayFrom)(arguments);\n\t\n\t      return this.tree.select(this.path.concat(path));\n\t    }\n\t\n\t    /**\n\t     * Method returning the parent node of the cursor or else `null` if the\n\t     * cursor is already at root level.\n\t     *\n\t     * @return {Baobab} - The parent cursor.\n\t     */\n\t  }, {\n\t    key: 'up',\n\t    value: function up() {\n\t      if (!this.isRoot()) return this.tree.select(this.path.slice(0, -1));\n\t\n\t      return null;\n\t    }\n\t\n\t    /**\n\t     * Method returning the child node of the cursor.\n\t     *\n\t     * @return {Baobab} - The child cursor.\n\t     */\n\t  }, {\n\t    key: 'down',\n\t    value: function down() {\n\t      checkPossibilityOfDynamicTraversal('down', this.solvedPath);\n\t\n\t      if (!(this._get().data instanceof Array)) throw Error('Baobab.Cursor.down: cannot go down on a non-list type.');\n\t\n\t      return this.tree.select(this.solvedPath.concat(0));\n\t    }\n\t\n\t    /**\n\t     * Method returning the left sibling node of the cursor if this one is\n\t     * pointing at a list. Returns `null` if this cursor is already leftmost.\n\t     *\n\t     * @return {Baobab} - The left sibling cursor.\n\t     */\n\t  }, {\n\t    key: 'left',\n\t    value: function left() {\n\t      checkPossibilityOfDynamicTraversal('left', this.solvedPath);\n\t\n\t      var last = +this.solvedPath[this.solvedPath.length - 1];\n\t\n\t      if (isNaN(last)) throw Error('Baobab.Cursor.left: cannot go left on a non-list type.');\n\t\n\t      return last ? this.tree.select(this.solvedPath.slice(0, -1).concat(last - 1)) : null;\n\t    }\n\t\n\t    /**\n\t     * Method returning the right sibling node of the cursor if this one is\n\t     * pointing at a list. Returns `null` if this cursor is already rightmost.\n\t     *\n\t     * @return {Baobab} - The right sibling cursor.\n\t     */\n\t  }, {\n\t    key: 'right',\n\t    value: function right() {\n\t      checkPossibilityOfDynamicTraversal('right', this.solvedPath);\n\t\n\t      var last = +this.solvedPath[this.solvedPath.length - 1];\n\t\n\t      if (isNaN(last)) throw Error('Baobab.Cursor.right: cannot go right on a non-list type.');\n\t\n\t      if (last + 1 === this.up()._get().data.length) return null;\n\t\n\t      return this.tree.select(this.solvedPath.slice(0, -1).concat(last + 1));\n\t    }\n\t\n\t    /**\n\t     * Method returning the leftmost sibling node of the cursor if this one is\n\t     * pointing at a list.\n\t     *\n\t     * @return {Baobab} - The leftmost sibling cursor.\n\t     */\n\t  }, {\n\t    key: 'leftmost',\n\t    value: function leftmost() {\n\t      checkPossibilityOfDynamicTraversal('leftmost', this.solvedPath);\n\t\n\t      var last = +this.solvedPath[this.solvedPath.length - 1];\n\t\n\t      if (isNaN(last)) throw Error('Baobab.Cursor.leftmost: cannot go left on a non-list type.');\n\t\n\t      return this.tree.select(this.solvedPath.slice(0, -1).concat(0));\n\t    }\n\t\n\t    /**\n\t     * Method returning the rightmost sibling node of the cursor if this one is\n\t     * pointing at a list.\n\t     *\n\t     * @return {Baobab} - The rightmost sibling cursor.\n\t     */\n\t  }, {\n\t    key: 'rightmost',\n\t    value: function rightmost() {\n\t      checkPossibilityOfDynamicTraversal('rightmost', this.solvedPath);\n\t\n\t      var last = +this.solvedPath[this.solvedPath.length - 1];\n\t\n\t      if (isNaN(last)) throw Error('Baobab.Cursor.rightmost: cannot go right on a non-list type.');\n\t\n\t      var list = this.up()._get().data;\n\t\n\t      return this.tree.select(this.solvedPath.slice(0, -1).concat(list.length - 1));\n\t    }\n\t\n\t    /**\n\t     * Method mapping the children nodes of the cursor.\n\t     *\n\t     * @param  {function} fn      - The function to map.\n\t     * @param  {object}   [scope] - An optional scope.\n\t     * @return {array}            - The resultant array.\n\t     */\n\t  }, {\n\t    key: 'map',\n\t    value: function map(fn, scope) {\n\t      checkPossibilityOfDynamicTraversal('map', this.solvedPath);\n\t\n\t      var array = this._get().data,\n\t          l = arguments.length;\n\t\n\t      if (!_type2['default'].array(array)) throw Error('baobab.Cursor.map: cannot map a non-list type.');\n\t\n\t      return array.map(function (item, i) {\n\t        return fn.call(l > 1 ? scope : this, this.select(i), i, array);\n\t      }, this);\n\t    }\n\t\n\t    /**\n\t     * Getter Methods\n\t     * ---------------\n\t     */\n\t\n\t    /**\n\t     * Internal get method. Basically contains the main body of the `get` method\n\t     * without the event emitting. This is sometimes needed not to fire useless\n\t     * events.\n\t     *\n\t     * @param  {path}   [path=[]]       - Path to get in the tree.\n\t     * @return {object} info            - The resultant information.\n\t     * @return {mixed}  info.data       - Data at path.\n\t     * @return {array}  info.solvedPath - The path solved when getting.\n\t     */\n\t  }, {\n\t    key: '_get',\n\t    value: function _get() {\n\t      var path = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];\n\t\n\t      if (!_type2['default'].path(path)) throw (0, _helpers.makeError)('Baobab.Cursor.getters: invalid path.', { path: path });\n\t\n\t      if (!this.solvedPath) return { data: undefined, solvedPath: null, exists: false };\n\t\n\t      return (0, _helpers.getIn)(this.tree._data, this.solvedPath.concat(path));\n\t    }\n\t\n\t    /**\n\t     * Method used to check whether a certain path exists in the tree starting\n\t     * from the current cursor.\n\t     *\n\t     * Arity (1):\n\t     * @param  {path}   path           - Path to check in the tree.\n\t     *\n\t     * Arity (2):\n\t     * @param {..step}  path           - Path to check in the tree.\n\t     *\n\t     * @return {boolean}               - Does the given path exists?\n\t     */\n\t  }, {\n\t    key: 'exists',\n\t    value: function exists(path) {\n\t      path = (0, _helpers.coercePath)(path);\n\t\n\t      if (arguments.length > 1) path = (0, _helpers.arrayFrom)(arguments);\n\t\n\t      return this._get(path).exists;\n\t    }\n\t\n\t    /**\n\t     * Method used to get data from the tree. Will fire a `get` event from the\n\t     * tree so that the user may sometimes react upon it to fetch data, for\n\t     * instance.\n\t     *\n\t     * Arity (1):\n\t     * @param  {path}   path           - Path to get in the tree.\n\t     *\n\t     * Arity (2):\n\t     * @param  {..step} path           - Path to get in the tree.\n\t     *\n\t     * @return {mixed}                 - Data at path.\n\t     */\n\t  }, {\n\t    key: 'get',\n\t    value: function get(path) {\n\t      path = (0, _helpers.coercePath)(path);\n\t\n\t      if (arguments.length > 1) path = (0, _helpers.arrayFrom)(arguments);\n\t\n\t      var _get2 = this._get(path);\n\t\n\t      var data = _get2.data;\n\t      var solvedPath = _get2.solvedPath;\n\t\n\t      // Emitting the event\n\t      this.tree.emit('get', { data: data, solvedPath: solvedPath, path: this.path.concat(path) });\n\t\n\t      return data;\n\t    }\n\t\n\t    /**\n\t     * Method used to shallow clone data from the tree.\n\t     *\n\t     * Arity (1):\n\t     * @param  {path}   path           - Path to get in the tree.\n\t     *\n\t     * Arity (2):\n\t     * @param  {..step} path           - Path to get in the tree.\n\t     *\n\t     * @return {mixed}                 - Cloned data at path.\n\t     */\n\t  }, {\n\t    key: 'clone',\n\t    value: function clone() {\n\t      var data = this.get.apply(this, arguments);\n\t\n\t      return (0, _helpers.shallowClone)(data);\n\t    }\n\t\n\t    /**\n\t     * Method used to deep clone data from the tree.\n\t     *\n\t     * Arity (1):\n\t     * @param  {path}   path           - Path to get in the tree.\n\t     *\n\t     * Arity (2):\n\t     * @param  {..step} path           - Path to get in the tree.\n\t     *\n\t     * @return {mixed}                 - Cloned data at path.\n\t     */\n\t  }, {\n\t    key: 'deepClone',\n\t    value: function deepClone() {\n\t      var data = this.get.apply(this, arguments);\n\t\n\t      return (0, _helpers.deepClone)(data);\n\t    }\n\t\n\t    /**\n\t     * Method used to return raw data from the tree, by carefully avoiding\n\t     * computed one.\n\t     *\n\t     * @todo: should be more performant as the cloning should happen as well as\n\t     * when dropping computed data.\n\t     *\n\t     * Arity (1):\n\t     * @param  {path}   path           - Path to serialize in the tree.\n\t     *\n\t     * Arity (2):\n\t     * @param  {..step} path           - Path to serialize in the tree.\n\t     *\n\t     * @return {mixed}                 - The retrieved raw data.\n\t     */\n\t  }, {\n\t    key: 'serialize',\n\t    value: function serialize(path) {\n\t      path = (0, _helpers.coercePath)(path);\n\t\n\t      if (arguments.length > 1) path = (0, _helpers.arrayFrom)(arguments);\n\t\n\t      if (!_type2['default'].path(path)) throw (0, _helpers.makeError)('Baobab.Cursor.getters: invalid path.', { path: path });\n\t\n\t      if (!this.solvedPath) return undefined;\n\t\n\t      var fullPath = this.solvedPath.concat(path);\n\t\n\t      var data = (0, _helpers.deepClone)((0, _helpers.getIn)(this.tree._data, fullPath).data),\n\t          monkeys = (0, _helpers.getIn)(this.tree._monkeys, fullPath).data;\n\t\n\t      var dropComputedData = function dropComputedData(d, m) {\n\t        if (!_type2['default'].object(m) || !_type2['default'].object(d)) return;\n\t\n\t        for (var k in m) {\n\t          if (m[k] instanceof _monkey.Monkey) delete d[k];else dropComputedData(d[k], m[k]);\n\t        }\n\t      };\n\t\n\t      dropComputedData(data, monkeys);\n\t      return data;\n\t    }\n\t\n\t    /**\n\t     * Method used to project some of the data at cursor onto a map or a list.\n\t     *\n\t     * @param  {object|array} projection - The projection's formal definition.\n\t     * @return {object|array}            - The resultant map/list.\n\t     */\n\t  }, {\n\t    key: 'project',\n\t    value: function project(projection) {\n\t      if (_type2['default'].object(projection)) {\n\t        var data = {};\n\t\n\t        for (var k in projection) {\n\t          data[k] = this.get(projection[k]);\n\t        }return data;\n\t      } else if (_type2['default'].array(projection)) {\n\t        var data = [];\n\t\n\t        for (var i = 0, l = projection.length; i < l; i++) {\n\t          data.push(this.get(projection[i]));\n\t        }return data;\n\t      }\n\t\n\t      throw (0, _helpers.makeError)('Baobab.Cursor.project: wrong projection.', { projection: projection });\n\t    }\n\t\n\t    /**\n\t     * History Methods\n\t     * ----------------\n\t     */\n\t\n\t    /**\n\t     * Methods starting to record the cursor's successive states.\n\t     *\n\t     * @param  {integer} [maxRecords] - Maximum records to keep in memory. Note\n\t     *                                  that if no number is provided, the cursor\n\t     *                                  will keep everything.\n\t     * @return {Cursor}               - The cursor instance for chaining purposes.\n\t     */\n\t  }, {\n\t    key: 'startRecording',\n\t    value: function startRecording(maxRecords) {\n\t      maxRecords = maxRecords || Infinity;\n\t\n\t      if (maxRecords < 1) throw (0, _helpers.makeError)('Baobab.Cursor.startRecording: invalid max records.', {\n\t        value: maxRecords\n\t      });\n\t\n\t      this.state.recording = true;\n\t\n\t      if (this.archive) return this;\n\t\n\t      // Lazy binding\n\t      this._lazyBind();\n\t\n\t      this.archive = new _helpers.Archive(maxRecords);\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Methods stopping to record the cursor's successive states.\n\t     *\n\t     * @return {Cursor} - The cursor instance for chaining purposes.\n\t     */\n\t  }, {\n\t    key: 'stopRecording',\n\t    value: function stopRecording() {\n\t      this.state.recording = false;\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Methods undoing n steps of the cursor's recorded states.\n\t     *\n\t     * @param  {integer} [steps=1] - The number of steps to rollback.\n\t     * @return {Cursor}            - The cursor instance for chaining purposes.\n\t     */\n\t  }, {\n\t    key: 'undo',\n\t    value: function undo() {\n\t      var steps = arguments.length <= 0 || arguments[0] === undefined ? 1 : arguments[0];\n\t\n\t      if (!this.state.recording) throw new Error('Baobab.Cursor.undo: cursor is not recording.');\n\t\n\t      var record = this.archive.back(steps);\n\t\n\t      if (!record) throw Error('Baobab.Cursor.undo: cannot find a relevant record.');\n\t\n\t      this.state.undoing = true;\n\t      this.set(record);\n\t\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Methods returning whether the cursor has a recorded history.\n\t     *\n\t     * @return {boolean} - `true` if the cursor has a recorded history?\n\t     */\n\t  }, {\n\t    key: 'hasHistory',\n\t    value: function hasHistory() {\n\t      return !!(this.archive && this.archive.get().length);\n\t    }\n\t\n\t    /**\n\t     * Methods returning the cursor's history.\n\t     *\n\t     * @return {array} - The cursor's history.\n\t     */\n\t  }, {\n\t    key: 'getHistory',\n\t    value: function getHistory() {\n\t      return this.archive ? this.archive.get() : [];\n\t    }\n\t\n\t    /**\n\t     * Methods clearing the cursor's history.\n\t     *\n\t     * @return {Cursor} - The cursor instance for chaining purposes.\n\t     */\n\t  }, {\n\t    key: 'clearHistory',\n\t    value: function clearHistory() {\n\t      if (this.archive) this.archive.clear();\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Releasing\n\t     * ----------\n\t     */\n\t\n\t    /**\n\t     * Methods releasing the cursor from memory.\n\t     */\n\t  }, {\n\t    key: 'release',\n\t    value: function release() {\n\t\n\t      // Removing listeners on parent\n\t      if (this._dynamicPath) this.tree.off('write', this._writeHandler);\n\t\n\t      this.tree.off('update', this._updateHandler);\n\t\n\t      // Unsubscribe from the parent\n\t      if (this.hash) delete this.tree._cursors[this.hash];\n\t\n\t      // Dereferencing\n\t      delete this.tree;\n\t      delete this.path;\n\t      delete this.solvedPath;\n\t      delete this.archive;\n\t\n\t      // Killing emitter\n\t      this.kill();\n\t      this.state.killed = true;\n\t    }\n\t\n\t    /**\n\t     * Output\n\t     * -------\n\t     */\n\t\n\t    /**\n\t     * Overriding the `toJSON` method for convenient use with JSON.stringify.\n\t     *\n\t     * @return {mixed} - Data at cursor.\n\t     */\n\t  }, {\n\t    key: 'toJSON',\n\t    value: function toJSON() {\n\t      return this.serialize();\n\t    }\n\t\n\t    /**\n\t     * Overriding the `toString` method for debugging purposes.\n\t     *\n\t     * @return {string} - The cursor's identity.\n\t     */\n\t  }, {\n\t    key: 'toString',\n\t    value: function toString() {\n\t      return this._identity;\n\t    }\n\t  }]);\n\t\n\t  return Cursor;\n\t})(_emmett2['default']);\n\t\n\texports['default'] = Cursor;\n\tif (typeof Symbol === 'function' && typeof Symbol.iterator !== 'undefined') {\n\t  Cursor.prototype[Symbol.iterator] = function () {\n\t    var array = this._get().data;\n\t\n\t    if (!_type2['default'].array(array)) throw Error('baobab.Cursor.@@iterate: cannot iterate a non-list type.');\n\t\n\t    var i = 0;\n\t\n\t    var cursor = this,\n\t        length = array.length;\n\t\n\t    return {\n\t      next: function next() {\n\t        if (i < length) {\n\t          return {\n\t            value: cursor.select(i++)\n\t          };\n\t        }\n\t\n\t        return {\n\t          done: true\n\t        };\n\t      }\n\t    };\n\t  };\n\t}\n\t\n\t/**\n\t * Setter Methods\n\t * ---------------\n\t *\n\t * Those methods are dynamically assigned to the class for DRY reasons.\n\t */\n\t\n\t// Not using a Set so that ES5 consumers don't pay a bundle size price\n\tvar INTRANSITIVE_SETTERS = {\n\t  unset: true,\n\t  pop: true,\n\t  shift: true\n\t};\n\t\n\t/**\n\t * Function creating a setter method for the Cursor class.\n\t *\n\t * @param {string}   name          - the method's name.\n\t * @param {function} [typeChecker] - a function checking that the given value is\n\t *                                   valid for the given operation.\n\t */\n\tfunction makeSetter(name, typeChecker) {\n\t\n\t  /**\n\t   * Binding a setter method to the Cursor class and having the following\n\t   * definition.\n\t   *\n\t   * Note: this is not really possible to make those setters variadic because\n\t   * it would create an impossible polymorphism with path.\n\t   *\n\t   * @todo: perform value validation elsewhere so that tree.update can\n\t   * beneficiate from it.\n\t   *\n\t   * Arity (1):\n\t   * @param  {mixed} value - New value to set at cursor's path.\n\t   *\n\t   * Arity (2):\n\t   * @param  {path}  path  - Subpath to update starting from cursor's.\n\t   * @param  {mixed} value - New value to set.\n\t   *\n\t   * @return {mixed}       - Data at path.\n\t   */\n\t  Cursor.prototype[name] = function (path, value) {\n\t\n\t    // We should warn the user if he applies to many arguments to the function\n\t    if (arguments.length > 2) throw (0, _helpers.makeError)('Baobab.Cursor.' + name + ': too many arguments.');\n\t\n\t    // Handling arities\n\t    if (arguments.length === 1 && !INTRANSITIVE_SETTERS[name]) {\n\t      value = path;\n\t      path = [];\n\t    }\n\t\n\t    // Coerce path\n\t    path = (0, _helpers.coercePath)(path);\n\t\n\t    // Checking the path's validity\n\t    if (!_type2['default'].path(path)) throw (0, _helpers.makeError)('Baobab.Cursor.' + name + ': invalid path.', { path: path });\n\t\n\t    // Checking the value's validity\n\t    if (typeChecker && !typeChecker(value)) throw (0, _helpers.makeError)('Baobab.Cursor.' + name + ': invalid value.', { path: path, value: value });\n\t\n\t    // Checking the solvability of the cursor's dynamic path\n\t    if (!this.solvedPath) throw (0, _helpers.makeError)('Baobab.Cursor.' + name + ': the dynamic path of the cursor cannot be solved.', { path: this.path });\n\t\n\t    var fullPath = this.solvedPath.concat(path);\n\t\n\t    // Filing the update to the tree\n\t    return this.tree.update(fullPath, {\n\t      type: name,\n\t      value: value\n\t    });\n\t  };\n\t}\n\t\n\t/**\n\t * Making the necessary setters.\n\t */\n\tmakeSetter('set');\n\tmakeSetter('unset');\n\tmakeSetter('apply', _type2['default']['function']);\n\tmakeSetter('push');\n\tmakeSetter('concat', _type2['default'].array);\n\tmakeSetter('unshift');\n\tmakeSetter('pop');\n\tmakeSetter('shift');\n\tmakeSetter('splice', _type2['default'].splicer);\n\tmakeSetter('merge', _type2['default'].object);\n\tmakeSetter('deepMerge', _type2['default'].object);\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Baobab Monkeys\n\t * ===============\n\t *\n\t * Exposing both handy monkey definitions and the underlying working class.\n\t */\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\t\n\tvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\t\n\tvar _type = __webpack_require__(18);\n\t\n\tvar _type2 = _interopRequireDefault(_type);\n\t\n\tvar _update2 = __webpack_require__(19);\n\t\n\tvar _update3 = _interopRequireDefault(_update2);\n\t\n\tvar _helpers = __webpack_require__(20);\n\t\n\t/**\n\t * Monkey Definition class\n\t * Note: The only reason why this is a class is to be able to spot it within\n\t * otherwise ordinary data.\n\t *\n\t * @constructor\n\t * @param {array|object} definition - The formal definition of the monkey.\n\t */\n\t\n\tvar MonkeyDefinition = function MonkeyDefinition(definition) {\n\t  var _this = this;\n\t\n\t  _classCallCheck(this, MonkeyDefinition);\n\t\n\t  var monkeyType = _type2['default'].monkeyDefinition(definition);\n\t\n\t  if (!monkeyType) throw (0, _helpers.makeError)('Baobab.monkey: invalid definition.', { definition: definition });\n\t\n\t  this.type = monkeyType;\n\t\n\t  if (this.type === 'object') {\n\t    this.getter = definition.get;\n\t    this.projection = definition.cursors || {};\n\t    this.paths = Object.keys(this.projection).map(function (k) {\n\t      return _this.projection[k];\n\t    });\n\t    this.options = definition.options || {};\n\t  } else {\n\t    var offset = 1,\n\t        options = {};\n\t\n\t    if (_type2['default'].object(definition[definition.length - 1])) {\n\t      offset++;\n\t      options = definition[definition.length - 1];\n\t    }\n\t\n\t    this.getter = definition[definition.length - offset];\n\t    this.projection = definition.slice(0, -offset);\n\t    this.paths = this.projection;\n\t    this.options = options;\n\t  }\n\t\n\t  // Coercing paths for convenience\n\t  this.paths = this.paths.map(function (p) {\n\t    return [].concat(p);\n\t  });\n\t\n\t  // Does the definition contain dynamic paths\n\t  this.hasDynamicPaths = this.paths.some(_type2['default'].dynamicPath);\n\t}\n\t\n\t/**\n\t * Monkey core class\n\t *\n\t * @constructor\n\t * @param {Baobab}           tree       - The bound tree.\n\t * @param {MonkeyDefinition} definition - A definition instance.\n\t */\n\t;\n\t\n\texports.MonkeyDefinition = MonkeyDefinition;\n\t\n\tvar Monkey = (function () {\n\t  function Monkey(tree, pathInTree, definition) {\n\t    var _this2 = this;\n\t\n\t    _classCallCheck(this, Monkey);\n\t\n\t    // Properties\n\t    this.tree = tree;\n\t    this.path = pathInTree;\n\t    this.definition = definition;\n\t\n\t    // Adapting the definition's paths & projection to this monkey's case\n\t    var projection = definition.projection,\n\t        relative = _helpers.solveRelativePath.bind(null, pathInTree.slice(0, -1));\n\t\n\t    if (definition.type === 'object') {\n\t      this.projection = Object.keys(projection).reduce(function (acc, k) {\n\t        acc[k] = relative(projection[k]);\n\t        return acc;\n\t      }, {});\n\t      this.depPaths = Object.keys(this.projection).map(function (k) {\n\t        return _this2.projection[k];\n\t      });\n\t    } else {\n\t      this.projection = projection.map(relative);\n\t      this.depPaths = this.projection;\n\t    }\n\t\n\t    // Internal state\n\t    this.state = {\n\t      killed: false\n\t    };\n\t\n\t    /**\n\t     * Listener on the tree's `write` event.\n\t     *\n\t     * When the tree writes, this listener will check whether the updated paths\n\t     * are of any use to the monkey and, if so, will update the tree's node\n\t     * where the monkey sits.\n\t     */\n\t    this.writeListener = function (_ref) {\n\t      var path = _ref.data.path;\n\t\n\t      if (_this2.state.killed) return;\n\t\n\t      // Is the monkey affected by the current write event?\n\t      var concerned = (0, _helpers.solveUpdate)([path], _this2.relatedPaths());\n\t\n\t      if (concerned) _this2.update();\n\t    };\n\t\n\t    /**\n\t     * Listener on the tree's `monkey` event.\n\t     *\n\t     * When another monkey updates, this listener will check whether the\n\t     * updated paths are of any use to the monkey and, if so, will update the\n\t     * tree's node where the monkey sits.\n\t     */\n\t    this.recursiveListener = function (_ref2) {\n\t      var _ref2$data = _ref2.data;\n\t      var monkey = _ref2$data.monkey;\n\t      var path = _ref2$data.path;\n\t\n\t      if (_this2.state.killed) return;\n\t\n\t      // Breaking if this is the same monkey\n\t      if (_this2 === monkey) return;\n\t\n\t      // Is the monkey affected by the current monkey event?\n\t      var concerned = (0, _helpers.solveUpdate)([path], _this2.relatedPaths(false));\n\t\n\t      if (concerned) _this2.update();\n\t    };\n\t\n\t    // Binding listeners\n\t    this.tree.on('write', this.writeListener);\n\t    this.tree.on('_monkey', this.recursiveListener);\n\t\n\t    // Updating relevant node\n\t    this.update();\n\t  }\n\t\n\t  /**\n\t   * Method returning solved paths related to the monkey.\n\t   *\n\t   * @param  {boolean} recursive - Should we compute recursive paths?\n\t   * @return {array}             - An array of related paths.\n\t   */\n\t\n\t  _createClass(Monkey, [{\n\t    key: 'relatedPaths',\n\t    value: function relatedPaths() {\n\t      var _this3 = this;\n\t\n\t      var recursive = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];\n\t\n\t      var paths = undefined;\n\t\n\t      if (this.definition.hasDynamicPaths) paths = this.depPaths.map(function (p) {\n\t        return (0, _helpers.getIn)(_this3.tree._data, p).solvedPath;\n\t      });else paths = this.depPaths;\n\t\n\t      var isRecursive = recursive && this.depPaths.some(function (p) {\n\t        return !!_type2['default'].monkeyPath(_this3.tree._monkeys, p);\n\t      });\n\t\n\t      if (!isRecursive) return paths;\n\t\n\t      return paths.reduce(function (accumulatedPaths, path) {\n\t        var monkeyPath = _type2['default'].monkeyPath(_this3.tree._monkeys, path);\n\t\n\t        if (!monkeyPath) return accumulatedPaths.concat([path]);\n\t\n\t        // Solving recursive path\n\t        var relatedMonkey = (0, _helpers.getIn)(_this3.tree._monkeys, monkeyPath).data;\n\t\n\t        return accumulatedPaths.concat(relatedMonkey.relatedPaths());\n\t      }, []);\n\t    }\n\t\n\t    /**\n\t     * Method used to update the tree's internal data with a lazy getter holding\n\t     * the computed data.\n\t     *\n\t     * @return {Monkey} - Returns itself for chaining purposes.\n\t     */\n\t  }, {\n\t    key: 'update',\n\t    value: function update() {\n\t      var deps = this.tree.project(this.projection);\n\t\n\t      var lazyGetter = (function (tree, def, data) {\n\t        var cache = null,\n\t            alreadyComputed = false;\n\t\n\t        return function () {\n\t\n\t          if (!alreadyComputed) {\n\t            cache = def.getter.apply(tree, def.type === 'object' ? [data] : data);\n\t\n\t            if (tree.options.immutable && def.options.immutable !== false) (0, _helpers.deepFreeze)(cache);\n\t\n\t            alreadyComputed = true;\n\t          }\n\t\n\t          return cache;\n\t        };\n\t      })(this.tree, this.definition, deps);\n\t\n\t      lazyGetter.isLazyGetter = true;\n\t\n\t      // Should we write the lazy getter in the tree or solve it right now?\n\t      if (this.tree.options.lazyMonkeys) {\n\t        this.tree._data = (0, _update3['default'])(this.tree._data, this.path, {\n\t          type: 'monkey',\n\t          value: lazyGetter\n\t        }, this.tree.options).data;\n\t      } else {\n\t        var result = (0, _update3['default'])(this.tree._data, this.path, {\n\t          type: 'set',\n\t          value: lazyGetter(),\n\t          options: {\n\t            mutableLeaf: !this.definition.options.immutable\n\t          }\n\t        }, this.tree.options);\n\t\n\t        if ('data' in result) this.tree._data = result.data;\n\t      }\n\t\n\t      // Notifying the monkey's update so we can handle recursivity\n\t      this.tree.emit('_monkey', { monkey: this, path: this.path });\n\t\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Method releasing the monkey from memory.\n\t     */\n\t  }, {\n\t    key: 'release',\n\t    value: function release() {\n\t\n\t      // Unbinding events\n\t      this.tree.off('write', this.writeListener);\n\t      this.tree.off('_monkey', this.monkeyListener);\n\t      this.state.killed = true;\n\t\n\t      // Deleting properties\n\t      // NOTE: not deleting this.definition because some strange things happen\n\t      // in the _refreshMonkeys method. See #372.\n\t      delete this.projection;\n\t      delete this.depPaths;\n\t      delete this.tree;\n\t    }\n\t  }]);\n\t\n\t  return Monkey;\n\t})();\n\t\n\texports.Monkey = Monkey;\n\n/***/ },\n/* 18 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Baobab Type Checking\n\t * =====================\n\t *\n\t * Helpers functions used throughout the library to perform some type\n\t * tests at runtime.\n\t *\n\t */\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\t\n\tvar _monkey = __webpack_require__(17);\n\t\n\tvar type = {};\n\t\n\t/**\n\t * Helpers\n\t * --------\n\t */\n\t\n\t/**\n\t * Checking whether the given variable is of any of the given types.\n\t *\n\t * @todo   Optimize this function by dropping `some`.\n\t *\n\t * @param  {mixed} target  - Variable to test.\n\t * @param  {array} allowed - Array of allowed types.\n\t * @return {boolean}\n\t */\n\tfunction anyOf(target, allowed) {\n\t  return allowed.some(function (t) {\n\t    return type[t](target);\n\t  });\n\t}\n\t\n\t/**\n\t * Simple types\n\t * -------------\n\t */\n\t\n\t/**\n\t * Checking whether the given variable is an array.\n\t *\n\t * @param  {mixed} target - Variable to test.\n\t * @return {boolean}\n\t */\n\ttype.array = function (target) {\n\t  return Array.isArray(target);\n\t};\n\t\n\t/**\n\t * Checking whether the given variable is an object.\n\t *\n\t * @param  {mixed} target - Variable to test.\n\t * @return {boolean}\n\t */\n\ttype.object = function (target) {\n\t  return target && typeof target === 'object' && !Array.isArray(target) && !(target instanceof Date) && !(target instanceof RegExp) && !(typeof Map === 'function' && target instanceof Map) && !(typeof Set === 'function' && target instanceof Set);\n\t};\n\t\n\t/**\n\t * Checking whether the given variable is a string.\n\t *\n\t * @param  {mixed} target - Variable to test.\n\t * @return {boolean}\n\t */\n\ttype.string = function (target) {\n\t  return typeof target === 'string';\n\t};\n\t\n\t/**\n\t * Checking whether the given variable is a number.\n\t *\n\t * @param  {mixed} target - Variable to test.\n\t * @return {boolean}\n\t */\n\ttype.number = function (target) {\n\t  return typeof target === 'number';\n\t};\n\t\n\t/**\n\t * Checking whether the given variable is a function.\n\t *\n\t * @param  {mixed} target - Variable to test.\n\t * @return {boolean}\n\t */\n\ttype['function'] = function (target) {\n\t  return typeof target === 'function';\n\t};\n\t\n\t/**\n\t * Checking whether the given variable is a JavaScript primitive.\n\t *\n\t * @param  {mixed} target - Variable to test.\n\t * @return {boolean}\n\t */\n\ttype.primitive = function (target) {\n\t  return target !== Object(target);\n\t};\n\t\n\t/**\n\t * Complex types\n\t * --------------\n\t */\n\t\n\t/**\n\t * Checking whether the given variable is a valid splicer.\n\t *\n\t * @param  {mixed} target    - Variable to test.\n\t * @param  {array} [allowed] - Optional valid types in path.\n\t * @return {boolean}\n\t */\n\ttype.splicer = function (target) {\n\t  if (!type.array(target) || target.length < 2) return false;\n\t\n\t  return anyOf(target[0], ['number', 'function', 'object']) && type.number(target[1]);\n\t};\n\t\n\t/**\n\t * Checking whether the given variable is a valid cursor path.\n\t *\n\t * @param  {mixed} target    - Variable to test.\n\t * @param  {array} [allowed] - Optional valid types in path.\n\t * @return {boolean}\n\t */\n\t\n\t// Order is important for performance reasons\n\tvar ALLOWED_FOR_PATH = ['string', 'number', 'function', 'object'];\n\t\n\ttype.path = function (target) {\n\t  if (!target && target !== 0 && target !== '') return false;\n\t\n\t  return [].concat(target).every(function (step) {\n\t    return anyOf(step, ALLOWED_FOR_PATH);\n\t  });\n\t};\n\t\n\t/**\n\t * Checking whether the given path is a dynamic one.\n\t *\n\t * @param  {mixed} path - The path to test.\n\t * @return {boolean}\n\t */\n\ttype.dynamicPath = function (path) {\n\t  return path.some(function (step) {\n\t    return type['function'](step) || type.object(step);\n\t  });\n\t};\n\t\n\t/**\n\t * Retrieve any monkey subpath in the given path or null if the path never comes\n\t * across computed data.\n\t *\n\t * @param  {mixed} data - The data to test.\n\t * @param  {array} path - The path to test.\n\t * @return {boolean}\n\t */\n\ttype.monkeyPath = function (data, path) {\n\t  var subpath = [];\n\t\n\t  var c = data,\n\t      i = undefined,\n\t      l = undefined;\n\t\n\t  for (i = 0, l = path.length; i < l; i++) {\n\t    subpath.push(path[i]);\n\t\n\t    if (typeof c !== 'object') return null;\n\t\n\t    c = c[path[i]];\n\t\n\t    if (c instanceof _monkey.Monkey) return subpath;\n\t  }\n\t\n\t  return null;\n\t};\n\t\n\t/**\n\t * Check if the given object property is a lazy getter used by a monkey.\n\t *\n\t * @param  {mixed}   o           - The target object.\n\t * @param  {string}  propertyKey - The property to test.\n\t * @return {boolean}\n\t */\n\ttype.lazyGetter = function (o, propertyKey) {\n\t  var descriptor = Object.getOwnPropertyDescriptor(o, propertyKey);\n\t\n\t  return descriptor && descriptor.get && descriptor.get.isLazyGetter === true;\n\t};\n\t\n\t/**\n\t * Returns the type of the given monkey definition or `null` if invalid.\n\t *\n\t * @param  {mixed} definition - The definition to check.\n\t * @return {string|null}\n\t */\n\ttype.monkeyDefinition = function (definition) {\n\t\n\t  if (type.object(definition)) {\n\t    if (!type['function'](definition.get) || definition.cursors && (!type.object(definition.cursors) || !Object.keys(definition.cursors).every(function (k) {\n\t      return type.path(definition.cursors[k]);\n\t    }))) return null;\n\t\n\t    return 'object';\n\t  } else if (type.array(definition)) {\n\t    var offset = 1;\n\t\n\t    if (type.object(definition[definition.length - 1])) offset++;\n\t\n\t    if (!type['function'](definition[definition.length - offset]) || !definition.slice(0, -offset).every(function (p) {\n\t      return type.path(p);\n\t    })) return null;\n\t\n\t    return 'array';\n\t  }\n\t\n\t  return null;\n\t};\n\t\n\t/**\n\t * Checking whether the given watcher definition is valid.\n\t *\n\t * @param  {mixed}   definition - The definition to check.\n\t * @return {boolean}\n\t */\n\ttype.watcherMapping = function (definition) {\n\t  return type.object(definition) && Object.keys(definition).every(function (k) {\n\t    return type.path(definition[k]);\n\t  });\n\t};\n\t\n\t/**\n\t * Checking whether the given string is a valid operation type.\n\t *\n\t * @param  {mixed} string - The string to test.\n\t * @return {boolean}\n\t */\n\t\n\t// Ordered by likeliness\n\tvar VALID_OPERATIONS = ['set', 'apply', 'push', 'unshift', 'concat', 'pop', 'shift', 'deepMerge', 'merge', 'splice', 'unset'];\n\t\n\ttype.operationType = function (string) {\n\t  return typeof string === 'string' && !! ~VALID_OPERATIONS.indexOf(string);\n\t};\n\t\n\texports['default'] = type;\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 19 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Baobab Update\n\t * ==============\n\t *\n\t * The tree's update scheme.\n\t */\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\texports['default'] = update;\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }\n\t\n\tvar _type = __webpack_require__(18);\n\t\n\tvar _type2 = _interopRequireDefault(_type);\n\t\n\tvar _helpers = __webpack_require__(20);\n\t\n\tfunction err(operation, expectedTarget, path) {\n\t  return (0, _helpers.makeError)('Baobab.update: cannot apply the \"' + operation + '\" on ' + ('a non ' + expectedTarget + ' (path: /' + path.join('/') + ').'), { path: path });\n\t}\n\t\n\t/**\n\t * Function aiming at applying a single update operation on the given tree's\n\t * data.\n\t *\n\t * @param  {mixed}  data      - The tree's data.\n\t * @param  {path}   path      - Path of the update.\n\t * @param  {object} operation - The operation to apply.\n\t * @param  {object} [opts]    - Optional options.\n\t * @return {mixed}            - Both the new tree's data and the updated node.\n\t */\n\t\n\tfunction update(data, path, operation) {\n\t  var opts = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];\n\t  var operationType = operation.type;\n\t  var value = operation.value;\n\t  var _operation$options = operation.options;\n\t  var operationOptions = _operation$options === undefined ? {} : _operation$options;\n\t\n\t  // Dummy root, so we can shift and alter the root\n\t  var dummy = { root: data },\n\t      dummyPath = ['root'].concat(_toConsumableArray(path)),\n\t      currentPath = [];\n\t\n\t  // Walking the path\n\t  var p = dummy,\n\t      i = undefined,\n\t      l = undefined,\n\t      s = undefined;\n\t\n\t  for (i = 0, l = dummyPath.length; i < l; i++) {\n\t\n\t    // Current item's reference is therefore p[s]\n\t    // The reason why we don't create a variable here for convenience\n\t    // is because we actually need to mutate the reference.\n\t    s = dummyPath[i];\n\t\n\t    // Updating the path\n\t    if (i > 0) currentPath.push(s);\n\t\n\t    // If we reached the end of the path, we apply the operation\n\t    if (i === l - 1) {\n\t\n\t      /**\n\t       * Set\n\t       */\n\t      if (operationType === 'set') {\n\t\n\t        // Purity check\n\t        if (opts.pure && p[s] === value) return { node: p[s] };\n\t\n\t        if (_type2['default'].lazyGetter(p, s)) {\n\t          Object.defineProperty(p, s, {\n\t            value: value,\n\t            enumerable: true,\n\t            configurable: true\n\t          });\n\t        } else if (opts.persistent && !operationOptions.mutableLeaf) {\n\t          p[s] = (0, _helpers.shallowClone)(value);\n\t        } else {\n\t          p[s] = value;\n\t        }\n\t      }\n\t\n\t      /**\n\t       * Monkey\n\t       */\n\t      else if (operationType === 'monkey') {\n\t          Object.defineProperty(p, s, {\n\t            get: value,\n\t            enumerable: true,\n\t            configurable: true\n\t          });\n\t        }\n\t\n\t        /**\n\t         * Apply\n\t         */\n\t        else if (operationType === 'apply') {\n\t            var result = value(p[s]);\n\t\n\t            // Purity check\n\t            if (opts.pure && p[s] === result) return { node: p[s] };\n\t\n\t            if (_type2['default'].lazyGetter(p, s)) {\n\t              Object.defineProperty(p, s, {\n\t                value: result,\n\t                enumerable: true,\n\t                configurable: true\n\t              });\n\t            } else if (opts.persistent) {\n\t              p[s] = (0, _helpers.shallowClone)(result);\n\t            } else {\n\t              p[s] = result;\n\t            }\n\t          }\n\t\n\t          /**\n\t           * Push\n\t           */\n\t          else if (operationType === 'push') {\n\t              if (!_type2['default'].array(p[s])) throw err('push', 'array', currentPath);\n\t\n\t              if (opts.persistent) p[s] = p[s].concat([value]);else p[s].push(value);\n\t            }\n\t\n\t            /**\n\t             * Unshift\n\t             */\n\t            else if (operationType === 'unshift') {\n\t                if (!_type2['default'].array(p[s])) throw err('unshift', 'array', currentPath);\n\t\n\t                if (opts.persistent) p[s] = [value].concat(p[s]);else p[s].unshift(value);\n\t              }\n\t\n\t              /**\n\t               * Concat\n\t               */\n\t              else if (operationType === 'concat') {\n\t                  if (!_type2['default'].array(p[s])) throw err('concat', 'array', currentPath);\n\t\n\t                  if (opts.persistent) p[s] = p[s].concat(value);else p[s].push.apply(p[s], value);\n\t                }\n\t\n\t                /**\n\t                 * Splice\n\t                 */\n\t                else if (operationType === 'splice') {\n\t                    if (!_type2['default'].array(p[s])) throw err('splice', 'array', currentPath);\n\t\n\t                    if (opts.persistent) p[s] = _helpers.splice.apply(null, [p[s]].concat(value));else p[s].splice.apply(p[s], value);\n\t                  }\n\t\n\t                  /**\n\t                   * Pop\n\t                   */\n\t                  else if (operationType === 'pop') {\n\t                      if (!_type2['default'].array(p[s])) throw err('pop', 'array', currentPath);\n\t\n\t                      if (opts.persistent) p[s] = (0, _helpers.splice)(p[s], -1, 1);else p[s].pop();\n\t                    }\n\t\n\t                    /**\n\t                     * Shift\n\t                     */\n\t                    else if (operationType === 'shift') {\n\t                        if (!_type2['default'].array(p[s])) throw err('shift', 'array', currentPath);\n\t\n\t                        if (opts.persistent) p[s] = (0, _helpers.splice)(p[s], 0, 1);else p[s].shift();\n\t                      }\n\t\n\t                      /**\n\t                       * Unset\n\t                       */\n\t                      else if (operationType === 'unset') {\n\t                          if (_type2['default'].object(p)) delete p[s];else if (_type2['default'].array(p)) p.splice(s, 1);\n\t                        }\n\t\n\t                        /**\n\t                         * Merge\n\t                         */\n\t                        else if (operationType === 'merge') {\n\t                            if (!_type2['default'].object(p[s])) throw err('merge', 'object', currentPath);\n\t\n\t                            if (opts.persistent) p[s] = (0, _helpers.shallowMerge)({}, p[s], value);else p[s] = (0, _helpers.shallowMerge)(p[s], value);\n\t                          }\n\t\n\t                          /**\n\t                           * Deep merge\n\t                           */\n\t                          else if (operationType === 'deepMerge') {\n\t                              if (!_type2['default'].object(p[s])) throw err('deepMerge', 'object', currentPath);\n\t\n\t                              if (opts.persistent) p[s] = (0, _helpers.deepMerge)({}, p[s], value);else p[s] = (0, _helpers.deepMerge)(p[s], value);\n\t                            }\n\t\n\t      // Deep freezing the resulting value\n\t      if (opts.immutable && !operationOptions.mutableLeaf) (0, _helpers.deepFreeze)(p);\n\t\n\t      break;\n\t    }\n\t\n\t    // If we reached a leaf, we override by setting an empty object\n\t    else if (_type2['default'].primitive(p[s])) {\n\t        p[s] = {};\n\t      }\n\t\n\t      // Else, we shift the reference and continue the path\n\t      else if (opts.persistent) {\n\t          p[s] = (0, _helpers.shallowClone)(p[s]);\n\t        }\n\t\n\t    // Should we freeze the current step before continuing?\n\t    if (opts.immutable && l > 0) (0, _helpers.freeze)(p);\n\t\n\t    p = p[s];\n\t  }\n\t\n\t  // If we are updating a dynamic node, we need not return the affected node\n\t  if (_type2['default'].lazyGetter(p, s)) return { data: dummy.root };\n\t\n\t  // Returning new data object\n\t  return { data: dummy.root, node: p[s] };\n\t}\n\t\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 20 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {/* eslint eqeqeq: 0 */\n\t\n\t/**\n\t * Baobab Helpers\n\t * ===============\n\t *\n\t * Miscellaneous helper functions.\n\t */\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\t\n\tvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\t\n\texports.arrayFrom = arrayFrom;\n\texports.before = before;\n\texports.coercePath = coercePath;\n\texports.getIn = getIn;\n\texports.makeError = makeError;\n\texports.solveRelativePath = solveRelativePath;\n\texports.solveUpdate = solveUpdate;\n\texports.splice = splice;\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\t\n\tvar _monkey = __webpack_require__(17);\n\t\n\tvar _type = __webpack_require__(18);\n\t\n\tvar _type2 = _interopRequireDefault(_type);\n\t\n\t/**\n\t * Noop function\n\t */\n\tvar noop = Function.prototype;\n\t\n\t/**\n\t * Function returning the index of the first element of a list matching the\n\t * given predicate.\n\t *\n\t * @param  {array}     a  - The target array.\n\t * @param  {function}  fn - The predicate function.\n\t * @return {mixed}        - The index of the first matching item or -1.\n\t */\n\tfunction index(a, fn) {\n\t  var i = undefined,\n\t      l = undefined;\n\t  for (i = 0, l = a.length; i < l; i++) {\n\t    if (fn(a[i])) return i;\n\t  }\n\t  return -1;\n\t}\n\t\n\t/**\n\t * Efficient slice function used to clone arrays or parts of them.\n\t *\n\t * @param  {array} array - The array to slice.\n\t * @return {array}       - The sliced array.\n\t */\n\tfunction slice(array) {\n\t  var newArray = new Array(array.length);\n\t\n\t  var i = undefined,\n\t      l = undefined;\n\t\n\t  for (i = 0, l = array.length; i < l; i++) newArray[i] = array[i];\n\t\n\t  return newArray;\n\t}\n\t\n\t/**\n\t * Archive abstraction\n\t *\n\t * @constructor\n\t * @param {integer} size - Maximum number of records to store.\n\t */\n\t\n\tvar Archive = (function () {\n\t  function Archive(size) {\n\t    _classCallCheck(this, Archive);\n\t\n\t    this.size = size;\n\t    this.records = [];\n\t  }\n\t\n\t  /**\n\t   * Function creating a real array from what should be an array but is not.\n\t   * I'm looking at you nasty `arguments`...\n\t   *\n\t   * @param  {mixed} culprit - The culprit to convert.\n\t   * @return {array}         - The real array.\n\t   */\n\t\n\t  /**\n\t   * Method retrieving the records.\n\t   *\n\t   * @return {array} - The records.\n\t   */\n\t\n\t  _createClass(Archive, [{\n\t    key: 'get',\n\t    value: function get() {\n\t      return this.records;\n\t    }\n\t\n\t    /**\n\t     * Method adding a record to the archive\n\t     *\n\t     * @param {object}  record - The record to store.\n\t     * @return {Archive}       - The archive itself for chaining purposes.\n\t     */\n\t  }, {\n\t    key: 'add',\n\t    value: function add(record) {\n\t      this.records.unshift(record);\n\t\n\t      // If the number of records is exceeded, we truncate the records\n\t      if (this.records.length > this.size) this.records.length = this.size;\n\t\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Method clearing the records.\n\t     *\n\t     * @return {Archive} - The archive itself for chaining purposes.\n\t     */\n\t  }, {\n\t    key: 'clear',\n\t    value: function clear() {\n\t      this.records = [];\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Method to go back in time.\n\t     *\n\t     * @param {integer} steps - Number of steps we should go back by.\n\t     * @return {number}       - The last record.\n\t     */\n\t  }, {\n\t    key: 'back',\n\t    value: function back(steps) {\n\t      var record = this.records[steps - 1];\n\t\n\t      if (record) this.records = this.records.slice(steps);\n\t      return record;\n\t    }\n\t  }]);\n\t\n\t  return Archive;\n\t})();\n\t\n\texports.Archive = Archive;\n\t\n\tfunction arrayFrom(culprit) {\n\t  return slice(culprit);\n\t}\n\t\n\t/**\n\t * Function decorating one function with another that will be called before the\n\t * decorated one.\n\t *\n\t * @param  {function} decorator - The decorating function.\n\t * @param  {function} fn        - The function to decorate.\n\t * @return {function}           - The decorated function.\n\t */\n\t\n\tfunction before(decorator, fn) {\n\t  return function () {\n\t    decorator.apply(null, arguments);\n\t    fn.apply(null, arguments);\n\t  };\n\t}\n\t\n\t/**\n\t * Function cloning the given regular expression. Supports `y` and `u` flags\n\t * already.\n\t *\n\t * @param  {RegExp} re - The target regular expression.\n\t * @return {RegExp}    - The cloned regular expression.\n\t */\n\tfunction cloneRegexp(re) {\n\t  var pattern = re.source;\n\t\n\t  var flags = '';\n\t\n\t  if (re.global) flags += 'g';\n\t  if (re.multiline) flags += 'm';\n\t  if (re.ignoreCase) flags += 'i';\n\t  if (re.sticky) flags += 'y';\n\t  if (re.unicode) flags += 'u';\n\t\n\t  return new RegExp(pattern, flags);\n\t}\n\t\n\t/**\n\t * Function cloning the given variable.\n\t *\n\t * @todo: implement a faster way to clone an array.\n\t *\n\t * @param  {boolean} deep - Should we deep clone the variable.\n\t * @param  {mixed}   item - The variable to clone\n\t * @return {mixed}        - The cloned variable.\n\t */\n\tfunction cloner(deep, item) {\n\t  if (!item || typeof item !== 'object' || item instanceof Error || item instanceof _monkey.MonkeyDefinition || item instanceof _monkey.Monkey || 'ArrayBuffer' in global && item instanceof ArrayBuffer) return item;\n\t\n\t  // Array\n\t  if (_type2['default'].array(item)) {\n\t    if (deep) {\n\t      var a = [];\n\t\n\t      var i = undefined,\n\t          l = undefined;\n\t\n\t      for (i = 0, l = item.length; i < l; i++) a.push(cloner(true, item[i]));\n\t      return a;\n\t    }\n\t\n\t    return slice(item);\n\t  }\n\t\n\t  // Date\n\t  if (item instanceof Date) return new Date(item.getTime());\n\t\n\t  // RegExp\n\t  if (item instanceof RegExp) return cloneRegexp(item);\n\t\n\t  // Object\n\t  if (_type2['default'].object(item)) {\n\t    var o = {};\n\t\n\t    var k = undefined;\n\t\n\t    // NOTE: could be possible to erase computed properties through `null`.\n\t    for (k in item) {\n\t      if (_type2['default'].lazyGetter(item, k)) {\n\t        Object.defineProperty(o, k, {\n\t          get: Object.getOwnPropertyDescriptor(item, k).get,\n\t          enumerable: true,\n\t          configurable: true\n\t        });\n\t      } else if (item.hasOwnProperty(k)) {\n\t        o[k] = deep ? cloner(true, item[k]) : item[k];\n\t      }\n\t    }\n\t    return o;\n\t  }\n\t\n\t  return item;\n\t}\n\t\n\t/**\n\t * Exporting shallow and deep cloning functions.\n\t */\n\tvar shallowClone = cloner.bind(null, false),\n\t    deepClone = cloner.bind(null, true);\n\t\n\texports.shallowClone = shallowClone;\n\texports.deepClone = deepClone;\n\t\n\t/**\n\t * Coerce the given variable into a full-fledged path.\n\t *\n\t * @param  {mixed} target - The variable to coerce.\n\t * @return {array}        - The array path.\n\t */\n\t\n\tfunction coercePath(target) {\n\t  if (target || target === 0 || target === '') return target;\n\t  return [];\n\t}\n\t\n\t/**\n\t * Function comparing an object's properties to a given descriptive\n\t * object.\n\t *\n\t * @param  {object} object      - The object to compare.\n\t * @param  {object} description - The description's mapping.\n\t * @return {boolean}            - Whether the object matches the description.\n\t */\n\tfunction compare(object, description) {\n\t  var ok = true,\n\t      k = undefined;\n\t\n\t  // If we reached here via a recursive call, object may be undefined because\n\t  // not all items in a collection will have the same deep nesting structure.\n\t  if (!object) return false;\n\t\n\t  for (k in description) {\n\t    if (_type2['default'].object(description[k])) {\n\t      ok = ok && compare(object[k], description[k]);\n\t    } else if (_type2['default'].array(description[k])) {\n\t      ok = ok && !! ~description[k].indexOf(object[k]);\n\t    } else {\n\t      if (object[k] !== description[k]) return false;\n\t    }\n\t  }\n\t\n\t  return ok;\n\t}\n\t\n\t/**\n\t * Function freezing the given variable if possible.\n\t *\n\t * @param  {boolean} deep - Should we recursively freeze the given objects?\n\t * @param  {object}  o    - The variable to freeze.\n\t * @return {object}    - The merged object.\n\t */\n\tfunction freezer(deep, o) {\n\t  if (typeof o !== 'object' || o === null || o instanceof _monkey.Monkey) return;\n\t\n\t  Object.freeze(o);\n\t\n\t  if (!deep) return;\n\t\n\t  if (Array.isArray(o)) {\n\t\n\t    // Iterating through the elements\n\t    var i = undefined,\n\t        l = undefined;\n\t\n\t    for (i = 0, l = o.length; i < l; i++) freezer(true, o[i]);\n\t  } else {\n\t    var p = undefined,\n\t        k = undefined;\n\t\n\t    for (k in o) {\n\t      if (_type2['default'].lazyGetter(o, k)) continue;\n\t\n\t      p = o[k];\n\t\n\t      if (!p || !o.hasOwnProperty(k) || typeof p !== 'object' || Object.isFrozen(p)) continue;\n\t\n\t      freezer(true, p);\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t * Exporting both `freeze` and `deepFreeze` functions.\n\t * Note that if the engine does not support `Object.freeze` then this will\n\t * export noop functions instead.\n\t */\n\tvar isFreezeSupported = typeof Object.freeze === 'function';\n\t\n\tvar freeze = isFreezeSupported ? freezer.bind(null, false) : noop,\n\t    deepFreeze = isFreezeSupported ? freezer.bind(null, true) : noop;\n\t\n\texports.freeze = freeze;\n\texports.deepFreeze = deepFreeze;\n\t\n\t/**\n\t * Function retrieving nested data within the given object and according to\n\t * the given path.\n\t *\n\t * @todo: work if dynamic path hit objects also.\n\t * @todo: memoized perfgetters.\n\t *\n\t * @param  {object}  object - The object we need to get data from.\n\t * @param  {array}   path   - The path to follow.\n\t * @return {object}  result            - The result.\n\t * @return {mixed}   result.data       - The data at path, or `undefined`.\n\t * @return {array}   result.solvedPath - The solved path or `null`.\n\t * @return {boolean} result.exists     - Does the path exists in the tree?\n\t */\n\tvar NOT_FOUND_OBJECT = { data: undefined, solvedPath: null, exists: false };\n\t\n\tfunction getIn(object, path) {\n\t  if (!path) return NOT_FOUND_OBJECT;\n\t\n\t  var solvedPath = [];\n\t\n\t  var exists = true,\n\t      c = object,\n\t      idx = undefined,\n\t      i = undefined,\n\t      l = undefined;\n\t\n\t  for (i = 0, l = path.length; i < l; i++) {\n\t    if (!c) return {\n\t      data: undefined,\n\t      solvedPath: solvedPath.concat(path.slice(i)),\n\t      exists: false\n\t    };\n\t\n\t    if (typeof path[i] === 'function') {\n\t      if (!_type2['default'].array(c)) return NOT_FOUND_OBJECT;\n\t\n\t      idx = index(c, path[i]);\n\t      if (! ~idx) return NOT_FOUND_OBJECT;\n\t\n\t      solvedPath.push(idx);\n\t      c = c[idx];\n\t    } else if (typeof path[i] === 'object') {\n\t      if (!_type2['default'].array(c)) return NOT_FOUND_OBJECT;\n\t\n\t      idx = index(c, function (e) {\n\t        return compare(e, path[i]);\n\t      });\n\t      if (! ~idx) return NOT_FOUND_OBJECT;\n\t\n\t      solvedPath.push(idx);\n\t      c = c[idx];\n\t    } else {\n\t      solvedPath.push(path[i]);\n\t      exists = typeof c === 'object' && path[i] in c;\n\t      c = c[path[i]];\n\t    }\n\t  }\n\t\n\t  return { data: c, solvedPath: solvedPath, exists: exists };\n\t}\n\t\n\t/**\n\t * Little helper returning a JavaScript error carrying some data with it.\n\t *\n\t * @param  {string} message - The error message.\n\t * @param  {object} [data]  - Optional data to assign to the error.\n\t * @return {Error}          - The created error.\n\t */\n\t\n\tfunction makeError(message, data) {\n\t  var err = new Error(message);\n\t\n\t  for (var k in data) {\n\t    err[k] = data[k];\n\t  }return err;\n\t}\n\t\n\t/**\n\t * Function taking n objects to merge them together.\n\t * Note 1): the latter object will take precedence over the first one.\n\t * Note 2): the first object will be mutated to allow for perf scenarios.\n\t * Note 3): this function will consider monkeys as leaves.\n\t *\n\t * @param  {boolean}   deep    - Whether the merge should be deep or not.\n\t * @param  {...object} objects - Objects to merge.\n\t * @return {object}            - The merged object.\n\t */\n\tfunction merger(deep) {\n\t  for (var _len = arguments.length, objects = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t    objects[_key - 1] = arguments[_key];\n\t  }\n\t\n\t  var o = objects[0];\n\t\n\t  var t = undefined,\n\t      i = undefined,\n\t      l = undefined,\n\t      k = undefined;\n\t\n\t  for (i = 1, l = objects.length; i < l; i++) {\n\t    t = objects[i];\n\t\n\t    for (k in t) {\n\t      if (deep && _type2['default'].object(t[k]) && !(t[k] instanceof _monkey.Monkey)) {\n\t        o[k] = merger(true, o[k] || {}, t[k]);\n\t      } else {\n\t        o[k] = t[k];\n\t      }\n\t    }\n\t  }\n\t\n\t  return o;\n\t}\n\t\n\t/**\n\t * Exporting both `shallowMerge` and `deepMerge` functions.\n\t */\n\tvar shallowMerge = merger.bind(null, false),\n\t    deepMerge = merger.bind(null, true);\n\t\n\texports.shallowMerge = shallowMerge;\n\texports.deepMerge = deepMerge;\n\t\n\t/**\n\t * Solving a potentially relative path.\n\t *\n\t * @param  {array} base - The base path from which to solve the path.\n\t * @param  {array} to   - The subpath to reach.\n\t * @param  {array}      - The solved absolute path.\n\t */\n\t\n\tfunction solveRelativePath(base, to) {\n\t  var solvedPath = [];\n\t\n\t  // Coercing to array\n\t  to = [].concat(to);\n\t\n\t  for (var i = 0, l = to.length; i < l; i++) {\n\t    var step = to[i];\n\t\n\t    if (step === '.') {\n\t      if (!i) solvedPath = base.slice(0);\n\t    } else if (step === '..') {\n\t      solvedPath = (!i ? base : solvedPath).slice(0, -1);\n\t    } else {\n\t      solvedPath.push(step);\n\t    }\n\t  }\n\t\n\t  return solvedPath;\n\t}\n\t\n\t/**\n\t * Function determining whether some paths in the tree were affected by some\n\t * updates that occurred at the given paths. This helper is mainly used at\n\t * cursor level to determine whether the cursor is concerned by the updates\n\t * fired at tree level.\n\t *\n\t * NOTES: 1) If performance become an issue, the following threefold loop\n\t *           can be simplified to a complex twofold one.\n\t *        2) A regex version could also work but I am not confident it would\n\t *           be faster.\n\t *        3) Another solution would be to keep a register of cursors like with\n\t *           the monkeys and update along this tree.\n\t *\n\t * @param  {array} affectedPaths - The paths that were updated.\n\t * @param  {array} comparedPaths - The paths that we are actually interested in.\n\t * @return {boolean}             - Is the update relevant to the compared\n\t *                                 paths?\n\t */\n\t\n\tfunction solveUpdate(affectedPaths, comparedPaths) {\n\t  var i = undefined,\n\t      j = undefined,\n\t      k = undefined,\n\t      l = undefined,\n\t      m = undefined,\n\t      n = undefined,\n\t      p = undefined,\n\t      c = undefined,\n\t      s = undefined;\n\t\n\t  // Looping through possible paths\n\t  for (i = 0, l = affectedPaths.length; i < l; i++) {\n\t    p = affectedPaths[i];\n\t\n\t    if (!p.length) return true;\n\t\n\t    // Looping through logged paths\n\t    for (j = 0, m = comparedPaths.length; j < m; j++) {\n\t      c = comparedPaths[j];\n\t\n\t      if (!c || !c.length) return true;\n\t\n\t      // Looping through steps\n\t      for (k = 0, n = c.length; k < n; k++) {\n\t        s = c[k];\n\t\n\t        // If path is not relevant, we break\n\t        // NOTE: the '!=' instead of '!==' is required here!\n\t        if (s != p[k]) break;\n\t\n\t        // If we reached last item and we are relevant\n\t        if (k + 1 === n || k + 1 === p.length) return true;\n\t      }\n\t    }\n\t  }\n\t\n\t  return false;\n\t}\n\t\n\t/**\n\t * Non-mutative version of the splice array method.\n\t *\n\t * @param  {array}    array        - The array to splice.\n\t * @param  {integer}  startIndex   - The start index.\n\t * @param  {integer}  nb           - Number of elements to remove.\n\t * @param  {...mixed} elements     - Elements to append after splicing.\n\t * @return {array}                 - The spliced array.\n\t */\n\t\n\tfunction splice(array, startIndex, nb) {\n\t  nb = Math.max(0, nb);\n\t\n\t  // Solving startIndex\n\t  if (_type2['default']['function'](startIndex)) startIndex = index(array, startIndex);\n\t  if (_type2['default'].object(startIndex)) startIndex = index(array, function (e) {\n\t    return compare(e, startIndex);\n\t  });\n\t\n\t  // Positive index\n\t\n\t  for (var _len2 = arguments.length, elements = Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {\n\t    elements[_key2 - 3] = arguments[_key2];\n\t  }\n\t\n\t  if (startIndex >= 0) return array.slice(0, startIndex).concat(elements).concat(array.slice(startIndex + nb));\n\t\n\t  // Negative index\n\t  return array.slice(0, array.length + startIndex).concat(elements).concat(array.slice(array.length + startIndex + nb));\n\t}\n\t\n\t/**\n\t * Function returning a unique incremental id each time it is called.\n\t *\n\t * @return {integer} - The latest unique id.\n\t */\n\tvar uniqid = (function () {\n\t  var i = 0;\n\t\n\t  return function () {\n\t    return i++;\n\t  };\n\t})();\n\t\n\texports.uniqid = uniqid;\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 21 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Baobab Watchers\n\t * ================\n\t *\n\t * Abstraction used to listen and retrieve data from multiple parts of a\n\t * Baobab tree at once.\n\t */\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\t\n\tvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\t\n\tvar _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar _emmett = __webpack_require__(15);\n\t\n\tvar _emmett2 = _interopRequireDefault(_emmett);\n\t\n\tvar _cursor = __webpack_require__(16);\n\t\n\tvar _cursor2 = _interopRequireDefault(_cursor);\n\t\n\tvar _type = __webpack_require__(18);\n\t\n\tvar _type2 = _interopRequireDefault(_type);\n\t\n\tvar _helpers = __webpack_require__(20);\n\t\n\t/**\n\t * Watcher class.\n\t *\n\t * @constructor\n\t * @param {Baobab} tree     - The watched tree.\n\t * @param {object} mapping  - A mapping of the paths to watch in the tree.\n\t */\n\t\n\tvar Watcher = (function (_Emitter) {\n\t  _inherits(Watcher, _Emitter);\n\t\n\t  function Watcher(tree, mapping) {\n\t    var _this = this;\n\t\n\t    _classCallCheck(this, Watcher);\n\t\n\t    _get(Object.getPrototypeOf(Watcher.prototype), 'constructor', this).call(this);\n\t\n\t    // Properties\n\t    this.tree = tree;\n\t    this.mapping = null;\n\t\n\t    this.state = {\n\t      killed: false\n\t    };\n\t\n\t    // Initializing\n\t    this.refresh(mapping);\n\t\n\t    // Listening\n\t    this.handler = function (e) {\n\t      if (_this.state.killed) return;\n\t\n\t      var watchedPaths = _this.getWatchedPaths();\n\t\n\t      if ((0, _helpers.solveUpdate)(e.data.paths, watchedPaths)) return _this.emit('update');\n\t    };\n\t\n\t    this.tree.on('update', this.handler);\n\t  }\n\t\n\t  /**\n\t   * Method used to get the current watched paths.\n\t   *\n\t   * @return {array} - The array of watched paths.\n\t   */\n\t\n\t  _createClass(Watcher, [{\n\t    key: 'getWatchedPaths',\n\t    value: function getWatchedPaths() {\n\t      var _this2 = this;\n\t\n\t      var rawPaths = Object.keys(this.mapping).map(function (k) {\n\t        var v = _this2.mapping[k];\n\t\n\t        // Watcher mappings can accept a cursor\n\t        if (v instanceof _cursor2['default']) return v.solvedPath;\n\t\n\t        return _this2.mapping[k];\n\t      });\n\t\n\t      return rawPaths.reduce(function (cp, p) {\n\t\n\t        // Handling path polymorphisms\n\t        p = [].concat(p);\n\t\n\t        // Dynamic path?\n\t        if (_type2['default'].dynamicPath(p)) p = (0, _helpers.getIn)(_this2.tree._data, p).solvedPath;\n\t\n\t        if (!p) return cp;\n\t\n\t        // Facet path?\n\t        var monkeyPath = _type2['default'].monkeyPath(_this2.tree._monkeys, p);\n\t\n\t        if (monkeyPath) return cp.concat((0, _helpers.getIn)(_this2.tree._monkeys, monkeyPath).data.relatedPaths());\n\t\n\t        return cp.concat([p]);\n\t      }, []);\n\t    }\n\t\n\t    /**\n\t     * Method used to return a map of the watcher's cursors.\n\t     *\n\t     * @return {object} - TMap of relevant cursors.\n\t     */\n\t  }, {\n\t    key: 'getCursors',\n\t    value: function getCursors() {\n\t      var _this3 = this;\n\t\n\t      var cursors = {};\n\t\n\t      Object.keys(this.mapping).forEach(function (k) {\n\t        var path = _this3.mapping[k];\n\t\n\t        if (path instanceof _cursor2['default']) cursors[k] = path;else cursors[k] = _this3.tree.select(path);\n\t      });\n\t\n\t      return cursors;\n\t    }\n\t\n\t    /**\n\t     * Method used to refresh the watcher's mapping.\n\t     *\n\t     * @param  {object}  mapping  - The new mapping to apply.\n\t     * @return {Watcher}          - Itself for chaining purposes.\n\t     */\n\t  }, {\n\t    key: 'refresh',\n\t    value: function refresh(mapping) {\n\t\n\t      if (!_type2['default'].watcherMapping(mapping)) throw (0, _helpers.makeError)('Baobab.watch: invalid mapping.', { mapping: mapping });\n\t\n\t      this.mapping = mapping;\n\t\n\t      // Creating the get method\n\t      var projection = {};\n\t\n\t      for (var k in mapping) {\n\t        projection[k] = mapping[k] instanceof _cursor2['default'] ? mapping[k].path : mapping[k];\n\t      }this.get = this.tree.project.bind(this.tree, projection);\n\t    }\n\t\n\t    /**\n\t     * Methods releasing the watcher from memory.\n\t     */\n\t  }, {\n\t    key: 'release',\n\t    value: function release() {\n\t\n\t      this.tree.off('update', this.handler);\n\t      this.state.killed = true;\n\t      this.kill();\n\t    }\n\t  }]);\n\t\n\t  return Watcher;\n\t})(_emmett2['default']);\n\t\n\texports['default'] = Watcher;\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 22 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\tvar addToSubscriptionIdsStorage = exports.addToSubscriptionIdsStorage = function addToSubscriptionIdsStorage(id) {\n\t    var existingSubscriptionIds = [];\n\t    if (window.localStorage.getItem(\"subscriptionIds\")) {\n\t        existingSubscriptionIds = JSON.parse(window.localStorage.getItem(\"subscriptionIds\"));\n\t    }\n\t    existingSubscriptionIds.push(id);\n\t    window.localStorage.setItem(\"subscriptionIds\", JSON.stringify(existingSubscriptionIds));\n\t};\n\t\n\tvar removeFromSubscriptionIdsStorage = exports.removeFromSubscriptionIdsStorage = function removeFromSubscriptionIdsStorage(id) {\n\t    var existingSubscriptionIds = [];\n\t    if (window.localStorage.getItem(\"subscriptionIds\")) {\n\t        existingSubscriptionIds = JSON.parse(window.localStorage.getItem(\"subscriptionIds\"));\n\t    }\n\t    existingSubscriptionIds = existingSubscriptionIds.filter(function (l) {\n\t        return l != id;\n\t    });\n\t\n\t    window.localStorage.setItem(\"subscriptionIds\", JSON.stringify(existingSubscriptionIds));\n\t};\n\t\n\tvar getSubscriptionIdsFromStorage = exports.getSubscriptionIdsFromStorage = function getSubscriptionIdsFromStorage() {\n\t    if (window.localStorage.getItem(\"subscriptionIds\")) {\n\t        return JSON.parse(window.localStorage.getItem(\"subscriptionIds\"));\n\t    }\n\t    return [];\n\t};\n\n/***/ },\n/* 23 */\n/***/ function(module, exports) {\n\n\tmodule.exports = \"<ion-modal-view> <ion-header-bar> <h1 class=title> </h1> <button class=\\\"button icon icon-left ion-ios-close-outline\\\" ng-click=closeModal()></button> </ion-header-bar> <ion-content> <ion-list> <ion-item ng-click=addLocation(loc) ng-repeat=\\\"loc in getLocationsForModal()\\\"> {{ loc.name }} </ion-item> </ion-list> </ion-content> </ion-modal-view>\";\n\n/***/ },\n/* 24 */\n/***/ function(module, exports) {\n\n\tmodule.exports = \"<ion-view view-title=Dashboard> <ion-nav-title> WEATHER GONG </ion-nav-title> <ion-content class=padding id=dashboard-page-container> <div class=current-weather-container> <div class=\\\"row header\\\"> <div class=col> </div> <div class=col></div> <div class=col></div> <div class=col> </div> <div class=col></div> <div class=col>'</div> <div class=col> </div> <div class=col></div> <div class=col></div> </div> <div class=row ng-repeat=\\\"row in currentData\\\"> <div class=col> <button class=\\\"button icon ion-ios-minus-outline\\\" ng-click=removeLocation(row.id)></button> </div> <div class=col>{{ row.location }}</div> <div class=col>{{ row.time }}</div> <div class=col>{{ row.wind }}</div> <div class=col>{{ row.windDirection }}</div> <div class=col>{{ row.temperature }}</div> <div class=col>{{ row.wave }}</div> <div class=col>{{ row.waveDirection }}</div> <div class=col> <button class=\\\"icon ion-ios-camera-outline\\\"/></div> </div> <div class=row> <div class=col> <button class=\\\"button icon ion-ios-plus-outline\\\" ng-click=showAddLocation()></button> </div> </div> </div> <div class=forecast-container> <h3> ( )</h3> <div class=\\\"row header\\\"> <div class=col> </div> <div class=col></div> <div class=col></div> <div class=col></div> <div class=col></div> <div class=col>'</div> <div class=col> </div> <div class=col></div> <div class=col></div> </div> <div class=row ng-repeat=\\\"row in forecastData\\\"> <div class=col> <button class=\\\"button icon ion-ios-minus-outline\\\" ng-click=removeLocation(row.id)></button> </div> <div class=col>{{ row.location }}</div> <div class=col>{{ row.time }}</div> <div class=col>{{ row.wind }}</div> <div class=col>{{ row.windDirection }}</div> <div class=col>{{ row.temperature }}</div> <div class=col>{{ row.wave }}</div> <div class=col>{{ row.waveDirection }}</div> <div class=col></div> </div> <div class=row> <div class=col> <button class=\\\"button icon ion-ios-plus-outline\\\" ng-click=showAddLocation()></button> </div> </div> </div> </ion-content> </ion-view>\";\n\n/***/ },\n/* 25 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// style-loader: Adds some css to the DOM by adding a <style> tag\n\t\n\t// load the styles\n\tvar content = __webpack_require__(26);\n\tif(typeof content === 'string') content = [[module.id, content, '']];\n\t// add the styles to the DOM\n\tvar update = __webpack_require__(28)(content, {});\n\tif(content.locals) module.exports = content.locals;\n\t// Hot Module Replacement\n\tif(false) {\n\t\t// When the styles change, update the <style> tags\n\t\tif(!content.locals) {\n\t\t\tmodule.hot.accept(\"!!./../../../../node_modules/css-loader/index.js!./../../../../node_modules/sass-loader/index.js!./dashboard.scss\", function() {\n\t\t\t\tvar newContent = require(\"!!./../../../../node_modules/css-loader/index.js!./../../../../node_modules/sass-loader/index.js!./dashboard.scss\");\n\t\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\t\tupdate(newContent);\n\t\t\t});\n\t\t}\n\t\t// When the module is disposed, remove the <style> tags\n\t\tmodule.hot.dispose(function() { update(); });\n\t}\n\n/***/ },\n/* 26 */\n/***/ function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(27)();\n\t// imports\n\t\n\t\n\t// module\n\texports.push([module.id, \"#dashboard-page-container .scroll{direction:rtl}#dashboard-page-container .scroll>div{margin-bottom:60px;word-wrap:normal}#dashboard-page-container .scroll>div .col{text-align:right;min-width:37px;font-size:8px}#dashboard-page-container .scroll>div .col .button{background:transparent;min-height:auto;min-width:auto}#dashboard-page-container .scroll>div .col .button.icon:before{line-height:20px}#dashboard-page-container .scroll>div .col button.icon{font-size:21px;line-height:0;background:none;padding:0;margin:0;outline:0;border:none}\", \"\"]);\n\t\n\t// exports\n\n\n/***/ },\n/* 27 */\n/***/ function(module, exports) {\n\n\t/*\r\n\t\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\t\tAuthor Tobias Koppers @sokra\r\n\t*/\r\n\t// css base code, injected by the css-loader\r\n\tmodule.exports = function() {\r\n\t\tvar list = [];\r\n\t\r\n\t\t// return the list of modules as css string\r\n\t\tlist.toString = function toString() {\r\n\t\t\tvar result = [];\r\n\t\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\t\tvar item = this[i];\r\n\t\t\t\tif(item[2]) {\r\n\t\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\r\n\t\t\t\t} else {\r\n\t\t\t\t\tresult.push(item[1]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn result.join(\"\");\r\n\t\t};\r\n\t\r\n\t\t// import a list of modules into the list\r\n\t\tlist.i = function(modules, mediaQuery) {\r\n\t\t\tif(typeof modules === \"string\")\r\n\t\t\t\tmodules = [[null, modules, \"\"]];\r\n\t\t\tvar alreadyImportedModules = {};\r\n\t\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\t\tvar id = this[i][0];\r\n\t\t\t\tif(typeof id === \"number\")\r\n\t\t\t\t\talreadyImportedModules[id] = true;\r\n\t\t\t}\r\n\t\t\tfor(i = 0; i < modules.length; i++) {\r\n\t\t\t\tvar item = modules[i];\r\n\t\t\t\t// skip already imported module\r\n\t\t\t\t// this implementation is not 100% perfect for weird media query combinations\r\n\t\t\t\t//  when a module is imported multiple times with different media queries.\r\n\t\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\r\n\t\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\r\n\t\t\t\t\tif(mediaQuery && !item[2]) {\r\n\t\t\t\t\t\titem[2] = mediaQuery;\r\n\t\t\t\t\t} else if(mediaQuery) {\r\n\t\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\r\n\t\t\t\t\t}\r\n\t\t\t\t\tlist.push(item);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t\treturn list;\r\n\t};\r\n\n\n/***/ },\n/* 28 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*\r\n\t\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\t\tAuthor Tobias Koppers @sokra\r\n\t*/\r\n\tvar stylesInDom = {},\r\n\t\tmemoize = function(fn) {\r\n\t\t\tvar memo;\r\n\t\t\treturn function () {\r\n\t\t\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\r\n\t\t\t\treturn memo;\r\n\t\t\t};\r\n\t\t},\r\n\t\tisOldIE = memoize(function() {\r\n\t\t\treturn /msie [6-9]\\b/.test(window.navigator.userAgent.toLowerCase());\r\n\t\t}),\r\n\t\tgetHeadElement = memoize(function () {\r\n\t\t\treturn document.head || document.getElementsByTagName(\"head\")[0];\r\n\t\t}),\r\n\t\tsingletonElement = null,\r\n\t\tsingletonCounter = 0,\r\n\t\tstyleElementsInsertedAtTop = [];\r\n\t\r\n\tmodule.exports = function(list, options) {\r\n\t\tif(true) {\r\n\t\t\tif(typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\r\n\t\t}\r\n\t\r\n\t\toptions = options || {};\r\n\t\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\r\n\t\t// tags it will allow on a page\r\n\t\tif (typeof options.singleton === \"undefined\") options.singleton = isOldIE();\r\n\t\r\n\t\t// By default, add <style> tags to the bottom of <head>.\r\n\t\tif (typeof options.insertAt === \"undefined\") options.insertAt = \"bottom\";\r\n\t\r\n\t\tvar styles = listToStyles(list);\r\n\t\taddStylesToDom(styles, options);\r\n\t\r\n\t\treturn function update(newList) {\r\n\t\t\tvar mayRemove = [];\r\n\t\t\tfor(var i = 0; i < styles.length; i++) {\r\n\t\t\t\tvar item = styles[i];\r\n\t\t\t\tvar domStyle = stylesInDom[item.id];\r\n\t\t\t\tdomStyle.refs--;\r\n\t\t\t\tmayRemove.push(domStyle);\r\n\t\t\t}\r\n\t\t\tif(newList) {\r\n\t\t\t\tvar newStyles = listToStyles(newList);\r\n\t\t\t\taddStylesToDom(newStyles, options);\r\n\t\t\t}\r\n\t\t\tfor(var i = 0; i < mayRemove.length; i++) {\r\n\t\t\t\tvar domStyle = mayRemove[i];\r\n\t\t\t\tif(domStyle.refs === 0) {\r\n\t\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++)\r\n\t\t\t\t\t\tdomStyle.parts[j]();\r\n\t\t\t\t\tdelete stylesInDom[domStyle.id];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n\t\r\n\tfunction addStylesToDom(styles, options) {\r\n\t\tfor(var i = 0; i < styles.length; i++) {\r\n\t\t\tvar item = styles[i];\r\n\t\t\tvar domStyle = stylesInDom[item.id];\r\n\t\t\tif(domStyle) {\r\n\t\t\t\tdomStyle.refs++;\r\n\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\r\n\t\t\t\t\tdomStyle.parts[j](item.parts[j]);\r\n\t\t\t\t}\r\n\t\t\t\tfor(; j < item.parts.length; j++) {\r\n\t\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tvar parts = [];\r\n\t\t\t\tfor(var j = 0; j < item.parts.length; j++) {\r\n\t\t\t\t\tparts.push(addStyle(item.parts[j], options));\r\n\t\t\t\t}\r\n\t\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction listToStyles(list) {\r\n\t\tvar styles = [];\r\n\t\tvar newStyles = {};\r\n\t\tfor(var i = 0; i < list.length; i++) {\r\n\t\t\tvar item = list[i];\r\n\t\t\tvar id = item[0];\r\n\t\t\tvar css = item[1];\r\n\t\t\tvar media = item[2];\r\n\t\t\tvar sourceMap = item[3];\r\n\t\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\r\n\t\t\tif(!newStyles[id])\r\n\t\t\t\tstyles.push(newStyles[id] = {id: id, parts: [part]});\r\n\t\t\telse\r\n\t\t\t\tnewStyles[id].parts.push(part);\r\n\t\t}\r\n\t\treturn styles;\r\n\t}\r\n\t\r\n\tfunction insertStyleElement(options, styleElement) {\r\n\t\tvar head = getHeadElement();\r\n\t\tvar lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];\r\n\t\tif (options.insertAt === \"top\") {\r\n\t\t\tif(!lastStyleElementInsertedAtTop) {\r\n\t\t\t\thead.insertBefore(styleElement, head.firstChild);\r\n\t\t\t} else if(lastStyleElementInsertedAtTop.nextSibling) {\r\n\t\t\t\thead.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);\r\n\t\t\t} else {\r\n\t\t\t\thead.appendChild(styleElement);\r\n\t\t\t}\r\n\t\t\tstyleElementsInsertedAtTop.push(styleElement);\r\n\t\t} else if (options.insertAt === \"bottom\") {\r\n\t\t\thead.appendChild(styleElement);\r\n\t\t} else {\r\n\t\t\tthrow new Error(\"Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.\");\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction removeStyleElement(styleElement) {\r\n\t\tstyleElement.parentNode.removeChild(styleElement);\r\n\t\tvar idx = styleElementsInsertedAtTop.indexOf(styleElement);\r\n\t\tif(idx >= 0) {\r\n\t\t\tstyleElementsInsertedAtTop.splice(idx, 1);\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction createStyleElement(options) {\r\n\t\tvar styleElement = document.createElement(\"style\");\r\n\t\tstyleElement.type = \"text/css\";\r\n\t\tinsertStyleElement(options, styleElement);\r\n\t\treturn styleElement;\r\n\t}\r\n\t\r\n\tfunction createLinkElement(options) {\r\n\t\tvar linkElement = document.createElement(\"link\");\r\n\t\tlinkElement.rel = \"stylesheet\";\r\n\t\tinsertStyleElement(options, linkElement);\r\n\t\treturn linkElement;\r\n\t}\r\n\t\r\n\tfunction addStyle(obj, options) {\r\n\t\tvar styleElement, update, remove;\r\n\t\r\n\t\tif (options.singleton) {\r\n\t\t\tvar styleIndex = singletonCounter++;\r\n\t\t\tstyleElement = singletonElement || (singletonElement = createStyleElement(options));\r\n\t\t\tupdate = applyToSingletonTag.bind(null, styleElement, styleIndex, false);\r\n\t\t\tremove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);\r\n\t\t} else if(obj.sourceMap &&\r\n\t\t\ttypeof URL === \"function\" &&\r\n\t\t\ttypeof URL.createObjectURL === \"function\" &&\r\n\t\t\ttypeof URL.revokeObjectURL === \"function\" &&\r\n\t\t\ttypeof Blob === \"function\" &&\r\n\t\t\ttypeof btoa === \"function\") {\r\n\t\t\tstyleElement = createLinkElement(options);\r\n\t\t\tupdate = updateLink.bind(null, styleElement);\r\n\t\t\tremove = function() {\r\n\t\t\t\tremoveStyleElement(styleElement);\r\n\t\t\t\tif(styleElement.href)\r\n\t\t\t\t\tURL.revokeObjectURL(styleElement.href);\r\n\t\t\t};\r\n\t\t} else {\r\n\t\t\tstyleElement = createStyleElement(options);\r\n\t\t\tupdate = applyToTag.bind(null, styleElement);\r\n\t\t\tremove = function() {\r\n\t\t\t\tremoveStyleElement(styleElement);\r\n\t\t\t};\r\n\t\t}\r\n\t\r\n\t\tupdate(obj);\r\n\t\r\n\t\treturn function updateStyle(newObj) {\r\n\t\t\tif(newObj) {\r\n\t\t\t\tif(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)\r\n\t\t\t\t\treturn;\r\n\t\t\t\tupdate(obj = newObj);\r\n\t\t\t} else {\r\n\t\t\t\tremove();\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n\t\r\n\tvar replaceText = (function () {\r\n\t\tvar textStore = [];\r\n\t\r\n\t\treturn function (index, replacement) {\r\n\t\t\ttextStore[index] = replacement;\r\n\t\t\treturn textStore.filter(Boolean).join('\\n');\r\n\t\t};\r\n\t})();\r\n\t\r\n\tfunction applyToSingletonTag(styleElement, index, remove, obj) {\r\n\t\tvar css = remove ? \"\" : obj.css;\r\n\t\r\n\t\tif (styleElement.styleSheet) {\r\n\t\t\tstyleElement.styleSheet.cssText = replaceText(index, css);\r\n\t\t} else {\r\n\t\t\tvar cssNode = document.createTextNode(css);\r\n\t\t\tvar childNodes = styleElement.childNodes;\r\n\t\t\tif (childNodes[index]) styleElement.removeChild(childNodes[index]);\r\n\t\t\tif (childNodes.length) {\r\n\t\t\t\tstyleElement.insertBefore(cssNode, childNodes[index]);\r\n\t\t\t} else {\r\n\t\t\t\tstyleElement.appendChild(cssNode);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction applyToTag(styleElement, obj) {\r\n\t\tvar css = obj.css;\r\n\t\tvar media = obj.media;\r\n\t\r\n\t\tif(media) {\r\n\t\t\tstyleElement.setAttribute(\"media\", media)\r\n\t\t}\r\n\t\r\n\t\tif(styleElement.styleSheet) {\r\n\t\t\tstyleElement.styleSheet.cssText = css;\r\n\t\t} else {\r\n\t\t\twhile(styleElement.firstChild) {\r\n\t\t\t\tstyleElement.removeChild(styleElement.firstChild);\r\n\t\t\t}\r\n\t\t\tstyleElement.appendChild(document.createTextNode(css));\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction updateLink(linkElement, obj) {\r\n\t\tvar css = obj.css;\r\n\t\tvar sourceMap = obj.sourceMap;\r\n\t\r\n\t\tif(sourceMap) {\r\n\t\t\t// http://stackoverflow.com/a/26603875\r\n\t\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\r\n\t\t}\r\n\t\r\n\t\tvar blob = new Blob([css], { type: \"text/css\" });\r\n\t\r\n\t\tvar oldSrc = linkElement.href;\r\n\t\r\n\t\tlinkElement.href = URL.createObjectURL(blob);\r\n\t\r\n\t\tif(oldSrc)\r\n\t\t\tURL.revokeObjectURL(oldSrc);\r\n\t}\r\n\n\n/***/ },\n/* 29 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\texports.default = function ($stateProvider, $urlRouterProvider) {\n\t    $stateProvider\n\t\n\t    // setup an abstract state for the tabs directive\n\t    .state('tab', {\n\t        url: '/tab',\n\t        abstract: true,\n\t        template: __webpack_require__(30)\n\t    });\n\t};\n\n/***/ },\n/* 30 */\n/***/ function(module, exports) {\n\n\tmodule.exports = \"<ion-tabs class=\\\"tabs-icon-top tabs-color-active-positive\\\"> <ion-tab title= href=#/tab/chats> <ion-nav-view name=tab-chats></ion-nav-view> </ion-tab> <ion-tab title=\\\" \\\" href=#/tab/account> <ion-nav-view name=tab-account></ion-nav-view> </ion-tab> <ion-tab title=\\\" \\\" href=#/tab/account> <ion-nav-view name=tab-account></ion-nav-view> </ion-tab> <ion-tab icon-off=ion-ios-home icon-on=ion-ios-home href=#/tab/dash> <ion-nav-view name=tab-dash></ion-nav-view> </ion-tab> </ion-tabs>\";\n\n/***/ },\n/* 31 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// style-loader: Adds some css to the DOM by adding a <style> tag\n\t\n\t// load the styles\n\tvar content = __webpack_require__(32);\n\tif(typeof content === 'string') content = [[module.id, content, '']];\n\t// add the styles to the DOM\n\tvar update = __webpack_require__(28)(content, {});\n\tif(content.locals) module.exports = content.locals;\n\t// Hot Module Replacement\n\tif(false) {\n\t\t// When the styles change, update the <style> tags\n\t\tif(!content.locals) {\n\t\t\tmodule.hot.accept(\"!!./../../../node_modules/css-loader/index.js!./../../../node_modules/sass-loader/index.js!./tabs.scss\", function() {\n\t\t\t\tvar newContent = require(\"!!./../../../node_modules/css-loader/index.js!./../../../node_modules/sass-loader/index.js!./tabs.scss\");\n\t\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\t\tupdate(newContent);\n\t\t\t});\n\t\t}\n\t\t// When the module is disposed, remove the <style> tags\n\t\tmodule.hot.dispose(function() { update(); });\n\t}\n\n/***/ },\n/* 32 */\n/***/ function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(27)();\n\t// imports\n\t\n\t\n\t// module\n\texports.push([module.id, \".tabs-icon-top>.tabs .tab-item{line-height:40px;font-size:15px}\", \"\"]);\n\t\n\t// exports\n\n\n/***/ },\n/* 33 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// style-loader: Adds some css to the DOM by adding a <style> tag\n\t\n\t// load the styles\n\tvar content = __webpack_require__(34);\n\tif(typeof content === 'string') content = [[module.id, content, '']];\n\t// add the styles to the DOM\n\tvar update = __webpack_require__(28)(content, {});\n\tif(content.locals) module.exports = content.locals;\n\t// Hot Module Replacement\n\tif(false) {\n\t\t// When the styles change, update the <style> tags\n\t\tif(!content.locals) {\n\t\t\tmodule.hot.accept(\"!!./../../node_modules/css-loader/index.js!./../../node_modules/sass-loader/index.js!./index.scss\", function() {\n\t\t\t\tvar newContent = require(\"!!./../../node_modules/css-loader/index.js!./../../node_modules/sass-loader/index.js!./index.scss\");\n\t\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\t\tupdate(newContent);\n\t\t\t});\n\t\t}\n\t\t// When the module is disposed, remove the <style> tags\n\t\tmodule.hot.dispose(function() { update(); });\n\t}\n\n/***/ },\n/* 34 */\n/***/ function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(27)();\n\t// imports\n\t\n\t\n\t// module\n\texports.push([module.id, \"\", \"\"]);\n\t\n\t// exports\n\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** bundle.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 1fa6ef086c2ee59145ad\n **/","import components from './components';\r\nimport './scss/index.scss';\r\nangular.module('app', ['ionic', components])\r\n.run(function($ionicPlatform) {\r\n    $ionicPlatform.ready(function() {\r\n        // Hide the accessory bar by default (remove this to show the accessory bar above the keyboard\r\n        // for form inputs)\r\n        if (window.cordova && window.cordova.plugins && window.cordova.plugins.Keyboard) {\r\n            cordova.plugins.Keyboard.hideKeyboardAccessoryBar(true);\r\n            cordova.plugins.Keyboard.disableScroll(true);\r\n\r\n        }\r\n        if (window.StatusBar) {\r\n            // org.apache.cordova.statusbar required\r\n            StatusBar.styleDefault();\r\n        }\r\n    });\r\n}).config(function($stateProvider, $urlRouterProvider) {\r\n    $urlRouterProvider.otherwise('/tab/dash');\r\n});\n\n\n/** WEBPACK FOOTER **\n ** ./app/index.js\n **/","import tabs from './tabs';\r\n\r\nexport default angular.module('app.components', [tabs])\r\n  .name;\n\n\n/** WEBPACK FOOTER **\n ** ./app/components/index.js\n **/","import dashboard from './dashboard';\r\nimport routing from './tabs.route';\r\nimport './tabs.scss';\r\nexport default angular.module('app.components.tabs', [dashboard])\r\n  .config(routing)\r\n  .name;\n\n\n/** WEBPACK FOOTER **\n ** ./app/components/tabs/index.js\n **/","import routing from './dashboard.route';\r\nimport './dashboard.scss';\r\n\r\nexport default angular.module('app.components.tabs.dashboard', [])\r\n  .config(routing)\r\n  .name;\n\n\n/** WEBPACK FOOTER **\n ** ./app/components/tabs/dashboard/index.js\n **/","import controller from './dashboard.controller';\r\nimport template from './dashboard.html';\r\n\r\nexport default ($stateProvider, $urlRouterProvider) => {\r\n    $stateProvider\r\n        .state('tab.dash', {\r\n            url: '/dash',\r\n            views: {\r\n                'tab-dash': {\r\n                    template,\r\n                    controller\r\n                }\r\n            }\r\n        })\r\n}\n\n\n/** WEBPACK FOOTER **\n ** ./app/components/tabs/dashboard/dashboard.route.js\n **/","import tree from '../../../store';\r\nimport { \r\n    addToSubscriptionIdsStorage,\r\n    removeFromSubscriptionIdsStorage,\r\n    getSubscriptionIdsFromStorage\r\n} from '../../../storage/subscriptionIds.helper';\r\nvar locationModalTemplate = require('./locationModal.html');\r\n\r\nconst connectSubscriptions = (data, scope, $timeout) => {\r\n    $timeout(() => {\r\n        scope.currentData = scope.forecastData = data;\r\n    });\r\n}\r\n\r\nconst connectLocations = (data, scope, $timeout) => {\r\n    $timeout(() => {\r\n        scope.locations = data;\r\n    });\r\n}\r\n\r\nexport default ['$scope', '$timeout', '$ionicModal',\r\n    (scope, $timeout, $ionicModal) => {\r\n        const subscriptionSelector = tree.select('subscriptions', 'subscribedLocations');\r\n        const locationSelector = tree.select('locations');\r\n        connectSubscriptions(subscriptionSelector.get(), scope, $timeout);\r\n        subscriptionSelector.on('update', function (e) {\r\n            connectSubscriptions(e.data.currentData, scope, $timeout);\r\n        });\r\n\r\n        locationSelector.on('update', (e) => {\r\n            connectLocations(e.data.currentData, scope, $timeout);\r\n        });\r\n\r\n        scope.getLocationsForModal = () => {\r\n            if(!scope.locations) return [];\r\n            const existingIds = getSubscriptionIdsFromStorage();\r\n            return scope.locations.filter((d) => existingIds.indexOf(d.id) == -1);\r\n        }\r\n\r\n        scope.modal = $ionicModal.fromTemplate(locationModalTemplate, {\r\n            scope,\r\n            animation: 'none'\r\n        });\r\n\r\n        scope.showAddLocation = function () {\r\n            scope.modal.show();\r\n        }\r\n\r\n        scope.closeModal = function () {\r\n            scope.modal.hide();\r\n        };\r\n\r\n        scope.removeLocation = (id) => {\r\n            const idsSelector = tree.select([\"subscriptions\", \"ids\"]);\r\n            const existingIDs = idsSelector.get();\r\n            idsSelector.set(existingIDs.filter((l) => l != id));\r\n            removeFromSubscriptionIdsStorage(id);\r\n        }\r\n\r\n        scope.addLocation = (location) => {\r\n            tree.push([\"subscriptions\", \"ids\"], location.id);\r\n            addToSubscriptionIdsStorage(location.id);\r\n            scope.modal.hide();\r\n        };\r\n    }]\n\n\n/** WEBPACK FOOTER **\n ** ./app/components/tabs/dashboard/dashboard.controller.js\n **/","import { default_subscriptions } from './consts';\r\nimport subscript_data_monkey from './monkeys/subscriptionData';\r\nimport { fetchLocations } from '../api/mockApi';\r\nvar Baobab = require('baobab');\r\n\r\nconst tree = new Baobab({\r\n    locations: {\r\n\r\n    },\r\n    subscriptions: {\r\n        ids: window.localStorage.getItem(\"subscriptionIds\") ?\r\n               JSON.parse(window.localStorage.getItem(\"subscriptionIds\")) : \r\n               default_subscriptions,\r\n        data: [],\r\n        subscribedLocations: subscript_data_monkey\r\n    }\r\n}, {\r\n        immutable: false\r\n    });\r\nexport default tree;\r\n\r\nfetchLocations().then((result) => {\r\n    tree.set(\"locations\", result);\r\n});\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./app/store/index.js\n **/","export const default_subscriptions = [];\n\n\n/** WEBPACK FOOTER **\n ** ./app/store/consts.js\n **/","\r\nvar Baobab = require('baobab');\r\nvar monkey = Baobab.monkey;\r\nimport loadSubscriptions from './loaders/subscriptionData';\r\nexport default monkey({\r\n    cursors: {\r\n        ids: ['subscriptions', 'ids'],\r\n        data: ['subscriptions', 'data']\r\n    },\r\n    get: function (state) {\r\n        const result = state.ids.map((id) => {\r\n            let data = state.data[id];\r\n            return data || { id, loading: true };\r\n        });     \r\n        loadSubscriptions(result.filter((r) => r.loading));   \r\n        return result;\r\n    }\r\n});\r\n\r\n\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./app/store/monkeys/subscriptionData.js\n **/","import tree from '../../index.js';\r\nimport { fetchLocationsData } from '../../../api/mockApi'\r\nexport default (ids) => {\r\n    if (ids.length == 0)\r\n        return null;\r\n    let dataSelector = tree.select('subscriptions', 'data');\r\n    fetchLocationsData(ids)\r\n    .then((data) => {\r\n            data.forEach((d) => {\r\n                dataSelector.set(d.id, d);\r\n            });\r\n        });\r\n}\n\n\n/** WEBPACK FOOTER **\n ** ./app/store/monkeys/loaders/subscriptionData.js\n **/","import config from '../config';\r\nconst locationsData = require('./mocks/locationsData.js');\r\nconst locations = require('./mocks/locations.js');\r\nexport const fetchLocationsData = (ids) => {\r\n    return new Promise((resolve) => {\r\n        resolve(locationsData);\r\n    });\r\n}\r\n\r\nexport const fetchLocations = () => {\r\n    return new Promise((resolve) => {\r\n        resolve(locations);\r\n    });\r\n}\n\n\n/** WEBPACK FOOTER **\n ** ./app/api/mockApi.js\n **/","export default {\r\n    apiUrl: 'http://some.url.to.api'\r\n}\n\n\n/** WEBPACK FOOTER **\n ** ./app/config.js\n **/","module.exports = [\r\n    {\r\n        \"id\": 1,\r\n        \"location\": \"tel-aviv\",\r\n        \"time\": \"08:00\",\r\n        \"wind\": \"8 Kts\",\r\n        \"windDirection\": \"N\",\r\n        \"temp\": \"28\",\r\n        \"wave\": \"0.5/7s\",\r\n        \"waveDirection\": \"N\"\r\n    },\r\n    {\r\n        \"id\": 2,\r\n        \"location\": \"haifa\",\r\n        \"time\": \"08:00\",\r\n        \"wind\": \"8 Kts\",\r\n        \"windDirection\": \"N\",\r\n        \"temp\": \"28\",\r\n        \"wave\": \"0.5/7s\",\r\n        \"waveDirection\": \"N\"\r\n    },\r\n    {\r\n        \"id\": 3,\r\n        \"location\": \"kineret\",\r\n        \"time\": \"08:00\",\r\n        \"wind\": \"8 Kts\",\r\n        \"windDirection\": \"N\",\r\n        \"temp\": \"28\",\r\n        \"wave\": \"0.5 / 7sec\",\r\n        \"waveDirection\": \"N\"\r\n    },\r\n    {\r\n        \"id\": 4,\r\n        \"location\": \"bat-yam\",\r\n        \"time\": \"08:00\",\r\n        \"wind\": \"8 Kts\",\r\n        \"windDirection\": \"N\",\r\n        \"temp\": \"28\",\r\n        \"wave\": \"0.5 / 7sec\",\r\n        \"waveDirection\": \"N\"\r\n    }\r\n]\n\n\n/** WEBPACK FOOTER **\n ** ./app/api/mocks/locationsData.js\n **/","module.exports = [{\"id\":1,\"name\":\"tel-aviv\"},{\"id\": 2, \"name\":\"haifa\"},{\"id\": 3, \"name\":\"kineret\"},{\"id\": 4, \"name\": \"bat-yam\"}]\n\n\n/** WEBPACK FOOTER **\n ** ./app/api/mocks/locations.js\n **/","/**\n * Baobab Data Structure\n * ======================\n *\n * A handy data tree with cursors.\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nvar _get = function get(_x3, _x4, _x5) { var _again = true; _function: while (_again) { var object = _x3, property = _x4, receiver = _x5; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x3 = parent; _x4 = property; _x5 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _emmett = require('emmett');\n\nvar _emmett2 = _interopRequireDefault(_emmett);\n\nvar _cursor = require('./cursor');\n\nvar _cursor2 = _interopRequireDefault(_cursor);\n\nvar _monkey = require('./monkey');\n\nvar _watcher = require('./watcher');\n\nvar _watcher2 = _interopRequireDefault(_watcher);\n\nvar _type = require('./type');\n\nvar _type2 = _interopRequireDefault(_type);\n\nvar _update2 = require('./update');\n\nvar _update3 = _interopRequireDefault(_update2);\n\nvar _helpers = require('./helpers');\n\nvar helpers = _interopRequireWildcard(_helpers);\n\nvar arrayFrom = helpers.arrayFrom;\nvar coercePath = helpers.coercePath;\nvar deepFreeze = helpers.deepFreeze;\nvar getIn = helpers.getIn;\nvar makeError = helpers.makeError;\nvar deepClone = helpers.deepClone;\nvar deepMerge = helpers.deepMerge;\nvar shallowClone = helpers.shallowClone;\nvar shallowMerge = helpers.shallowMerge;\nvar uniqid = helpers.uniqid;\n\n/**\n * Baobab defaults\n */\nvar DEFAULTS = {\n\n  // Should the tree handle its transactions on its own?\n  autoCommit: true,\n\n  // Should the transactions be handled asynchronously?\n  asynchronous: true,\n\n  // Should the tree's data be immutable?\n  immutable: true,\n\n  // Should the monkeys be lazy?\n  lazyMonkeys: true,\n\n  // Should the tree be persistent?\n  persistent: true,\n\n  // Should the tree's update be pure?\n  pure: true,\n\n  // Validation specifications\n  validate: null,\n\n  // Validation behavior 'rollback' or 'notify'\n  validationBehavior: 'rollback'\n};\n\n/**\n * Function returning a string hash from a non-dynamic path expressed as an\n * array.\n *\n * @param  {array}  path - The path to hash.\n * @return {string} string - The resultant hash.\n */\nfunction hashPath(path) {\n  return '' + path.map(function (step) {\n    if (_type2['default']['function'](step) || _type2['default'].object(step)) return '#' + uniqid() + '#';\n\n    return step;\n  }).join('');\n}\n\n/**\n * Baobab class\n *\n * @constructor\n * @param {object|array} [initialData={}]    - Initial data passed to the tree.\n * @param {object}       [opts]              - Optional options.\n * @param {boolean}      [opts.autoCommit]   - Should the tree auto-commit?\n * @param {boolean}      [opts.asynchronous] - Should the tree's transactions\n *                                             handled asynchronously?\n * @param {boolean}      [opts.immutable]    - Should the tree be immutable?\n * @param {boolean}      [opts.persistent]   - Should the tree be persistent?\n * @param {boolean}      [opts.pure]         - Should the tree be pure?\n * @param {function}     [opts.validate]     - Validation function.\n * @param {string}       [opts.validationBehaviour] - \"rollback\" or \"notify\".\n */\n\nvar Baobab = (function (_Emitter) {\n  _inherits(Baobab, _Emitter);\n\n  function Baobab(initialData, opts) {\n    var _this = this;\n\n    _classCallCheck(this, Baobab);\n\n    _get(Object.getPrototypeOf(Baobab.prototype), 'constructor', this).call(this);\n\n    // Setting initialData to an empty object if no data is provided by use\n    if (arguments.length < 1) initialData = {};\n\n    // Checking whether given initial data is valid\n    if (!_type2['default'].object(initialData) && !_type2['default'].array(initialData)) throw makeError('Baobab: invalid data.', { data: initialData });\n\n    // Merging given options with defaults\n    this.options = shallowMerge({}, DEFAULTS, opts);\n\n    // Disabling immutability & persistence if persistence if disabled\n    if (!this.options.persistent) {\n      this.options.immutable = false;\n      this.options.pure = false;\n    }\n\n    // Privates\n    this._identity = '[object Baobab]';\n    this._cursors = {};\n    this._future = null;\n    this._transaction = [];\n    this._affectedPathsIndex = {};\n    this._monkeys = {};\n    this._previousData = null;\n    this._data = initialData;\n\n    // Properties\n    this.root = new _cursor2['default'](this, [], '');\n    delete this.root.release;\n\n    // Does the user want an immutable tree?\n    if (this.options.immutable) deepFreeze(this._data);\n\n    // Bootstrapping root cursor's getters and setters\n    var bootstrap = function bootstrap(name) {\n      _this[name] = function () {\n        var r = this.root[name].apply(this.root, arguments);\n        return r instanceof _cursor2['default'] ? this : r;\n      };\n    };\n\n    ['apply', 'clone', 'concat', 'deepClone', 'deepMerge', 'exists', 'get', 'push', 'merge', 'pop', 'project', 'serialize', 'set', 'shift', 'splice', 'unset', 'unshift'].forEach(bootstrap);\n\n    // Registering the initial monkeys\n    this._refreshMonkeys();\n\n    // Initial validation\n    var validationError = this.validate();\n\n    if (validationError) throw Error('Baobab: invalid data.', { error: validationError });\n  }\n\n  /**\n   * Monkey helper.\n   */\n\n  /**\n   * Internal method used to refresh the tree's monkey register on every\n   * update.\n   * Note 1) For the time being, placing monkeys beneath array nodes is not\n   * allowed for performance reasons.\n   *\n   * @param  {mixed}   node      - The starting node.\n   * @param  {array}   path      - The starting node's path.\n   * @param  {string}  operation - The operation that lead to a refreshment.\n   * @return {Baobab}            - The tree instance for chaining purposes.\n   */\n\n  _createClass(Baobab, [{\n    key: '_refreshMonkeys',\n    value: function _refreshMonkeys(node, path, operation) {\n      var _this2 = this;\n\n      var clean = function clean(data) {\n        var p = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];\n\n        if (data instanceof _monkey.Monkey) {\n          data.release();\n          (0, _update3['default'])(_this2._monkeys, p, { type: 'unset' }, {\n            immutable: false,\n            persistent: false,\n            pure: false\n          });\n\n          return;\n        }\n\n        if (_type2['default'].object(data)) {\n          for (var k in data) {\n            clean(data[k], p.concat(k));\n          }\n        }\n      };\n\n      var walk = function walk(data) {\n        var p = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];\n\n        // Should we sit a monkey in the tree?\n        if (data instanceof _monkey.MonkeyDefinition || data instanceof _monkey.Monkey) {\n          var monkeyInstance = new _monkey.Monkey(_this2, p, data instanceof _monkey.Monkey ? data.definition : data);\n\n          (0, _update3['default'])(_this2._monkeys, p, { type: 'set', value: monkeyInstance }, {\n            immutable: false,\n            persistent: false,\n            pure: false\n          });\n\n          return;\n        }\n\n        // Object iteration\n        if (_type2['default'].object(data)) {\n          for (var k in data) {\n            walk(data[k], p.concat(k));\n          }\n        }\n      };\n\n      // Walking the whole tree\n      if (!arguments.length) {\n        walk(this._data);\n      } else {\n        var monkeysNode = getIn(this._monkeys, path).data;\n\n        // Is this required that we clean some already existing monkeys?\n        if (monkeysNode) clean(monkeysNode, path);\n\n        // Let's walk the tree only from the updated point\n        if (operation !== 'unset') {\n          walk(node, path);\n        }\n      }\n\n      return this;\n    }\n\n    /**\n     * Method used to validate the tree's data.\n     *\n     * @return {boolean} - Is the tree valid?\n     */\n  }, {\n    key: 'validate',\n    value: function validate(affectedPaths) {\n      var _options = this.options;\n      var validate = _options.validate;\n      var behavior = _options.validationBehavior;\n\n      if (typeof validate !== 'function') return null;\n\n      var error = validate.call(this, this._previousData, this._data, affectedPaths || [[]]);\n\n      if (error instanceof Error) {\n\n        if (behavior === 'rollback') {\n          this._data = this._previousData;\n          this._affectedPathsIndex = {};\n          this._transaction = [];\n          this._previousData = this._data;\n        }\n\n        this.emit('invalid', { error: error });\n\n        return error;\n      }\n\n      return null;\n    }\n\n    /**\n     * Method used to select data within the tree by creating a cursor. Cursors\n     * are kept as singletons by the tree for performance and hygiene reasons.\n     *\n     * Arity (1):\n     * @param {path}    path - Path to select in the tree.\n     *\n     * Arity (*):\n     * @param {...step} path - Path to select in the tree.\n     *\n     * @return {Cursor}      - The resultant cursor.\n     */\n  }, {\n    key: 'select',\n    value: function select(path) {\n\n      // If no path is given, we simply return the root\n      path = path || [];\n\n      // Variadic\n      if (arguments.length > 1) path = arrayFrom(arguments);\n\n      // Checking that given path is valid\n      if (!_type2['default'].path(path)) throw makeError('Baobab.select: invalid path.', { path: path });\n\n      // Casting to array\n      path = [].concat(path);\n\n      // Computing hash (done here because it would be too late to do it in the\n      // cursor's constructor since we need to hit the cursors' index first).\n      var hash = hashPath(path);\n\n      // Creating a new cursor or returning the already existing one for the\n      // requested path.\n      var cursor = this._cursors[hash];\n\n      if (!cursor) {\n        cursor = new _cursor2['default'](this, path, hash);\n        this._cursors[hash] = cursor;\n      }\n\n      // Emitting an event to notify that a part of the tree was selected\n      this.emit('select', { path: path, cursor: cursor });\n      return cursor;\n    }\n\n    /**\n     * Method used to update the tree. Updates are simply expressed by a path,\n     * dynamic or not, and an operation.\n     *\n     * This is where path solving should happen and not in the cursor.\n     *\n     * @param  {path}   path      - The path where we'll apply the operation.\n     * @param  {object} operation - The operation to apply.\n     * @return {mixed} - Return the result of the update.\n     */\n  }, {\n    key: 'update',\n    value: function update(path, operation) {\n      var _this3 = this;\n\n      // Coercing path\n      path = coercePath(path);\n\n      if (!_type2['default'].operationType(operation.type)) throw makeError('Baobab.update: unknown operation type \"' + operation.type + '\".', { operation: operation });\n\n      // Solving the given path\n\n      var _getIn = getIn(this._data, path);\n\n      var solvedPath = _getIn.solvedPath;\n      var exists = _getIn.exists;\n\n      // If we couldn't solve the path, we throw\n      if (!solvedPath) throw makeError('Baobab.update: could not solve the given path.', {\n        path: solvedPath\n      });\n\n      // Read-only path?\n      var monkeyPath = _type2['default'].monkeyPath(this._monkeys, solvedPath);\n      if (monkeyPath && solvedPath.length > monkeyPath.length) throw makeError('Baobab.update: attempting to update a read-only path.', {\n        path: solvedPath\n      });\n\n      // We don't unset irrelevant paths\n      if (operation.type === 'unset' && !exists) return;\n\n      // If we merge data, we need to acknowledge monkeys\n      var realOperation = operation;\n      if (/merge/i.test(operation.type)) {\n        var monkeysNode = getIn(this._monkeys, solvedPath).data;\n\n        if (_type2['default'].object(monkeysNode)) {\n\n          // Cloning the operation not to create weird behavior for the user\n          realOperation = shallowClone(realOperation);\n\n          // Fetching the existing node in the current data\n          var currentNode = getIn(this._data, solvedPath).data;\n\n          if (/deep/i.test(realOperation.type)) realOperation.value = deepMerge({}, deepMerge({}, currentNode, deepClone(monkeysNode)), realOperation.value);else realOperation.value = shallowMerge({}, deepMerge({}, currentNode, deepClone(monkeysNode)), realOperation.value);\n        }\n      }\n\n      // Stashing previous data if this is the frame's first update\n      if (!this._transaction.length) this._previousData = this._data;\n\n      // Applying the operation\n      var result = (0, _update3['default'])(this._data, solvedPath, realOperation, this.options);\n\n      var data = result.data;\n      var node = result.node;\n\n      // If because of purity, the update was moot, we stop here\n      if (!('data' in result)) return node;\n\n      // If the operation is push, the affected path is slightly different\n      var affectedPath = solvedPath.concat(operation.type === 'push' ? node.length - 1 : []);\n\n      var hash = hashPath(affectedPath);\n\n      // Updating data and transaction\n      this._data = data;\n      this._affectedPathsIndex[hash] = true;\n      this._transaction.push(shallowMerge({}, operation, { path: affectedPath }));\n\n      // Updating the monkeys\n      this._refreshMonkeys(node, solvedPath, operation.type);\n\n      // Emitting a `write` event\n      this.emit('write', { path: affectedPath });\n\n      // Should we let the user commit?\n      if (!this.options.autoCommit) return node;\n\n      // Should we update asynchronously?\n      if (!this.options.asynchronous) {\n        this.commit();\n        return node;\n      }\n\n      // Updating asynchronously\n      if (!this._future) this._future = setTimeout(function () {\n        return _this3.commit();\n      }, 0);\n\n      // Finally returning the affected node\n      return node;\n    }\n\n    /**\n     * Method committing the updates of the tree and firing the tree's events.\n     *\n     * @return {Baobab} - The tree instance for chaining purposes.\n     */\n  }, {\n    key: 'commit',\n    value: function commit() {\n\n      // Do not fire update if the transaction is empty\n      if (!this._transaction.length) return this;\n\n      // Clearing timeout if one was defined\n      if (this._future) this._future = clearTimeout(this._future);\n\n      var affectedPaths = Object.keys(this._affectedPathsIndex).map(function (h) {\n        return h !== '' ? h.split('').slice(1) : [];\n      });\n\n      // Is the tree still valid?\n      var validationError = this.validate(affectedPaths);\n\n      if (validationError) return this;\n\n      // Caching to keep original references before we change them\n      var transaction = this._transaction,\n          previousData = this._previousData;\n\n      this._affectedPathsIndex = {};\n      this._transaction = [];\n      this._previousData = this._data;\n\n      // Emitting update event\n      this.emit('update', {\n        paths: affectedPaths,\n        currentData: this._data,\n        transaction: transaction,\n        previousData: previousData\n      });\n\n      return this;\n    }\n\n    /**\n     * Method returning a monkey at the given path or else `null`.\n     *\n     * @param  {path}        path - Path of the monkey to retrieve.\n     * @return {Monkey|null}      - The Monkey instance of `null`.\n     */\n  }, {\n    key: 'getMonkey',\n    value: function getMonkey(path) {\n      path = coercePath(path);\n\n      var monkey = getIn(this._monkeys, [].concat(path)).data;\n\n      if (monkey instanceof _monkey.Monkey) return monkey;\n\n      return null;\n    }\n\n    /**\n     * Method used to watch a collection of paths within the tree. Very useful\n     * to bind UI components and such to the tree.\n     *\n     * @param  {object} mapping - Mapping of paths to listen.\n     * @return {Cursor}         - The created watcher.\n     */\n  }, {\n    key: 'watch',\n    value: function watch(mapping) {\n      return new _watcher2['default'](this, mapping);\n    }\n\n    /**\n     * Method releasing the tree and its attached data from memory.\n     */\n  }, {\n    key: 'release',\n    value: function release() {\n      var k = undefined;\n\n      this.emit('release');\n\n      delete this.root;\n\n      delete this._data;\n      delete this._previousData;\n      delete this._transaction;\n      delete this._affectedPathsIndex;\n      delete this._monkeys;\n\n      // Releasing cursors\n      for (k in this._cursors) this._cursors[k].release();\n      delete this._cursors;\n\n      // Killing event emitter\n      this.kill();\n    }\n\n    /**\n     * Overriding the `toJSON` method for convenient use with JSON.stringify.\n     *\n     * @return {mixed} - Data at cursor.\n     */\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return this.serialize();\n    }\n\n    /**\n     * Overriding the `toString` method for debugging purposes.\n     *\n     * @return {string} - The baobab's identity.\n     */\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return this._identity;\n    }\n  }]);\n\n  return Baobab;\n})(_emmett2['default']);\n\nexports['default'] = Baobab;\nBaobab.monkey = function () {\n  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  if (!args.length) throw new Error('Baobab.monkey: missing definition.');\n\n  if (args.length === 1 && typeof args[0] !== 'function') return new _monkey.MonkeyDefinition(args[0]);\n\n  return new _monkey.MonkeyDefinition(args);\n};\nBaobab.dynamicNode = Baobab.monkey;\n\n/**\n * Exposing some internals for convenience\n */\nBaobab.Cursor = _cursor2['default'];\nBaobab.MonkeyDefinition = _monkey.MonkeyDefinition;\nBaobab.Monkey = _monkey.Monkey;\nBaobab.type = _type2['default'];\nBaobab.helpers = helpers;\n\n/**\n * Version\n */\nBaobab.VERSION = '2.3.2';\nmodule.exports = exports['default'];\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/baobab/dist/baobab.js\n ** module id = 14\n ** module chunks = 0\n **/","(function() {\n  'use strict';\n\n  /**\n   * Here is the list of every allowed parameter when using Emitter#on:\n   * @type {Object}\n   */\n  var __allowedOptions = {\n    once: 'boolean',\n    scope: 'object'\n  };\n\n  /**\n   * Incremental id used to order event handlers.\n   */\n  var __order = 0;\n\n  /**\n   * A simple helper to shallowly merge two objects. The second one will \"win\"\n   * over the first one.\n   *\n   * @param  {object}  o1 First target object.\n   * @param  {object}  o2 Second target object.\n   * @return {object}     Returns the merged object.\n   */\n  function shallowMerge(o1, o2) {\n    var o = {},\n        k;\n\n    for (k in o1) o[k] = o1[k];\n    for (k in o2) o[k] = o2[k];\n\n    return o;\n  }\n\n  /**\n   * Is the given variable a plain JavaScript object?\n   *\n   * @param  {mixed}  v   Target.\n   * @return {boolean}    The boolean result.\n   */\n  function isPlainObject(v) {\n    return v &&\n           typeof v === 'object' &&\n           !Array.isArray(v) &&\n           !(v instanceof Function) &&\n           !(v instanceof RegExp);\n  }\n\n  /**\n   * Iterate over an object that may have ES6 Symbols.\n   *\n   * @param  {object}   object  Object on which to iterate.\n   * @param  {function} fn      Iterator function.\n   * @param  {object}   [scope] Optional scope.\n   */\n  function forIn(object, fn, scope) {\n    var symbols,\n        k,\n        i,\n        l;\n\n    for (k in object)\n      fn.call(scope || null, k, object[k]);\n\n    if (Object.getOwnPropertySymbols) {\n      symbols = Object.getOwnPropertySymbols(object);\n\n      for (i = 0, l = symbols.length; i < l; i++)\n        fn.call(scope || null, symbols[i], object[symbols[i]]);\n    }\n  }\n\n  /**\n   * The emitter's constructor. It initializes the handlers-per-events store and\n   * the global handlers store.\n   *\n   * Emitters are useful for non-DOM events communication. Read its methods\n   * documentation for more information about how it works.\n   *\n   * @return {Emitter}         The fresh new instance.\n   */\n  var Emitter = function() {\n    this._enabled = true;\n\n    // Dirty trick that will set the necessary properties to the emitter\n    this.unbindAll();\n  };\n\n  /**\n   * This method unbinds every handlers attached to every or any events. So,\n   * these functions will no more be executed when the related events are\n   * emitted. If the functions were not bound to the events, nothing will\n   * happen, and no error will be thrown.\n   *\n   * Usage:\n   * ******\n   * > myEmitter.unbindAll();\n   *\n   * @return {Emitter}      Returns this.\n   */\n  Emitter.prototype.unbindAll = function() {\n\n    this._handlers = {};\n    this._handlersAll = [];\n    this._handlersComplex = [];\n\n    return this;\n  };\n\n\n  /**\n   * This method binds one or more functions to the emitter, handled to one or a\n   * suite of events. So, these functions will be executed anytime one related\n   * event is emitted.\n   *\n   * It is also possible to bind a function to any emitted event by not\n   * specifying any event to bind the function to.\n   *\n   * Recognized options:\n   * *******************\n   *  - {?boolean} once   If true, the handlers will be unbound after the first\n   *                      execution. Default value: false.\n   *  - {?object}  scope  If a scope is given, then the listeners will be called\n   *                      with this scope as \"this\".\n   *\n   * Variant 1:\n   * **********\n   * > myEmitter.on('myEvent', function(e) { console.log(e); });\n   * > // Or:\n   * > myEmitter.on('myEvent', function(e) { console.log(e); }, { once: true });\n   *\n   * @param  {string}   event   The event to listen to.\n   * @param  {function} handler The function to bind.\n   * @param  {?object}  options Eventually some options.\n   * @return {Emitter}          Returns this.\n   *\n   * Variant 2:\n   * **********\n   * > myEmitter.on(\n   * >   ['myEvent1', 'myEvent2'],\n   * >   function(e) { console.log(e); }\n   * >);\n   * > // Or:\n   * > myEmitter.on(\n   * >   ['myEvent1', 'myEvent2'],\n   * >   function(e) { console.log(e); }\n   * >   { once: true }}\n   * >);\n   *\n   * @param  {array}    events  The events to listen to.\n   * @param  {function} handler The function to bind.\n   * @param  {?object}  options Eventually some options.\n   * @return {Emitter}          Returns this.\n   *\n   * Variant 3:\n   * **********\n   * > myEmitter.on({\n   * >   myEvent1: function(e) { console.log(e); },\n   * >   myEvent2: function(e) { console.log(e); }\n   * > });\n   * > // Or:\n   * > myEmitter.on({\n   * >   myEvent1: function(e) { console.log(e); },\n   * >   myEvent2: function(e) { console.log(e); }\n   * > }, { once: true });\n   *\n   * @param  {object}  bindings An object containing pairs event / function.\n   * @param  {?object}  options Eventually some options.\n   * @return {Emitter}          Returns this.\n   *\n   * Variant 4:\n   * **********\n   * > myEmitter.on(function(e) { console.log(e); });\n   * > // Or:\n   * > myEmitter.on(function(e) { console.log(e); }, { once: true});\n   *\n   * @param  {function} handler The function to bind to every events.\n   * @param  {?object}  options Eventually some options.\n   * @return {Emitter}          Returns this.\n   */\n  Emitter.prototype.on = function(a, b, c) {\n    var i,\n        l,\n        k,\n        event,\n        eArray,\n        handlersList,\n        bindingObject;\n\n    // Variant 3\n    if (isPlainObject(a)) {\n      forIn(a, function(name, fn) {\n        this.on(name, fn, b);\n      }, this);\n\n      return this;\n    }\n\n    // Variant 1, 2 and 4\n    if (typeof a === 'function') {\n      c = b;\n      b = a;\n      a = null;\n    }\n\n    eArray = [].concat(a);\n\n    for (i = 0, l = eArray.length; i < l; i++) {\n      event = eArray[i];\n\n      bindingObject = {\n        order: __order++,\n        fn: b\n      };\n\n      // Defining the list in which the handler should be inserted\n      if (typeof event === 'string' || typeof event === 'symbol') {\n        if (!this._handlers[event])\n          this._handlers[event] = [];\n        handlersList = this._handlers[event];\n        bindingObject.type = event;\n      }\n      else if (event instanceof RegExp) {\n        handlersList = this._handlersComplex;\n        bindingObject.pattern = event;\n      }\n      else if (event === null) {\n        handlersList = this._handlersAll;\n      }\n      else {\n        throw Error('Emitter.on: invalid event.');\n      }\n\n      // Appending needed properties\n      for (k in c || {})\n        if (__allowedOptions[k])\n          bindingObject[k] = c[k];\n\n      handlersList.push(bindingObject);\n    }\n\n    return this;\n  };\n\n\n  /**\n   * This method works exactly as the previous #on, but will add an options\n   * object if none is given, and set the option \"once\" to true.\n   *\n   * The polymorphism works exactly as with the #on method.\n   */\n  Emitter.prototype.once = function() {\n    var args = Array.prototype.slice.call(arguments),\n        li = args.length - 1;\n\n    if (isPlainObject(args[li]) && args.length > 1)\n      args[li] = shallowMerge(args[li], {once: true});\n    else\n      args.push({once: true});\n\n    return this.on.apply(this, args);\n  };\n\n\n  /**\n   * This method unbinds one or more functions from events of the emitter. So,\n   * these functions will no more be executed when the related events are\n   * emitted. If the functions were not bound to the events, nothing will\n   * happen, and no error will be thrown.\n   *\n   * Variant 1:\n   * **********\n   * > myEmitter.off('myEvent', myHandler);\n   *\n   * @param  {string}   event   The event to unbind the handler from.\n   * @param  {function} handler The function to unbind.\n   * @return {Emitter}          Returns this.\n   *\n   * Variant 2:\n   * **********\n   * > myEmitter.off(['myEvent1', 'myEvent2'], myHandler);\n   *\n   * @param  {array}    events  The events to unbind the handler from.\n   * @param  {function} handler The function to unbind.\n   * @return {Emitter}          Returns this.\n   *\n   * Variant 3:\n   * **********\n   * > myEmitter.off({\n   * >   myEvent1: myHandler1,\n   * >   myEvent2: myHandler2\n   * > });\n   *\n   * @param  {object} bindings An object containing pairs event / function.\n   * @return {Emitter}         Returns this.\n   *\n   * Variant 4:\n   * **********\n   * > myEmitter.off(myHandler);\n   *\n   * @param  {function} handler The function to unbind from every events.\n   * @return {Emitter}          Returns this.\n   *\n   * Variant 5:\n   * **********\n   * > myEmitter.off(event);\n   *\n   * @param  {string} event     The event we should unbind.\n   * @return {Emitter}          Returns this.\n   */\n  function filter(target, fn) {\n    target = target || [];\n\n    var a = [],\n        l,\n        i;\n\n    for (i = 0, l = target.length; i < l; i++)\n      if (target[i].fn !== fn)\n        a.push(target[i]);\n\n    return a;\n  }\n\n  Emitter.prototype.off = function(events, fn) {\n    var i,\n        n,\n        k,\n        event;\n\n    // Variant 4:\n    if (arguments.length === 1 && typeof events === 'function') {\n      fn = arguments[0];\n\n      // Handlers bound to events:\n      for (k in this._handlers) {\n        this._handlers[k] = filter(this._handlers[k], fn);\n\n        if (this._handlers[k].length === 0)\n          delete this._handlers[k];\n      }\n\n      // Generic Handlers\n      this._handlersAll = filter(this._handlersAll, fn);\n\n      // Complex handlers\n      this._handlersComplex = filter(this._handlersComplex, fn);\n    }\n\n    // Variant 5\n    else if (arguments.length === 1 &&\n             (typeof events === 'string' || typeof events === 'symbol')) {\n      delete this._handlers[events];\n    }\n\n    // Variant 1 and 2:\n    else if (arguments.length === 2) {\n      var eArray = [].concat(events);\n\n      for (i = 0, n = eArray.length; i < n; i++) {\n        event = eArray[i];\n\n        this._handlers[event] = filter(this._handlers[event], fn);\n\n        if ((this._handlers[event] || []).length === 0)\n          delete this._handlers[event];\n      }\n    }\n\n    // Variant 3\n    else if (isPlainObject(events)) {\n      forIn(events, this.off, this);\n    }\n\n    return this;\n  };\n\n  /**\n   * This method retrieve the listeners attached to a particular event.\n   *\n   * @param  {?string}    Name of the event.\n   * @return {array}      Array of handler functions.\n   */\n  Emitter.prototype.listeners = function(event) {\n    var handlers = this._handlersAll || [],\n        complex = false,\n        h,\n        i,\n        l;\n\n    if (!event)\n      throw Error('Emitter.listeners: no event provided.');\n\n    handlers = handlers.concat(this._handlers[event] || []);\n\n    for (i = 0, l = this._handlersComplex.length; i < l; i++) {\n      h = this._handlersComplex[i];\n\n      if (~event.search(h.pattern)) {\n        complex = true;\n        handlers.push(h);\n      }\n    }\n\n    // If we have any complex handlers, we need to sort\n    if (this._handlersAll.length || complex)\n      return handlers.sort(function(a, b) {\n        return a.order - b.order;\n      });\n    else\n      return handlers.slice(0);\n  };\n\n  /**\n   * This method emits the specified event(s), and executes every handlers bound\n   * to the event(s).\n   *\n   * Use cases:\n   * **********\n   * > myEmitter.emit('myEvent');\n   * > myEmitter.emit('myEvent', myData);\n   * > myEmitter.emit(['myEvent1', 'myEvent2']);\n   * > myEmitter.emit(['myEvent1', 'myEvent2'], myData);\n   * > myEmitter.emit({myEvent1: myData1, myEvent2: myData2});\n   *\n   * @param  {string|array} events The event(s) to emit.\n   * @param  {object?}      data   The data.\n   * @return {Emitter}             Returns this.\n   */\n  Emitter.prototype.emit = function(events, data) {\n\n    // Short exit if the emitter is disabled\n    if (!this._enabled)\n      return this;\n\n    // Object variant\n    if (isPlainObject(events)) {\n      forIn(events, this.emit, this);\n      return this;\n    }\n\n    var eArray = [].concat(events),\n        onces = [],\n        event,\n        parent,\n        handlers,\n        handler,\n        i,\n        j,\n        l,\n        m;\n\n    for (i = 0, l = eArray.length; i < l; i++) {\n      handlers = this.listeners(eArray[i]);\n\n      for (j = 0, m = handlers.length; j < m; j++) {\n        handler = handlers[j];\n        event = {\n          type: eArray[i],\n          target: this\n        };\n\n        if (arguments.length > 1)\n          event.data = data;\n\n        handler.fn.call('scope' in handler ? handler.scope : this, event);\n\n        if (handler.once)\n          onces.push(handler);\n      }\n\n      // Cleaning onces\n      for (j = onces.length - 1; j >= 0; j--) {\n        parent = onces[j].type ?\n          this._handlers[onces[j].type] :\n          onces[j].pattern ?\n            this._handlersComplex :\n            this._handlersAll;\n\n        parent.splice(parent.indexOf(onces[j]), 1);\n      }\n    }\n\n    return this;\n  };\n\n\n  /**\n   * This method will unbind all listeners and make it impossible to ever\n   * rebind any listener to any event.\n   */\n  Emitter.prototype.kill = function() {\n\n    this.unbindAll();\n    this._handlers = null;\n    this._handlersAll = null;\n    this._handlersComplex = null;\n    this._enabled = false;\n\n    // Nooping methods\n    this.unbindAll =\n    this.on =\n    this.once =\n    this.off =\n    this.emit =\n    this.listeners = Function.prototype;\n  };\n\n\n  /**\n   * This method disabled the emitter, which means its emit method will do\n   * nothing.\n   *\n   * @return {Emitter} Returns this.\n   */\n  Emitter.prototype.disable = function() {\n    this._enabled = false;\n\n    return this;\n  };\n\n\n  /**\n   * This method enables the emitter.\n   *\n   * @return {Emitter} Returns this.\n   */\n  Emitter.prototype.enable = function() {\n    this._enabled = true;\n\n    return this;\n  };\n\n\n  /**\n   * Version:\n   */\n  Emitter.version = '3.1.1';\n\n\n  // Export:\n  if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports)\n      exports = module.exports = Emitter;\n    exports.Emitter = Emitter;\n  } else if (typeof define === 'function' && define.amd)\n    define('emmett', [], function() {\n      return Emitter;\n    });\n  else\n    this.Emitter = Emitter;\n}).call(this);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/emmett/emmett.js\n ** module id = 15\n ** module chunks = 0\n **/","/**\n * Baobab Cursors\n * ===============\n *\n * Cursors created by selecting some data within a Baobab tree.\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nvar _get = function get(_x3, _x4, _x5) { var _again = true; _function: while (_again) { var object = _x3, property = _x4, receiver = _x5; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x3 = parent; _x4 = property; _x5 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _emmett = require('emmett');\n\nvar _emmett2 = _interopRequireDefault(_emmett);\n\nvar _monkey = require('./monkey');\n\nvar _type = require('./type');\n\nvar _type2 = _interopRequireDefault(_type);\n\nvar _helpers = require('./helpers');\n\n/**\n * Traversal helper function for dynamic cursors. Will throw a legible error\n * if traversal is not possible.\n *\n * @param {string} method     - The method name, to create a correct error msg.\n * @param {array}  solvedPath - The cursor's solved path.\n */\nfunction checkPossibilityOfDynamicTraversal(method, solvedPath) {\n  if (!solvedPath) throw (0, _helpers.makeError)('Baobab.Cursor.' + method + ': ' + ('cannot use ' + method + ' on an unresolved dynamic path.'), { path: solvedPath });\n}\n\n/**\n * Cursor class\n *\n * @constructor\n * @param {Baobab} tree   - The cursor's root.\n * @param {array}  path   - The cursor's path in the tree.\n * @param {string} hash   - The path's hash computed ahead by the tree.\n */\n\nvar Cursor = (function (_Emitter) {\n  _inherits(Cursor, _Emitter);\n\n  function Cursor(tree, path, hash) {\n    var _this = this;\n\n    _classCallCheck(this, Cursor);\n\n    _get(Object.getPrototypeOf(Cursor.prototype), 'constructor', this).call(this);\n\n    // If no path were to be provided, we fallback to an empty path (root)\n    path = path || [];\n\n    // Privates\n    this._identity = '[object Cursor]';\n    this._archive = null;\n\n    // Properties\n    this.tree = tree;\n    this.path = path;\n    this.hash = hash;\n\n    // State\n    this.state = {\n      killed: false,\n      recording: false,\n      undoing: false\n    };\n\n    // Checking whether the given path is dynamic or not\n    this._dynamicPath = _type2['default'].dynamicPath(this.path);\n\n    // Checking whether the given path will meet a monkey\n    this._monkeyPath = _type2['default'].monkeyPath(this.tree._monkeys, this.path);\n\n    if (!this._dynamicPath) this.solvedPath = this.path;else this.solvedPath = (0, _helpers.getIn)(this.tree._data, this.path).solvedPath;\n\n    /**\n     * Listener bound to the tree's writes so that cursors with dynamic paths\n     * may update their solved path correctly.\n     *\n     * @param {object} event - The event fired by the tree.\n     */\n    this._writeHandler = function (_ref) {\n      var data = _ref.data;\n\n      if (_this.state.killed || !(0, _helpers.solveUpdate)([data.path], _this._getComparedPaths())) return;\n\n      _this.solvedPath = (0, _helpers.getIn)(_this.tree._data, _this.path).solvedPath;\n    };\n\n    /**\n     * Function in charge of actually trigger the cursor's updates and\n     * deal with the archived records.\n     *\n     * @note: probably should wrap the current solvedPath in closure to avoid\n     * for tricky cases where it would fail.\n     *\n     * @param {mixed} previousData - the tree's previous data.\n     */\n    var fireUpdate = function fireUpdate(previousData) {\n      var self = _this;\n\n      var eventData = Object.defineProperties({}, {\n        previousData: {\n          get: function get() {\n            return (0, _helpers.getIn)(previousData, self.solvedPath).data;\n          },\n          configurable: true,\n          enumerable: true\n        },\n        currentData: {\n          get: function get() {\n            return self.get();\n          },\n          configurable: true,\n          enumerable: true\n        }\n      });\n\n      if (_this.state.recording && !_this.state.undoing) _this.archive.add(eventData.previousData);\n\n      _this.state.undoing = false;\n\n      return _this.emit('update', eventData);\n    };\n\n    /**\n     * Listener bound to the tree's updates and determining whether the\n     * cursor is affected and should react accordingly.\n     *\n     * Note that this listener is lazily bound to the tree to be sure\n     * one wouldn't leak listeners when only creating cursors for convenience\n     * and not to listen to updates specifically.\n     *\n     * @param {object} event - The event fired by the tree.\n     */\n    this._updateHandler = function (event) {\n      if (_this.state.killed) return;\n\n      var _event$data = event.data;\n      var paths = _event$data.paths;\n      var previousData = _event$data.previousData;\n      var update = fireUpdate.bind(_this, previousData);\n      var comparedPaths = _this._getComparedPaths();\n\n      if ((0, _helpers.solveUpdate)(paths, comparedPaths)) return update();\n    };\n\n    // Lazy binding\n    var bound = false;\n    this._lazyBind = function () {\n      if (bound) return;\n\n      bound = true;\n\n      if (_this._dynamicPath) _this.tree.on('write', _this._writeHandler);\n\n      return _this.tree.on('update', _this._updateHandler);\n    };\n\n    // If the path is dynamic, we actually need to listen to the tree\n    if (this._dynamicPath) {\n      this._lazyBind();\n    } else {\n\n      // Overriding the emitter `on` and `once` methods\n      this.on = (0, _helpers.before)(this._lazyBind, this.on.bind(this));\n      this.once = (0, _helpers.before)(this._lazyBind, this.once.bind(this));\n    }\n  }\n\n  /**\n   * Method used to allow iterating over cursors containing list-type data.\n   *\n   * e.g. for(let i of cursor) { ... }\n   *\n   * @returns {object} -  Each item sequentially.\n   */\n\n  /**\n   * Internal helpers\n   * -----------------\n   */\n\n  /**\n   * Method returning the paths of the tree watched over by the cursor and that\n   * should be taken into account when solving a potential update.\n   *\n   * @return {array} - Array of paths to compare with a given update.\n   */\n\n  _createClass(Cursor, [{\n    key: '_getComparedPaths',\n    value: function _getComparedPaths() {\n\n      // Checking whether we should keep track of some dependencies\n      var additionalPaths = this._monkeyPath ? (0, _helpers.getIn)(this.tree._monkeys, this._monkeyPath).data.relatedPaths() : [];\n\n      return [this.solvedPath].concat(additionalPaths);\n    }\n\n    /**\n     * Predicates\n     * -----------\n     */\n\n    /**\n     * Method returning whether the cursor is at root level.\n     *\n     * @return {boolean} - Is the cursor the root?\n     */\n  }, {\n    key: 'isRoot',\n    value: function isRoot() {\n      return !this.path.length;\n    }\n\n    /**\n     * Method returning whether the cursor is at leaf level.\n     *\n     * @return {boolean} - Is the cursor a leaf?\n     */\n  }, {\n    key: 'isLeaf',\n    value: function isLeaf() {\n      return _type2['default'].primitive(this._get().data);\n    }\n\n    /**\n     * Method returning whether the cursor is at branch level.\n     *\n     * @return {boolean} - Is the cursor a branch?\n     */\n  }, {\n    key: 'isBranch',\n    value: function isBranch() {\n      return !this.isRoot() && !this.isLeaf();\n    }\n\n    /**\n     * Traversal Methods\n     * ------------------\n     */\n\n    /**\n     * Method returning the root cursor.\n     *\n     * @return {Baobab} - The root cursor.\n     */\n  }, {\n    key: 'root',\n    value: function root() {\n      return this.tree.select();\n    }\n\n    /**\n     * Method selecting a subpath as a new cursor.\n     *\n     * Arity (1):\n     * @param  {path} path    - The path to select.\n     *\n     * Arity (*):\n     * @param  {...step} path - The path to select.\n     *\n     * @return {Cursor}       - The created cursor.\n     */\n  }, {\n    key: 'select',\n    value: function select(path) {\n      if (arguments.length > 1) path = (0, _helpers.arrayFrom)(arguments);\n\n      return this.tree.select(this.path.concat(path));\n    }\n\n    /**\n     * Method returning the parent node of the cursor or else `null` if the\n     * cursor is already at root level.\n     *\n     * @return {Baobab} - The parent cursor.\n     */\n  }, {\n    key: 'up',\n    value: function up() {\n      if (!this.isRoot()) return this.tree.select(this.path.slice(0, -1));\n\n      return null;\n    }\n\n    /**\n     * Method returning the child node of the cursor.\n     *\n     * @return {Baobab} - The child cursor.\n     */\n  }, {\n    key: 'down',\n    value: function down() {\n      checkPossibilityOfDynamicTraversal('down', this.solvedPath);\n\n      if (!(this._get().data instanceof Array)) throw Error('Baobab.Cursor.down: cannot go down on a non-list type.');\n\n      return this.tree.select(this.solvedPath.concat(0));\n    }\n\n    /**\n     * Method returning the left sibling node of the cursor if this one is\n     * pointing at a list. Returns `null` if this cursor is already leftmost.\n     *\n     * @return {Baobab} - The left sibling cursor.\n     */\n  }, {\n    key: 'left',\n    value: function left() {\n      checkPossibilityOfDynamicTraversal('left', this.solvedPath);\n\n      var last = +this.solvedPath[this.solvedPath.length - 1];\n\n      if (isNaN(last)) throw Error('Baobab.Cursor.left: cannot go left on a non-list type.');\n\n      return last ? this.tree.select(this.solvedPath.slice(0, -1).concat(last - 1)) : null;\n    }\n\n    /**\n     * Method returning the right sibling node of the cursor if this one is\n     * pointing at a list. Returns `null` if this cursor is already rightmost.\n     *\n     * @return {Baobab} - The right sibling cursor.\n     */\n  }, {\n    key: 'right',\n    value: function right() {\n      checkPossibilityOfDynamicTraversal('right', this.solvedPath);\n\n      var last = +this.solvedPath[this.solvedPath.length - 1];\n\n      if (isNaN(last)) throw Error('Baobab.Cursor.right: cannot go right on a non-list type.');\n\n      if (last + 1 === this.up()._get().data.length) return null;\n\n      return this.tree.select(this.solvedPath.slice(0, -1).concat(last + 1));\n    }\n\n    /**\n     * Method returning the leftmost sibling node of the cursor if this one is\n     * pointing at a list.\n     *\n     * @return {Baobab} - The leftmost sibling cursor.\n     */\n  }, {\n    key: 'leftmost',\n    value: function leftmost() {\n      checkPossibilityOfDynamicTraversal('leftmost', this.solvedPath);\n\n      var last = +this.solvedPath[this.solvedPath.length - 1];\n\n      if (isNaN(last)) throw Error('Baobab.Cursor.leftmost: cannot go left on a non-list type.');\n\n      return this.tree.select(this.solvedPath.slice(0, -1).concat(0));\n    }\n\n    /**\n     * Method returning the rightmost sibling node of the cursor if this one is\n     * pointing at a list.\n     *\n     * @return {Baobab} - The rightmost sibling cursor.\n     */\n  }, {\n    key: 'rightmost',\n    value: function rightmost() {\n      checkPossibilityOfDynamicTraversal('rightmost', this.solvedPath);\n\n      var last = +this.solvedPath[this.solvedPath.length - 1];\n\n      if (isNaN(last)) throw Error('Baobab.Cursor.rightmost: cannot go right on a non-list type.');\n\n      var list = this.up()._get().data;\n\n      return this.tree.select(this.solvedPath.slice(0, -1).concat(list.length - 1));\n    }\n\n    /**\n     * Method mapping the children nodes of the cursor.\n     *\n     * @param  {function} fn      - The function to map.\n     * @param  {object}   [scope] - An optional scope.\n     * @return {array}            - The resultant array.\n     */\n  }, {\n    key: 'map',\n    value: function map(fn, scope) {\n      checkPossibilityOfDynamicTraversal('map', this.solvedPath);\n\n      var array = this._get().data,\n          l = arguments.length;\n\n      if (!_type2['default'].array(array)) throw Error('baobab.Cursor.map: cannot map a non-list type.');\n\n      return array.map(function (item, i) {\n        return fn.call(l > 1 ? scope : this, this.select(i), i, array);\n      }, this);\n    }\n\n    /**\n     * Getter Methods\n     * ---------------\n     */\n\n    /**\n     * Internal get method. Basically contains the main body of the `get` method\n     * without the event emitting. This is sometimes needed not to fire useless\n     * events.\n     *\n     * @param  {path}   [path=[]]       - Path to get in the tree.\n     * @return {object} info            - The resultant information.\n     * @return {mixed}  info.data       - Data at path.\n     * @return {array}  info.solvedPath - The path solved when getting.\n     */\n  }, {\n    key: '_get',\n    value: function _get() {\n      var path = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];\n\n      if (!_type2['default'].path(path)) throw (0, _helpers.makeError)('Baobab.Cursor.getters: invalid path.', { path: path });\n\n      if (!this.solvedPath) return { data: undefined, solvedPath: null, exists: false };\n\n      return (0, _helpers.getIn)(this.tree._data, this.solvedPath.concat(path));\n    }\n\n    /**\n     * Method used to check whether a certain path exists in the tree starting\n     * from the current cursor.\n     *\n     * Arity (1):\n     * @param  {path}   path           - Path to check in the tree.\n     *\n     * Arity (2):\n     * @param {..step}  path           - Path to check in the tree.\n     *\n     * @return {boolean}               - Does the given path exists?\n     */\n  }, {\n    key: 'exists',\n    value: function exists(path) {\n      path = (0, _helpers.coercePath)(path);\n\n      if (arguments.length > 1) path = (0, _helpers.arrayFrom)(arguments);\n\n      return this._get(path).exists;\n    }\n\n    /**\n     * Method used to get data from the tree. Will fire a `get` event from the\n     * tree so that the user may sometimes react upon it to fetch data, for\n     * instance.\n     *\n     * Arity (1):\n     * @param  {path}   path           - Path to get in the tree.\n     *\n     * Arity (2):\n     * @param  {..step} path           - Path to get in the tree.\n     *\n     * @return {mixed}                 - Data at path.\n     */\n  }, {\n    key: 'get',\n    value: function get(path) {\n      path = (0, _helpers.coercePath)(path);\n\n      if (arguments.length > 1) path = (0, _helpers.arrayFrom)(arguments);\n\n      var _get2 = this._get(path);\n\n      var data = _get2.data;\n      var solvedPath = _get2.solvedPath;\n\n      // Emitting the event\n      this.tree.emit('get', { data: data, solvedPath: solvedPath, path: this.path.concat(path) });\n\n      return data;\n    }\n\n    /**\n     * Method used to shallow clone data from the tree.\n     *\n     * Arity (1):\n     * @param  {path}   path           - Path to get in the tree.\n     *\n     * Arity (2):\n     * @param  {..step} path           - Path to get in the tree.\n     *\n     * @return {mixed}                 - Cloned data at path.\n     */\n  }, {\n    key: 'clone',\n    value: function clone() {\n      var data = this.get.apply(this, arguments);\n\n      return (0, _helpers.shallowClone)(data);\n    }\n\n    /**\n     * Method used to deep clone data from the tree.\n     *\n     * Arity (1):\n     * @param  {path}   path           - Path to get in the tree.\n     *\n     * Arity (2):\n     * @param  {..step} path           - Path to get in the tree.\n     *\n     * @return {mixed}                 - Cloned data at path.\n     */\n  }, {\n    key: 'deepClone',\n    value: function deepClone() {\n      var data = this.get.apply(this, arguments);\n\n      return (0, _helpers.deepClone)(data);\n    }\n\n    /**\n     * Method used to return raw data from the tree, by carefully avoiding\n     * computed one.\n     *\n     * @todo: should be more performant as the cloning should happen as well as\n     * when dropping computed data.\n     *\n     * Arity (1):\n     * @param  {path}   path           - Path to serialize in the tree.\n     *\n     * Arity (2):\n     * @param  {..step} path           - Path to serialize in the tree.\n     *\n     * @return {mixed}                 - The retrieved raw data.\n     */\n  }, {\n    key: 'serialize',\n    value: function serialize(path) {\n      path = (0, _helpers.coercePath)(path);\n\n      if (arguments.length > 1) path = (0, _helpers.arrayFrom)(arguments);\n\n      if (!_type2['default'].path(path)) throw (0, _helpers.makeError)('Baobab.Cursor.getters: invalid path.', { path: path });\n\n      if (!this.solvedPath) return undefined;\n\n      var fullPath = this.solvedPath.concat(path);\n\n      var data = (0, _helpers.deepClone)((0, _helpers.getIn)(this.tree._data, fullPath).data),\n          monkeys = (0, _helpers.getIn)(this.tree._monkeys, fullPath).data;\n\n      var dropComputedData = function dropComputedData(d, m) {\n        if (!_type2['default'].object(m) || !_type2['default'].object(d)) return;\n\n        for (var k in m) {\n          if (m[k] instanceof _monkey.Monkey) delete d[k];else dropComputedData(d[k], m[k]);\n        }\n      };\n\n      dropComputedData(data, monkeys);\n      return data;\n    }\n\n    /**\n     * Method used to project some of the data at cursor onto a map or a list.\n     *\n     * @param  {object|array} projection - The projection's formal definition.\n     * @return {object|array}            - The resultant map/list.\n     */\n  }, {\n    key: 'project',\n    value: function project(projection) {\n      if (_type2['default'].object(projection)) {\n        var data = {};\n\n        for (var k in projection) {\n          data[k] = this.get(projection[k]);\n        }return data;\n      } else if (_type2['default'].array(projection)) {\n        var data = [];\n\n        for (var i = 0, l = projection.length; i < l; i++) {\n          data.push(this.get(projection[i]));\n        }return data;\n      }\n\n      throw (0, _helpers.makeError)('Baobab.Cursor.project: wrong projection.', { projection: projection });\n    }\n\n    /**\n     * History Methods\n     * ----------------\n     */\n\n    /**\n     * Methods starting to record the cursor's successive states.\n     *\n     * @param  {integer} [maxRecords] - Maximum records to keep in memory. Note\n     *                                  that if no number is provided, the cursor\n     *                                  will keep everything.\n     * @return {Cursor}               - The cursor instance for chaining purposes.\n     */\n  }, {\n    key: 'startRecording',\n    value: function startRecording(maxRecords) {\n      maxRecords = maxRecords || Infinity;\n\n      if (maxRecords < 1) throw (0, _helpers.makeError)('Baobab.Cursor.startRecording: invalid max records.', {\n        value: maxRecords\n      });\n\n      this.state.recording = true;\n\n      if (this.archive) return this;\n\n      // Lazy binding\n      this._lazyBind();\n\n      this.archive = new _helpers.Archive(maxRecords);\n      return this;\n    }\n\n    /**\n     * Methods stopping to record the cursor's successive states.\n     *\n     * @return {Cursor} - The cursor instance for chaining purposes.\n     */\n  }, {\n    key: 'stopRecording',\n    value: function stopRecording() {\n      this.state.recording = false;\n      return this;\n    }\n\n    /**\n     * Methods undoing n steps of the cursor's recorded states.\n     *\n     * @param  {integer} [steps=1] - The number of steps to rollback.\n     * @return {Cursor}            - The cursor instance for chaining purposes.\n     */\n  }, {\n    key: 'undo',\n    value: function undo() {\n      var steps = arguments.length <= 0 || arguments[0] === undefined ? 1 : arguments[0];\n\n      if (!this.state.recording) throw new Error('Baobab.Cursor.undo: cursor is not recording.');\n\n      var record = this.archive.back(steps);\n\n      if (!record) throw Error('Baobab.Cursor.undo: cannot find a relevant record.');\n\n      this.state.undoing = true;\n      this.set(record);\n\n      return this;\n    }\n\n    /**\n     * Methods returning whether the cursor has a recorded history.\n     *\n     * @return {boolean} - `true` if the cursor has a recorded history?\n     */\n  }, {\n    key: 'hasHistory',\n    value: function hasHistory() {\n      return !!(this.archive && this.archive.get().length);\n    }\n\n    /**\n     * Methods returning the cursor's history.\n     *\n     * @return {array} - The cursor's history.\n     */\n  }, {\n    key: 'getHistory',\n    value: function getHistory() {\n      return this.archive ? this.archive.get() : [];\n    }\n\n    /**\n     * Methods clearing the cursor's history.\n     *\n     * @return {Cursor} - The cursor instance for chaining purposes.\n     */\n  }, {\n    key: 'clearHistory',\n    value: function clearHistory() {\n      if (this.archive) this.archive.clear();\n      return this;\n    }\n\n    /**\n     * Releasing\n     * ----------\n     */\n\n    /**\n     * Methods releasing the cursor from memory.\n     */\n  }, {\n    key: 'release',\n    value: function release() {\n\n      // Removing listeners on parent\n      if (this._dynamicPath) this.tree.off('write', this._writeHandler);\n\n      this.tree.off('update', this._updateHandler);\n\n      // Unsubscribe from the parent\n      if (this.hash) delete this.tree._cursors[this.hash];\n\n      // Dereferencing\n      delete this.tree;\n      delete this.path;\n      delete this.solvedPath;\n      delete this.archive;\n\n      // Killing emitter\n      this.kill();\n      this.state.killed = true;\n    }\n\n    /**\n     * Output\n     * -------\n     */\n\n    /**\n     * Overriding the `toJSON` method for convenient use with JSON.stringify.\n     *\n     * @return {mixed} - Data at cursor.\n     */\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return this.serialize();\n    }\n\n    /**\n     * Overriding the `toString` method for debugging purposes.\n     *\n     * @return {string} - The cursor's identity.\n     */\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return this._identity;\n    }\n  }]);\n\n  return Cursor;\n})(_emmett2['default']);\n\nexports['default'] = Cursor;\nif (typeof Symbol === 'function' && typeof Symbol.iterator !== 'undefined') {\n  Cursor.prototype[Symbol.iterator] = function () {\n    var array = this._get().data;\n\n    if (!_type2['default'].array(array)) throw Error('baobab.Cursor.@@iterate: cannot iterate a non-list type.');\n\n    var i = 0;\n\n    var cursor = this,\n        length = array.length;\n\n    return {\n      next: function next() {\n        if (i < length) {\n          return {\n            value: cursor.select(i++)\n          };\n        }\n\n        return {\n          done: true\n        };\n      }\n    };\n  };\n}\n\n/**\n * Setter Methods\n * ---------------\n *\n * Those methods are dynamically assigned to the class for DRY reasons.\n */\n\n// Not using a Set so that ES5 consumers don't pay a bundle size price\nvar INTRANSITIVE_SETTERS = {\n  unset: true,\n  pop: true,\n  shift: true\n};\n\n/**\n * Function creating a setter method for the Cursor class.\n *\n * @param {string}   name          - the method's name.\n * @param {function} [typeChecker] - a function checking that the given value is\n *                                   valid for the given operation.\n */\nfunction makeSetter(name, typeChecker) {\n\n  /**\n   * Binding a setter method to the Cursor class and having the following\n   * definition.\n   *\n   * Note: this is not really possible to make those setters variadic because\n   * it would create an impossible polymorphism with path.\n   *\n   * @todo: perform value validation elsewhere so that tree.update can\n   * beneficiate from it.\n   *\n   * Arity (1):\n   * @param  {mixed} value - New value to set at cursor's path.\n   *\n   * Arity (2):\n   * @param  {path}  path  - Subpath to update starting from cursor's.\n   * @param  {mixed} value - New value to set.\n   *\n   * @return {mixed}       - Data at path.\n   */\n  Cursor.prototype[name] = function (path, value) {\n\n    // We should warn the user if he applies to many arguments to the function\n    if (arguments.length > 2) throw (0, _helpers.makeError)('Baobab.Cursor.' + name + ': too many arguments.');\n\n    // Handling arities\n    if (arguments.length === 1 && !INTRANSITIVE_SETTERS[name]) {\n      value = path;\n      path = [];\n    }\n\n    // Coerce path\n    path = (0, _helpers.coercePath)(path);\n\n    // Checking the path's validity\n    if (!_type2['default'].path(path)) throw (0, _helpers.makeError)('Baobab.Cursor.' + name + ': invalid path.', { path: path });\n\n    // Checking the value's validity\n    if (typeChecker && !typeChecker(value)) throw (0, _helpers.makeError)('Baobab.Cursor.' + name + ': invalid value.', { path: path, value: value });\n\n    // Checking the solvability of the cursor's dynamic path\n    if (!this.solvedPath) throw (0, _helpers.makeError)('Baobab.Cursor.' + name + ': the dynamic path of the cursor cannot be solved.', { path: this.path });\n\n    var fullPath = this.solvedPath.concat(path);\n\n    // Filing the update to the tree\n    return this.tree.update(fullPath, {\n      type: name,\n      value: value\n    });\n  };\n}\n\n/**\n * Making the necessary setters.\n */\nmakeSetter('set');\nmakeSetter('unset');\nmakeSetter('apply', _type2['default']['function']);\nmakeSetter('push');\nmakeSetter('concat', _type2['default'].array);\nmakeSetter('unshift');\nmakeSetter('pop');\nmakeSetter('shift');\nmakeSetter('splice', _type2['default'].splicer);\nmakeSetter('merge', _type2['default'].object);\nmakeSetter('deepMerge', _type2['default'].object);\nmodule.exports = exports['default'];\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/baobab/dist/cursor.js\n ** module id = 16\n ** module chunks = 0\n **/","/**\n * Baobab Monkeys\n * ===============\n *\n * Exposing both handy monkey definitions and the underlying working class.\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nvar _type = require('./type');\n\nvar _type2 = _interopRequireDefault(_type);\n\nvar _update2 = require('./update');\n\nvar _update3 = _interopRequireDefault(_update2);\n\nvar _helpers = require('./helpers');\n\n/**\n * Monkey Definition class\n * Note: The only reason why this is a class is to be able to spot it within\n * otherwise ordinary data.\n *\n * @constructor\n * @param {array|object} definition - The formal definition of the monkey.\n */\n\nvar MonkeyDefinition = function MonkeyDefinition(definition) {\n  var _this = this;\n\n  _classCallCheck(this, MonkeyDefinition);\n\n  var monkeyType = _type2['default'].monkeyDefinition(definition);\n\n  if (!monkeyType) throw (0, _helpers.makeError)('Baobab.monkey: invalid definition.', { definition: definition });\n\n  this.type = monkeyType;\n\n  if (this.type === 'object') {\n    this.getter = definition.get;\n    this.projection = definition.cursors || {};\n    this.paths = Object.keys(this.projection).map(function (k) {\n      return _this.projection[k];\n    });\n    this.options = definition.options || {};\n  } else {\n    var offset = 1,\n        options = {};\n\n    if (_type2['default'].object(definition[definition.length - 1])) {\n      offset++;\n      options = definition[definition.length - 1];\n    }\n\n    this.getter = definition[definition.length - offset];\n    this.projection = definition.slice(0, -offset);\n    this.paths = this.projection;\n    this.options = options;\n  }\n\n  // Coercing paths for convenience\n  this.paths = this.paths.map(function (p) {\n    return [].concat(p);\n  });\n\n  // Does the definition contain dynamic paths\n  this.hasDynamicPaths = this.paths.some(_type2['default'].dynamicPath);\n}\n\n/**\n * Monkey core class\n *\n * @constructor\n * @param {Baobab}           tree       - The bound tree.\n * @param {MonkeyDefinition} definition - A definition instance.\n */\n;\n\nexports.MonkeyDefinition = MonkeyDefinition;\n\nvar Monkey = (function () {\n  function Monkey(tree, pathInTree, definition) {\n    var _this2 = this;\n\n    _classCallCheck(this, Monkey);\n\n    // Properties\n    this.tree = tree;\n    this.path = pathInTree;\n    this.definition = definition;\n\n    // Adapting the definition's paths & projection to this monkey's case\n    var projection = definition.projection,\n        relative = _helpers.solveRelativePath.bind(null, pathInTree.slice(0, -1));\n\n    if (definition.type === 'object') {\n      this.projection = Object.keys(projection).reduce(function (acc, k) {\n        acc[k] = relative(projection[k]);\n        return acc;\n      }, {});\n      this.depPaths = Object.keys(this.projection).map(function (k) {\n        return _this2.projection[k];\n      });\n    } else {\n      this.projection = projection.map(relative);\n      this.depPaths = this.projection;\n    }\n\n    // Internal state\n    this.state = {\n      killed: false\n    };\n\n    /**\n     * Listener on the tree's `write` event.\n     *\n     * When the tree writes, this listener will check whether the updated paths\n     * are of any use to the monkey and, if so, will update the tree's node\n     * where the monkey sits.\n     */\n    this.writeListener = function (_ref) {\n      var path = _ref.data.path;\n\n      if (_this2.state.killed) return;\n\n      // Is the monkey affected by the current write event?\n      var concerned = (0, _helpers.solveUpdate)([path], _this2.relatedPaths());\n\n      if (concerned) _this2.update();\n    };\n\n    /**\n     * Listener on the tree's `monkey` event.\n     *\n     * When another monkey updates, this listener will check whether the\n     * updated paths are of any use to the monkey and, if so, will update the\n     * tree's node where the monkey sits.\n     */\n    this.recursiveListener = function (_ref2) {\n      var _ref2$data = _ref2.data;\n      var monkey = _ref2$data.monkey;\n      var path = _ref2$data.path;\n\n      if (_this2.state.killed) return;\n\n      // Breaking if this is the same monkey\n      if (_this2 === monkey) return;\n\n      // Is the monkey affected by the current monkey event?\n      var concerned = (0, _helpers.solveUpdate)([path], _this2.relatedPaths(false));\n\n      if (concerned) _this2.update();\n    };\n\n    // Binding listeners\n    this.tree.on('write', this.writeListener);\n    this.tree.on('_monkey', this.recursiveListener);\n\n    // Updating relevant node\n    this.update();\n  }\n\n  /**\n   * Method returning solved paths related to the monkey.\n   *\n   * @param  {boolean} recursive - Should we compute recursive paths?\n   * @return {array}             - An array of related paths.\n   */\n\n  _createClass(Monkey, [{\n    key: 'relatedPaths',\n    value: function relatedPaths() {\n      var _this3 = this;\n\n      var recursive = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];\n\n      var paths = undefined;\n\n      if (this.definition.hasDynamicPaths) paths = this.depPaths.map(function (p) {\n        return (0, _helpers.getIn)(_this3.tree._data, p).solvedPath;\n      });else paths = this.depPaths;\n\n      var isRecursive = recursive && this.depPaths.some(function (p) {\n        return !!_type2['default'].monkeyPath(_this3.tree._monkeys, p);\n      });\n\n      if (!isRecursive) return paths;\n\n      return paths.reduce(function (accumulatedPaths, path) {\n        var monkeyPath = _type2['default'].monkeyPath(_this3.tree._monkeys, path);\n\n        if (!monkeyPath) return accumulatedPaths.concat([path]);\n\n        // Solving recursive path\n        var relatedMonkey = (0, _helpers.getIn)(_this3.tree._monkeys, monkeyPath).data;\n\n        return accumulatedPaths.concat(relatedMonkey.relatedPaths());\n      }, []);\n    }\n\n    /**\n     * Method used to update the tree's internal data with a lazy getter holding\n     * the computed data.\n     *\n     * @return {Monkey} - Returns itself for chaining purposes.\n     */\n  }, {\n    key: 'update',\n    value: function update() {\n      var deps = this.tree.project(this.projection);\n\n      var lazyGetter = (function (tree, def, data) {\n        var cache = null,\n            alreadyComputed = false;\n\n        return function () {\n\n          if (!alreadyComputed) {\n            cache = def.getter.apply(tree, def.type === 'object' ? [data] : data);\n\n            if (tree.options.immutable && def.options.immutable !== false) (0, _helpers.deepFreeze)(cache);\n\n            alreadyComputed = true;\n          }\n\n          return cache;\n        };\n      })(this.tree, this.definition, deps);\n\n      lazyGetter.isLazyGetter = true;\n\n      // Should we write the lazy getter in the tree or solve it right now?\n      if (this.tree.options.lazyMonkeys) {\n        this.tree._data = (0, _update3['default'])(this.tree._data, this.path, {\n          type: 'monkey',\n          value: lazyGetter\n        }, this.tree.options).data;\n      } else {\n        var result = (0, _update3['default'])(this.tree._data, this.path, {\n          type: 'set',\n          value: lazyGetter(),\n          options: {\n            mutableLeaf: !this.definition.options.immutable\n          }\n        }, this.tree.options);\n\n        if ('data' in result) this.tree._data = result.data;\n      }\n\n      // Notifying the monkey's update so we can handle recursivity\n      this.tree.emit('_monkey', { monkey: this, path: this.path });\n\n      return this;\n    }\n\n    /**\n     * Method releasing the monkey from memory.\n     */\n  }, {\n    key: 'release',\n    value: function release() {\n\n      // Unbinding events\n      this.tree.off('write', this.writeListener);\n      this.tree.off('_monkey', this.monkeyListener);\n      this.state.killed = true;\n\n      // Deleting properties\n      // NOTE: not deleting this.definition because some strange things happen\n      // in the _refreshMonkeys method. See #372.\n      delete this.projection;\n      delete this.depPaths;\n      delete this.tree;\n    }\n  }]);\n\n  return Monkey;\n})();\n\nexports.Monkey = Monkey;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/baobab/dist/monkey.js\n ** module id = 17\n ** module chunks = 0\n **/","/**\n * Baobab Type Checking\n * =====================\n *\n * Helpers functions used throughout the library to perform some type\n * tests at runtime.\n *\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _monkey = require('./monkey');\n\nvar type = {};\n\n/**\n * Helpers\n * --------\n */\n\n/**\n * Checking whether the given variable is of any of the given types.\n *\n * @todo   Optimize this function by dropping `some`.\n *\n * @param  {mixed} target  - Variable to test.\n * @param  {array} allowed - Array of allowed types.\n * @return {boolean}\n */\nfunction anyOf(target, allowed) {\n  return allowed.some(function (t) {\n    return type[t](target);\n  });\n}\n\n/**\n * Simple types\n * -------------\n */\n\n/**\n * Checking whether the given variable is an array.\n *\n * @param  {mixed} target - Variable to test.\n * @return {boolean}\n */\ntype.array = function (target) {\n  return Array.isArray(target);\n};\n\n/**\n * Checking whether the given variable is an object.\n *\n * @param  {mixed} target - Variable to test.\n * @return {boolean}\n */\ntype.object = function (target) {\n  return target && typeof target === 'object' && !Array.isArray(target) && !(target instanceof Date) && !(target instanceof RegExp) && !(typeof Map === 'function' && target instanceof Map) && !(typeof Set === 'function' && target instanceof Set);\n};\n\n/**\n * Checking whether the given variable is a string.\n *\n * @param  {mixed} target - Variable to test.\n * @return {boolean}\n */\ntype.string = function (target) {\n  return typeof target === 'string';\n};\n\n/**\n * Checking whether the given variable is a number.\n *\n * @param  {mixed} target - Variable to test.\n * @return {boolean}\n */\ntype.number = function (target) {\n  return typeof target === 'number';\n};\n\n/**\n * Checking whether the given variable is a function.\n *\n * @param  {mixed} target - Variable to test.\n * @return {boolean}\n */\ntype['function'] = function (target) {\n  return typeof target === 'function';\n};\n\n/**\n * Checking whether the given variable is a JavaScript primitive.\n *\n * @param  {mixed} target - Variable to test.\n * @return {boolean}\n */\ntype.primitive = function (target) {\n  return target !== Object(target);\n};\n\n/**\n * Complex types\n * --------------\n */\n\n/**\n * Checking whether the given variable is a valid splicer.\n *\n * @param  {mixed} target    - Variable to test.\n * @param  {array} [allowed] - Optional valid types in path.\n * @return {boolean}\n */\ntype.splicer = function (target) {\n  if (!type.array(target) || target.length < 2) return false;\n\n  return anyOf(target[0], ['number', 'function', 'object']) && type.number(target[1]);\n};\n\n/**\n * Checking whether the given variable is a valid cursor path.\n *\n * @param  {mixed} target    - Variable to test.\n * @param  {array} [allowed] - Optional valid types in path.\n * @return {boolean}\n */\n\n// Order is important for performance reasons\nvar ALLOWED_FOR_PATH = ['string', 'number', 'function', 'object'];\n\ntype.path = function (target) {\n  if (!target && target !== 0 && target !== '') return false;\n\n  return [].concat(target).every(function (step) {\n    return anyOf(step, ALLOWED_FOR_PATH);\n  });\n};\n\n/**\n * Checking whether the given path is a dynamic one.\n *\n * @param  {mixed} path - The path to test.\n * @return {boolean}\n */\ntype.dynamicPath = function (path) {\n  return path.some(function (step) {\n    return type['function'](step) || type.object(step);\n  });\n};\n\n/**\n * Retrieve any monkey subpath in the given path or null if the path never comes\n * across computed data.\n *\n * @param  {mixed} data - The data to test.\n * @param  {array} path - The path to test.\n * @return {boolean}\n */\ntype.monkeyPath = function (data, path) {\n  var subpath = [];\n\n  var c = data,\n      i = undefined,\n      l = undefined;\n\n  for (i = 0, l = path.length; i < l; i++) {\n    subpath.push(path[i]);\n\n    if (typeof c !== 'object') return null;\n\n    c = c[path[i]];\n\n    if (c instanceof _monkey.Monkey) return subpath;\n  }\n\n  return null;\n};\n\n/**\n * Check if the given object property is a lazy getter used by a monkey.\n *\n * @param  {mixed}   o           - The target object.\n * @param  {string}  propertyKey - The property to test.\n * @return {boolean}\n */\ntype.lazyGetter = function (o, propertyKey) {\n  var descriptor = Object.getOwnPropertyDescriptor(o, propertyKey);\n\n  return descriptor && descriptor.get && descriptor.get.isLazyGetter === true;\n};\n\n/**\n * Returns the type of the given monkey definition or `null` if invalid.\n *\n * @param  {mixed} definition - The definition to check.\n * @return {string|null}\n */\ntype.monkeyDefinition = function (definition) {\n\n  if (type.object(definition)) {\n    if (!type['function'](definition.get) || definition.cursors && (!type.object(definition.cursors) || !Object.keys(definition.cursors).every(function (k) {\n      return type.path(definition.cursors[k]);\n    }))) return null;\n\n    return 'object';\n  } else if (type.array(definition)) {\n    var offset = 1;\n\n    if (type.object(definition[definition.length - 1])) offset++;\n\n    if (!type['function'](definition[definition.length - offset]) || !definition.slice(0, -offset).every(function (p) {\n      return type.path(p);\n    })) return null;\n\n    return 'array';\n  }\n\n  return null;\n};\n\n/**\n * Checking whether the given watcher definition is valid.\n *\n * @param  {mixed}   definition - The definition to check.\n * @return {boolean}\n */\ntype.watcherMapping = function (definition) {\n  return type.object(definition) && Object.keys(definition).every(function (k) {\n    return type.path(definition[k]);\n  });\n};\n\n/**\n * Checking whether the given string is a valid operation type.\n *\n * @param  {mixed} string - The string to test.\n * @return {boolean}\n */\n\n// Ordered by likeliness\nvar VALID_OPERATIONS = ['set', 'apply', 'push', 'unshift', 'concat', 'pop', 'shift', 'deepMerge', 'merge', 'splice', 'unset'];\n\ntype.operationType = function (string) {\n  return typeof string === 'string' && !! ~VALID_OPERATIONS.indexOf(string);\n};\n\nexports['default'] = type;\nmodule.exports = exports['default'];\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/baobab/dist/type.js\n ** module id = 18\n ** module chunks = 0\n **/","/**\n * Baobab Update\n * ==============\n *\n * The tree's update scheme.\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports['default'] = update;\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }\n\nvar _type = require('./type');\n\nvar _type2 = _interopRequireDefault(_type);\n\nvar _helpers = require('./helpers');\n\nfunction err(operation, expectedTarget, path) {\n  return (0, _helpers.makeError)('Baobab.update: cannot apply the \"' + operation + '\" on ' + ('a non ' + expectedTarget + ' (path: /' + path.join('/') + ').'), { path: path });\n}\n\n/**\n * Function aiming at applying a single update operation on the given tree's\n * data.\n *\n * @param  {mixed}  data      - The tree's data.\n * @param  {path}   path      - Path of the update.\n * @param  {object} operation - The operation to apply.\n * @param  {object} [opts]    - Optional options.\n * @return {mixed}            - Both the new tree's data and the updated node.\n */\n\nfunction update(data, path, operation) {\n  var opts = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];\n  var operationType = operation.type;\n  var value = operation.value;\n  var _operation$options = operation.options;\n  var operationOptions = _operation$options === undefined ? {} : _operation$options;\n\n  // Dummy root, so we can shift and alter the root\n  var dummy = { root: data },\n      dummyPath = ['root'].concat(_toConsumableArray(path)),\n      currentPath = [];\n\n  // Walking the path\n  var p = dummy,\n      i = undefined,\n      l = undefined,\n      s = undefined;\n\n  for (i = 0, l = dummyPath.length; i < l; i++) {\n\n    // Current item's reference is therefore p[s]\n    // The reason why we don't create a variable here for convenience\n    // is because we actually need to mutate the reference.\n    s = dummyPath[i];\n\n    // Updating the path\n    if (i > 0) currentPath.push(s);\n\n    // If we reached the end of the path, we apply the operation\n    if (i === l - 1) {\n\n      /**\n       * Set\n       */\n      if (operationType === 'set') {\n\n        // Purity check\n        if (opts.pure && p[s] === value) return { node: p[s] };\n\n        if (_type2['default'].lazyGetter(p, s)) {\n          Object.defineProperty(p, s, {\n            value: value,\n            enumerable: true,\n            configurable: true\n          });\n        } else if (opts.persistent && !operationOptions.mutableLeaf) {\n          p[s] = (0, _helpers.shallowClone)(value);\n        } else {\n          p[s] = value;\n        }\n      }\n\n      /**\n       * Monkey\n       */\n      else if (operationType === 'monkey') {\n          Object.defineProperty(p, s, {\n            get: value,\n            enumerable: true,\n            configurable: true\n          });\n        }\n\n        /**\n         * Apply\n         */\n        else if (operationType === 'apply') {\n            var result = value(p[s]);\n\n            // Purity check\n            if (opts.pure && p[s] === result) return { node: p[s] };\n\n            if (_type2['default'].lazyGetter(p, s)) {\n              Object.defineProperty(p, s, {\n                value: result,\n                enumerable: true,\n                configurable: true\n              });\n            } else if (opts.persistent) {\n              p[s] = (0, _helpers.shallowClone)(result);\n            } else {\n              p[s] = result;\n            }\n          }\n\n          /**\n           * Push\n           */\n          else if (operationType === 'push') {\n              if (!_type2['default'].array(p[s])) throw err('push', 'array', currentPath);\n\n              if (opts.persistent) p[s] = p[s].concat([value]);else p[s].push(value);\n            }\n\n            /**\n             * Unshift\n             */\n            else if (operationType === 'unshift') {\n                if (!_type2['default'].array(p[s])) throw err('unshift', 'array', currentPath);\n\n                if (opts.persistent) p[s] = [value].concat(p[s]);else p[s].unshift(value);\n              }\n\n              /**\n               * Concat\n               */\n              else if (operationType === 'concat') {\n                  if (!_type2['default'].array(p[s])) throw err('concat', 'array', currentPath);\n\n                  if (opts.persistent) p[s] = p[s].concat(value);else p[s].push.apply(p[s], value);\n                }\n\n                /**\n                 * Splice\n                 */\n                else if (operationType === 'splice') {\n                    if (!_type2['default'].array(p[s])) throw err('splice', 'array', currentPath);\n\n                    if (opts.persistent) p[s] = _helpers.splice.apply(null, [p[s]].concat(value));else p[s].splice.apply(p[s], value);\n                  }\n\n                  /**\n                   * Pop\n                   */\n                  else if (operationType === 'pop') {\n                      if (!_type2['default'].array(p[s])) throw err('pop', 'array', currentPath);\n\n                      if (opts.persistent) p[s] = (0, _helpers.splice)(p[s], -1, 1);else p[s].pop();\n                    }\n\n                    /**\n                     * Shift\n                     */\n                    else if (operationType === 'shift') {\n                        if (!_type2['default'].array(p[s])) throw err('shift', 'array', currentPath);\n\n                        if (opts.persistent) p[s] = (0, _helpers.splice)(p[s], 0, 1);else p[s].shift();\n                      }\n\n                      /**\n                       * Unset\n                       */\n                      else if (operationType === 'unset') {\n                          if (_type2['default'].object(p)) delete p[s];else if (_type2['default'].array(p)) p.splice(s, 1);\n                        }\n\n                        /**\n                         * Merge\n                         */\n                        else if (operationType === 'merge') {\n                            if (!_type2['default'].object(p[s])) throw err('merge', 'object', currentPath);\n\n                            if (opts.persistent) p[s] = (0, _helpers.shallowMerge)({}, p[s], value);else p[s] = (0, _helpers.shallowMerge)(p[s], value);\n                          }\n\n                          /**\n                           * Deep merge\n                           */\n                          else if (operationType === 'deepMerge') {\n                              if (!_type2['default'].object(p[s])) throw err('deepMerge', 'object', currentPath);\n\n                              if (opts.persistent) p[s] = (0, _helpers.deepMerge)({}, p[s], value);else p[s] = (0, _helpers.deepMerge)(p[s], value);\n                            }\n\n      // Deep freezing the resulting value\n      if (opts.immutable && !operationOptions.mutableLeaf) (0, _helpers.deepFreeze)(p);\n\n      break;\n    }\n\n    // If we reached a leaf, we override by setting an empty object\n    else if (_type2['default'].primitive(p[s])) {\n        p[s] = {};\n      }\n\n      // Else, we shift the reference and continue the path\n      else if (opts.persistent) {\n          p[s] = (0, _helpers.shallowClone)(p[s]);\n        }\n\n    // Should we freeze the current step before continuing?\n    if (opts.immutable && l > 0) (0, _helpers.freeze)(p);\n\n    p = p[s];\n  }\n\n  // If we are updating a dynamic node, we need not return the affected node\n  if (_type2['default'].lazyGetter(p, s)) return { data: dummy.root };\n\n  // Returning new data object\n  return { data: dummy.root, node: p[s] };\n}\n\nmodule.exports = exports['default'];\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/baobab/dist/update.js\n ** module id = 19\n ** module chunks = 0\n **/","/* eslint eqeqeq: 0 */\n\n/**\n * Baobab Helpers\n * ===============\n *\n * Miscellaneous helper functions.\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nexports.arrayFrom = arrayFrom;\nexports.before = before;\nexports.coercePath = coercePath;\nexports.getIn = getIn;\nexports.makeError = makeError;\nexports.solveRelativePath = solveRelativePath;\nexports.solveUpdate = solveUpdate;\nexports.splice = splice;\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nvar _monkey = require('./monkey');\n\nvar _type = require('./type');\n\nvar _type2 = _interopRequireDefault(_type);\n\n/**\n * Noop function\n */\nvar noop = Function.prototype;\n\n/**\n * Function returning the index of the first element of a list matching the\n * given predicate.\n *\n * @param  {array}     a  - The target array.\n * @param  {function}  fn - The predicate function.\n * @return {mixed}        - The index of the first matching item or -1.\n */\nfunction index(a, fn) {\n  var i = undefined,\n      l = undefined;\n  for (i = 0, l = a.length; i < l; i++) {\n    if (fn(a[i])) return i;\n  }\n  return -1;\n}\n\n/**\n * Efficient slice function used to clone arrays or parts of them.\n *\n * @param  {array} array - The array to slice.\n * @return {array}       - The sliced array.\n */\nfunction slice(array) {\n  var newArray = new Array(array.length);\n\n  var i = undefined,\n      l = undefined;\n\n  for (i = 0, l = array.length; i < l; i++) newArray[i] = array[i];\n\n  return newArray;\n}\n\n/**\n * Archive abstraction\n *\n * @constructor\n * @param {integer} size - Maximum number of records to store.\n */\n\nvar Archive = (function () {\n  function Archive(size) {\n    _classCallCheck(this, Archive);\n\n    this.size = size;\n    this.records = [];\n  }\n\n  /**\n   * Function creating a real array from what should be an array but is not.\n   * I'm looking at you nasty `arguments`...\n   *\n   * @param  {mixed} culprit - The culprit to convert.\n   * @return {array}         - The real array.\n   */\n\n  /**\n   * Method retrieving the records.\n   *\n   * @return {array} - The records.\n   */\n\n  _createClass(Archive, [{\n    key: 'get',\n    value: function get() {\n      return this.records;\n    }\n\n    /**\n     * Method adding a record to the archive\n     *\n     * @param {object}  record - The record to store.\n     * @return {Archive}       - The archive itself for chaining purposes.\n     */\n  }, {\n    key: 'add',\n    value: function add(record) {\n      this.records.unshift(record);\n\n      // If the number of records is exceeded, we truncate the records\n      if (this.records.length > this.size) this.records.length = this.size;\n\n      return this;\n    }\n\n    /**\n     * Method clearing the records.\n     *\n     * @return {Archive} - The archive itself for chaining purposes.\n     */\n  }, {\n    key: 'clear',\n    value: function clear() {\n      this.records = [];\n      return this;\n    }\n\n    /**\n     * Method to go back in time.\n     *\n     * @param {integer} steps - Number of steps we should go back by.\n     * @return {number}       - The last record.\n     */\n  }, {\n    key: 'back',\n    value: function back(steps) {\n      var record = this.records[steps - 1];\n\n      if (record) this.records = this.records.slice(steps);\n      return record;\n    }\n  }]);\n\n  return Archive;\n})();\n\nexports.Archive = Archive;\n\nfunction arrayFrom(culprit) {\n  return slice(culprit);\n}\n\n/**\n * Function decorating one function with another that will be called before the\n * decorated one.\n *\n * @param  {function} decorator - The decorating function.\n * @param  {function} fn        - The function to decorate.\n * @return {function}           - The decorated function.\n */\n\nfunction before(decorator, fn) {\n  return function () {\n    decorator.apply(null, arguments);\n    fn.apply(null, arguments);\n  };\n}\n\n/**\n * Function cloning the given regular expression. Supports `y` and `u` flags\n * already.\n *\n * @param  {RegExp} re - The target regular expression.\n * @return {RegExp}    - The cloned regular expression.\n */\nfunction cloneRegexp(re) {\n  var pattern = re.source;\n\n  var flags = '';\n\n  if (re.global) flags += 'g';\n  if (re.multiline) flags += 'm';\n  if (re.ignoreCase) flags += 'i';\n  if (re.sticky) flags += 'y';\n  if (re.unicode) flags += 'u';\n\n  return new RegExp(pattern, flags);\n}\n\n/**\n * Function cloning the given variable.\n *\n * @todo: implement a faster way to clone an array.\n *\n * @param  {boolean} deep - Should we deep clone the variable.\n * @param  {mixed}   item - The variable to clone\n * @return {mixed}        - The cloned variable.\n */\nfunction cloner(deep, item) {\n  if (!item || typeof item !== 'object' || item instanceof Error || item instanceof _monkey.MonkeyDefinition || item instanceof _monkey.Monkey || 'ArrayBuffer' in global && item instanceof ArrayBuffer) return item;\n\n  // Array\n  if (_type2['default'].array(item)) {\n    if (deep) {\n      var a = [];\n\n      var i = undefined,\n          l = undefined;\n\n      for (i = 0, l = item.length; i < l; i++) a.push(cloner(true, item[i]));\n      return a;\n    }\n\n    return slice(item);\n  }\n\n  // Date\n  if (item instanceof Date) return new Date(item.getTime());\n\n  // RegExp\n  if (item instanceof RegExp) return cloneRegexp(item);\n\n  // Object\n  if (_type2['default'].object(item)) {\n    var o = {};\n\n    var k = undefined;\n\n    // NOTE: could be possible to erase computed properties through `null`.\n    for (k in item) {\n      if (_type2['default'].lazyGetter(item, k)) {\n        Object.defineProperty(o, k, {\n          get: Object.getOwnPropertyDescriptor(item, k).get,\n          enumerable: true,\n          configurable: true\n        });\n      } else if (item.hasOwnProperty(k)) {\n        o[k] = deep ? cloner(true, item[k]) : item[k];\n      }\n    }\n    return o;\n  }\n\n  return item;\n}\n\n/**\n * Exporting shallow and deep cloning functions.\n */\nvar shallowClone = cloner.bind(null, false),\n    deepClone = cloner.bind(null, true);\n\nexports.shallowClone = shallowClone;\nexports.deepClone = deepClone;\n\n/**\n * Coerce the given variable into a full-fledged path.\n *\n * @param  {mixed} target - The variable to coerce.\n * @return {array}        - The array path.\n */\n\nfunction coercePath(target) {\n  if (target || target === 0 || target === '') return target;\n  return [];\n}\n\n/**\n * Function comparing an object's properties to a given descriptive\n * object.\n *\n * @param  {object} object      - The object to compare.\n * @param  {object} description - The description's mapping.\n * @return {boolean}            - Whether the object matches the description.\n */\nfunction compare(object, description) {\n  var ok = true,\n      k = undefined;\n\n  // If we reached here via a recursive call, object may be undefined because\n  // not all items in a collection will have the same deep nesting structure.\n  if (!object) return false;\n\n  for (k in description) {\n    if (_type2['default'].object(description[k])) {\n      ok = ok && compare(object[k], description[k]);\n    } else if (_type2['default'].array(description[k])) {\n      ok = ok && !! ~description[k].indexOf(object[k]);\n    } else {\n      if (object[k] !== description[k]) return false;\n    }\n  }\n\n  return ok;\n}\n\n/**\n * Function freezing the given variable if possible.\n *\n * @param  {boolean} deep - Should we recursively freeze the given objects?\n * @param  {object}  o    - The variable to freeze.\n * @return {object}    - The merged object.\n */\nfunction freezer(deep, o) {\n  if (typeof o !== 'object' || o === null || o instanceof _monkey.Monkey) return;\n\n  Object.freeze(o);\n\n  if (!deep) return;\n\n  if (Array.isArray(o)) {\n\n    // Iterating through the elements\n    var i = undefined,\n        l = undefined;\n\n    for (i = 0, l = o.length; i < l; i++) freezer(true, o[i]);\n  } else {\n    var p = undefined,\n        k = undefined;\n\n    for (k in o) {\n      if (_type2['default'].lazyGetter(o, k)) continue;\n\n      p = o[k];\n\n      if (!p || !o.hasOwnProperty(k) || typeof p !== 'object' || Object.isFrozen(p)) continue;\n\n      freezer(true, p);\n    }\n  }\n}\n\n/**\n * Exporting both `freeze` and `deepFreeze` functions.\n * Note that if the engine does not support `Object.freeze` then this will\n * export noop functions instead.\n */\nvar isFreezeSupported = typeof Object.freeze === 'function';\n\nvar freeze = isFreezeSupported ? freezer.bind(null, false) : noop,\n    deepFreeze = isFreezeSupported ? freezer.bind(null, true) : noop;\n\nexports.freeze = freeze;\nexports.deepFreeze = deepFreeze;\n\n/**\n * Function retrieving nested data within the given object and according to\n * the given path.\n *\n * @todo: work if dynamic path hit objects also.\n * @todo: memoized perfgetters.\n *\n * @param  {object}  object - The object we need to get data from.\n * @param  {array}   path   - The path to follow.\n * @return {object}  result            - The result.\n * @return {mixed}   result.data       - The data at path, or `undefined`.\n * @return {array}   result.solvedPath - The solved path or `null`.\n * @return {boolean} result.exists     - Does the path exists in the tree?\n */\nvar NOT_FOUND_OBJECT = { data: undefined, solvedPath: null, exists: false };\n\nfunction getIn(object, path) {\n  if (!path) return NOT_FOUND_OBJECT;\n\n  var solvedPath = [];\n\n  var exists = true,\n      c = object,\n      idx = undefined,\n      i = undefined,\n      l = undefined;\n\n  for (i = 0, l = path.length; i < l; i++) {\n    if (!c) return {\n      data: undefined,\n      solvedPath: solvedPath.concat(path.slice(i)),\n      exists: false\n    };\n\n    if (typeof path[i] === 'function') {\n      if (!_type2['default'].array(c)) return NOT_FOUND_OBJECT;\n\n      idx = index(c, path[i]);\n      if (! ~idx) return NOT_FOUND_OBJECT;\n\n      solvedPath.push(idx);\n      c = c[idx];\n    } else if (typeof path[i] === 'object') {\n      if (!_type2['default'].array(c)) return NOT_FOUND_OBJECT;\n\n      idx = index(c, function (e) {\n        return compare(e, path[i]);\n      });\n      if (! ~idx) return NOT_FOUND_OBJECT;\n\n      solvedPath.push(idx);\n      c = c[idx];\n    } else {\n      solvedPath.push(path[i]);\n      exists = typeof c === 'object' && path[i] in c;\n      c = c[path[i]];\n    }\n  }\n\n  return { data: c, solvedPath: solvedPath, exists: exists };\n}\n\n/**\n * Little helper returning a JavaScript error carrying some data with it.\n *\n * @param  {string} message - The error message.\n * @param  {object} [data]  - Optional data to assign to the error.\n * @return {Error}          - The created error.\n */\n\nfunction makeError(message, data) {\n  var err = new Error(message);\n\n  for (var k in data) {\n    err[k] = data[k];\n  }return err;\n}\n\n/**\n * Function taking n objects to merge them together.\n * Note 1): the latter object will take precedence over the first one.\n * Note 2): the first object will be mutated to allow for perf scenarios.\n * Note 3): this function will consider monkeys as leaves.\n *\n * @param  {boolean}   deep    - Whether the merge should be deep or not.\n * @param  {...object} objects - Objects to merge.\n * @return {object}            - The merged object.\n */\nfunction merger(deep) {\n  for (var _len = arguments.length, objects = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    objects[_key - 1] = arguments[_key];\n  }\n\n  var o = objects[0];\n\n  var t = undefined,\n      i = undefined,\n      l = undefined,\n      k = undefined;\n\n  for (i = 1, l = objects.length; i < l; i++) {\n    t = objects[i];\n\n    for (k in t) {\n      if (deep && _type2['default'].object(t[k]) && !(t[k] instanceof _monkey.Monkey)) {\n        o[k] = merger(true, o[k] || {}, t[k]);\n      } else {\n        o[k] = t[k];\n      }\n    }\n  }\n\n  return o;\n}\n\n/**\n * Exporting both `shallowMerge` and `deepMerge` functions.\n */\nvar shallowMerge = merger.bind(null, false),\n    deepMerge = merger.bind(null, true);\n\nexports.shallowMerge = shallowMerge;\nexports.deepMerge = deepMerge;\n\n/**\n * Solving a potentially relative path.\n *\n * @param  {array} base - The base path from which to solve the path.\n * @param  {array} to   - The subpath to reach.\n * @param  {array}      - The solved absolute path.\n */\n\nfunction solveRelativePath(base, to) {\n  var solvedPath = [];\n\n  // Coercing to array\n  to = [].concat(to);\n\n  for (var i = 0, l = to.length; i < l; i++) {\n    var step = to[i];\n\n    if (step === '.') {\n      if (!i) solvedPath = base.slice(0);\n    } else if (step === '..') {\n      solvedPath = (!i ? base : solvedPath).slice(0, -1);\n    } else {\n      solvedPath.push(step);\n    }\n  }\n\n  return solvedPath;\n}\n\n/**\n * Function determining whether some paths in the tree were affected by some\n * updates that occurred at the given paths. This helper is mainly used at\n * cursor level to determine whether the cursor is concerned by the updates\n * fired at tree level.\n *\n * NOTES: 1) If performance become an issue, the following threefold loop\n *           can be simplified to a complex twofold one.\n *        2) A regex version could also work but I am not confident it would\n *           be faster.\n *        3) Another solution would be to keep a register of cursors like with\n *           the monkeys and update along this tree.\n *\n * @param  {array} affectedPaths - The paths that were updated.\n * @param  {array} comparedPaths - The paths that we are actually interested in.\n * @return {boolean}             - Is the update relevant to the compared\n *                                 paths?\n */\n\nfunction solveUpdate(affectedPaths, comparedPaths) {\n  var i = undefined,\n      j = undefined,\n      k = undefined,\n      l = undefined,\n      m = undefined,\n      n = undefined,\n      p = undefined,\n      c = undefined,\n      s = undefined;\n\n  // Looping through possible paths\n  for (i = 0, l = affectedPaths.length; i < l; i++) {\n    p = affectedPaths[i];\n\n    if (!p.length) return true;\n\n    // Looping through logged paths\n    for (j = 0, m = comparedPaths.length; j < m; j++) {\n      c = comparedPaths[j];\n\n      if (!c || !c.length) return true;\n\n      // Looping through steps\n      for (k = 0, n = c.length; k < n; k++) {\n        s = c[k];\n\n        // If path is not relevant, we break\n        // NOTE: the '!=' instead of '!==' is required here!\n        if (s != p[k]) break;\n\n        // If we reached last item and we are relevant\n        if (k + 1 === n || k + 1 === p.length) return true;\n      }\n    }\n  }\n\n  return false;\n}\n\n/**\n * Non-mutative version of the splice array method.\n *\n * @param  {array}    array        - The array to splice.\n * @param  {integer}  startIndex   - The start index.\n * @param  {integer}  nb           - Number of elements to remove.\n * @param  {...mixed} elements     - Elements to append after splicing.\n * @return {array}                 - The spliced array.\n */\n\nfunction splice(array, startIndex, nb) {\n  nb = Math.max(0, nb);\n\n  // Solving startIndex\n  if (_type2['default']['function'](startIndex)) startIndex = index(array, startIndex);\n  if (_type2['default'].object(startIndex)) startIndex = index(array, function (e) {\n    return compare(e, startIndex);\n  });\n\n  // Positive index\n\n  for (var _len2 = arguments.length, elements = Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {\n    elements[_key2 - 3] = arguments[_key2];\n  }\n\n  if (startIndex >= 0) return array.slice(0, startIndex).concat(elements).concat(array.slice(startIndex + nb));\n\n  // Negative index\n  return array.slice(0, array.length + startIndex).concat(elements).concat(array.slice(array.length + startIndex + nb));\n}\n\n/**\n * Function returning a unique incremental id each time it is called.\n *\n * @return {integer} - The latest unique id.\n */\nvar uniqid = (function () {\n  var i = 0;\n\n  return function () {\n    return i++;\n  };\n})();\n\nexports.uniqid = uniqid;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/baobab/dist/helpers.js\n ** module id = 20\n ** module chunks = 0\n **/","/**\n * Baobab Watchers\n * ================\n *\n * Abstraction used to listen and retrieve data from multiple parts of a\n * Baobab tree at once.\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nvar _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _emmett = require('emmett');\n\nvar _emmett2 = _interopRequireDefault(_emmett);\n\nvar _cursor = require('./cursor');\n\nvar _cursor2 = _interopRequireDefault(_cursor);\n\nvar _type = require('./type');\n\nvar _type2 = _interopRequireDefault(_type);\n\nvar _helpers = require('./helpers');\n\n/**\n * Watcher class.\n *\n * @constructor\n * @param {Baobab} tree     - The watched tree.\n * @param {object} mapping  - A mapping of the paths to watch in the tree.\n */\n\nvar Watcher = (function (_Emitter) {\n  _inherits(Watcher, _Emitter);\n\n  function Watcher(tree, mapping) {\n    var _this = this;\n\n    _classCallCheck(this, Watcher);\n\n    _get(Object.getPrototypeOf(Watcher.prototype), 'constructor', this).call(this);\n\n    // Properties\n    this.tree = tree;\n    this.mapping = null;\n\n    this.state = {\n      killed: false\n    };\n\n    // Initializing\n    this.refresh(mapping);\n\n    // Listening\n    this.handler = function (e) {\n      if (_this.state.killed) return;\n\n      var watchedPaths = _this.getWatchedPaths();\n\n      if ((0, _helpers.solveUpdate)(e.data.paths, watchedPaths)) return _this.emit('update');\n    };\n\n    this.tree.on('update', this.handler);\n  }\n\n  /**\n   * Method used to get the current watched paths.\n   *\n   * @return {array} - The array of watched paths.\n   */\n\n  _createClass(Watcher, [{\n    key: 'getWatchedPaths',\n    value: function getWatchedPaths() {\n      var _this2 = this;\n\n      var rawPaths = Object.keys(this.mapping).map(function (k) {\n        var v = _this2.mapping[k];\n\n        // Watcher mappings can accept a cursor\n        if (v instanceof _cursor2['default']) return v.solvedPath;\n\n        return _this2.mapping[k];\n      });\n\n      return rawPaths.reduce(function (cp, p) {\n\n        // Handling path polymorphisms\n        p = [].concat(p);\n\n        // Dynamic path?\n        if (_type2['default'].dynamicPath(p)) p = (0, _helpers.getIn)(_this2.tree._data, p).solvedPath;\n\n        if (!p) return cp;\n\n        // Facet path?\n        var monkeyPath = _type2['default'].monkeyPath(_this2.tree._monkeys, p);\n\n        if (monkeyPath) return cp.concat((0, _helpers.getIn)(_this2.tree._monkeys, monkeyPath).data.relatedPaths());\n\n        return cp.concat([p]);\n      }, []);\n    }\n\n    /**\n     * Method used to return a map of the watcher's cursors.\n     *\n     * @return {object} - TMap of relevant cursors.\n     */\n  }, {\n    key: 'getCursors',\n    value: function getCursors() {\n      var _this3 = this;\n\n      var cursors = {};\n\n      Object.keys(this.mapping).forEach(function (k) {\n        var path = _this3.mapping[k];\n\n        if (path instanceof _cursor2['default']) cursors[k] = path;else cursors[k] = _this3.tree.select(path);\n      });\n\n      return cursors;\n    }\n\n    /**\n     * Method used to refresh the watcher's mapping.\n     *\n     * @param  {object}  mapping  - The new mapping to apply.\n     * @return {Watcher}          - Itself for chaining purposes.\n     */\n  }, {\n    key: 'refresh',\n    value: function refresh(mapping) {\n\n      if (!_type2['default'].watcherMapping(mapping)) throw (0, _helpers.makeError)('Baobab.watch: invalid mapping.', { mapping: mapping });\n\n      this.mapping = mapping;\n\n      // Creating the get method\n      var projection = {};\n\n      for (var k in mapping) {\n        projection[k] = mapping[k] instanceof _cursor2['default'] ? mapping[k].path : mapping[k];\n      }this.get = this.tree.project.bind(this.tree, projection);\n    }\n\n    /**\n     * Methods releasing the watcher from memory.\n     */\n  }, {\n    key: 'release',\n    value: function release() {\n\n      this.tree.off('update', this.handler);\n      this.state.killed = true;\n      this.kill();\n    }\n  }]);\n\n  return Watcher;\n})(_emmett2['default']);\n\nexports['default'] = Watcher;\nmodule.exports = exports['default'];\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/baobab/dist/watcher.js\n ** module id = 21\n ** module chunks = 0\n **/","export const addToSubscriptionIdsStorage = (id) => {\r\n    let existingSubscriptionIds = [];\r\n    if (window.localStorage.getItem(\"subscriptionIds\")) {\r\n        existingSubscriptionIds = JSON.parse(window.localStorage.getItem(\"subscriptionIds\"));\r\n    }\r\n    existingSubscriptionIds.push(id);\r\n    window.localStorage.setItem(\"subscriptionIds\", JSON.stringify(existingSubscriptionIds));\r\n\r\n}\r\n\r\nexport const removeFromSubscriptionIdsStorage = (id) => {\r\n    let existingSubscriptionIds = [];\r\n    if (window.localStorage.getItem(\"subscriptionIds\")) {\r\n        existingSubscriptionIds = JSON.parse(window.localStorage.getItem(\"subscriptionIds\"));\r\n    }\r\n    existingSubscriptionIds = existingSubscriptionIds.filter((l) => l != id);\r\n\r\n    window.localStorage.setItem(\"subscriptionIds\", JSON.stringify(existingSubscriptionIds));\r\n\r\n}\r\n\r\nexport const getSubscriptionIdsFromStorage = () => {\r\n    if (window.localStorage.getItem(\"subscriptionIds\")) {\r\n        return JSON.parse(window.localStorage.getItem(\"subscriptionIds\"));\r\n    }\r\n    return [];\r\n}\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./app/storage/subscriptionIds.helper.js\n **/","module.exports = \"<ion-modal-view> <ion-header-bar> <h1 class=title> </h1> <button class=\\\"button icon icon-left ion-ios-close-outline\\\" ng-click=closeModal()></button> </ion-header-bar> <ion-content> <ion-list> <ion-item ng-click=addLocation(loc) ng-repeat=\\\"loc in getLocationsForModal()\\\"> {{ loc.name }} </ion-item> </ion-list> </ion-content> </ion-modal-view>\";\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/components/tabs/dashboard/locationModal.html\n ** module id = 23\n ** module chunks = 0\n **/","module.exports = \"<ion-view view-title=Dashboard> <ion-nav-title> WEATHER GONG </ion-nav-title> <ion-content class=padding id=dashboard-page-container> <div class=current-weather-container> <div class=\\\"row header\\\"> <div class=col> </div> <div class=col></div> <div class=col></div> <div class=col> </div> <div class=col></div> <div class=col>'</div> <div class=col> </div> <div class=col></div> <div class=col></div> </div> <div class=row ng-repeat=\\\"row in currentData\\\"> <div class=col> <button class=\\\"button icon ion-ios-minus-outline\\\" ng-click=removeLocation(row.id)></button> </div> <div class=col>{{ row.location }}</div> <div class=col>{{ row.time }}</div> <div class=col>{{ row.wind }}</div> <div class=col>{{ row.windDirection }}</div> <div class=col>{{ row.temperature }}</div> <div class=col>{{ row.wave }}</div> <div class=col>{{ row.waveDirection }}</div> <div class=col> <button class=\\\"icon ion-ios-camera-outline\\\"/></div> </div> <div class=row> <div class=col> <button class=\\\"button icon ion-ios-plus-outline\\\" ng-click=showAddLocation()></button> </div> </div> </div> <div class=forecast-container> <h3> ( )</h3> <div class=\\\"row header\\\"> <div class=col> </div> <div class=col></div> <div class=col></div> <div class=col></div> <div class=col></div> <div class=col>'</div> <div class=col> </div> <div class=col></div> <div class=col></div> </div> <div class=row ng-repeat=\\\"row in forecastData\\\"> <div class=col> <button class=\\\"button icon ion-ios-minus-outline\\\" ng-click=removeLocation(row.id)></button> </div> <div class=col>{{ row.location }}</div> <div class=col>{{ row.time }}</div> <div class=col>{{ row.wind }}</div> <div class=col>{{ row.windDirection }}</div> <div class=col>{{ row.temperature }}</div> <div class=col>{{ row.wave }}</div> <div class=col>{{ row.waveDirection }}</div> <div class=col></div> </div> <div class=row> <div class=col> <button class=\\\"button icon ion-ios-plus-outline\\\" ng-click=showAddLocation()></button> </div> </div> </div> </ion-content> </ion-view>\";\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/components/tabs/dashboard/dashboard.html\n ** module id = 24\n ** module chunks = 0\n **/","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!./../../../../node_modules/css-loader/index.js!./../../../../node_modules/sass-loader/index.js!./dashboard.scss\");\nif(typeof content === 'string') content = [[module.id, content, '']];\n// add the styles to the DOM\nvar update = require(\"!./../../../../node_modules/style-loader/addStyles.js\")(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(module.hot) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!./../../../../node_modules/css-loader/index.js!./../../../../node_modules/sass-loader/index.js!./dashboard.scss\", function() {\n\t\t\tvar newContent = require(\"!!./../../../../node_modules/css-loader/index.js!./../../../../node_modules/sass-loader/index.js!./dashboard.scss\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/components/tabs/dashboard/dashboard.scss\n ** module id = 25\n ** module chunks = 0\n **/","exports = module.exports = require(\"./../../../../node_modules/css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \"#dashboard-page-container .scroll{direction:rtl}#dashboard-page-container .scroll>div{margin-bottom:60px;word-wrap:normal}#dashboard-page-container .scroll>div .col{text-align:right;min-width:37px;font-size:8px}#dashboard-page-container .scroll>div .col .button{background:transparent;min-height:auto;min-width:auto}#dashboard-page-container .scroll>div .col .button.icon:before{line-height:20px}#dashboard-page-container .scroll>div .col button.icon{font-size:21px;line-height:0;background:none;padding:0;margin:0;outline:0;border:none}\", \"\"]);\n\n// exports\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/css-loader!./~/sass-loader!./app/components/tabs/dashboard/dashboard.scss\n ** module id = 26\n ** module chunks = 0\n **/","/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n// css base code, injected by the css-loader\r\nmodule.exports = function() {\r\n\tvar list = [];\r\n\r\n\t// return the list of modules as css string\r\n\tlist.toString = function toString() {\r\n\t\tvar result = [];\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar item = this[i];\r\n\t\t\tif(item[2]) {\r\n\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\r\n\t\t\t} else {\r\n\t\t\t\tresult.push(item[1]);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result.join(\"\");\r\n\t};\r\n\r\n\t// import a list of modules into the list\r\n\tlist.i = function(modules, mediaQuery) {\r\n\t\tif(typeof modules === \"string\")\r\n\t\t\tmodules = [[null, modules, \"\"]];\r\n\t\tvar alreadyImportedModules = {};\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar id = this[i][0];\r\n\t\t\tif(typeof id === \"number\")\r\n\t\t\t\talreadyImportedModules[id] = true;\r\n\t\t}\r\n\t\tfor(i = 0; i < modules.length; i++) {\r\n\t\t\tvar item = modules[i];\r\n\t\t\t// skip already imported module\r\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\r\n\t\t\t//  when a module is imported multiple times with different media queries.\r\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\r\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\r\n\t\t\t\tif(mediaQuery && !item[2]) {\r\n\t\t\t\t\titem[2] = mediaQuery;\r\n\t\t\t\t} else if(mediaQuery) {\r\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\r\n\t\t\t\t}\r\n\t\t\t\tlist.push(item);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\treturn list;\r\n};\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/css-loader/lib/css-base.js\n ** module id = 27\n ** module chunks = 0\n **/","/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\nvar stylesInDom = {},\r\n\tmemoize = function(fn) {\r\n\t\tvar memo;\r\n\t\treturn function () {\r\n\t\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\r\n\t\t\treturn memo;\r\n\t\t};\r\n\t},\r\n\tisOldIE = memoize(function() {\r\n\t\treturn /msie [6-9]\\b/.test(window.navigator.userAgent.toLowerCase());\r\n\t}),\r\n\tgetHeadElement = memoize(function () {\r\n\t\treturn document.head || document.getElementsByTagName(\"head\")[0];\r\n\t}),\r\n\tsingletonElement = null,\r\n\tsingletonCounter = 0,\r\n\tstyleElementsInsertedAtTop = [];\r\n\r\nmodule.exports = function(list, options) {\r\n\tif(typeof DEBUG !== \"undefined\" && DEBUG) {\r\n\t\tif(typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\r\n\t}\r\n\r\n\toptions = options || {};\r\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\r\n\t// tags it will allow on a page\r\n\tif (typeof options.singleton === \"undefined\") options.singleton = isOldIE();\r\n\r\n\t// By default, add <style> tags to the bottom of <head>.\r\n\tif (typeof options.insertAt === \"undefined\") options.insertAt = \"bottom\";\r\n\r\n\tvar styles = listToStyles(list);\r\n\taddStylesToDom(styles, options);\r\n\r\n\treturn function update(newList) {\r\n\t\tvar mayRemove = [];\r\n\t\tfor(var i = 0; i < styles.length; i++) {\r\n\t\t\tvar item = styles[i];\r\n\t\t\tvar domStyle = stylesInDom[item.id];\r\n\t\t\tdomStyle.refs--;\r\n\t\t\tmayRemove.push(domStyle);\r\n\t\t}\r\n\t\tif(newList) {\r\n\t\t\tvar newStyles = listToStyles(newList);\r\n\t\t\taddStylesToDom(newStyles, options);\r\n\t\t}\r\n\t\tfor(var i = 0; i < mayRemove.length; i++) {\r\n\t\t\tvar domStyle = mayRemove[i];\r\n\t\t\tif(domStyle.refs === 0) {\r\n\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++)\r\n\t\t\t\t\tdomStyle.parts[j]();\r\n\t\t\t\tdelete stylesInDom[domStyle.id];\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n}\r\n\r\nfunction addStylesToDom(styles, options) {\r\n\tfor(var i = 0; i < styles.length; i++) {\r\n\t\tvar item = styles[i];\r\n\t\tvar domStyle = stylesInDom[item.id];\r\n\t\tif(domStyle) {\r\n\t\t\tdomStyle.refs++;\r\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\r\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\r\n\t\t\t}\r\n\t\t\tfor(; j < item.parts.length; j++) {\r\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tvar parts = [];\r\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\r\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\r\n\t\t\t}\r\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction listToStyles(list) {\r\n\tvar styles = [];\r\n\tvar newStyles = {};\r\n\tfor(var i = 0; i < list.length; i++) {\r\n\t\tvar item = list[i];\r\n\t\tvar id = item[0];\r\n\t\tvar css = item[1];\r\n\t\tvar media = item[2];\r\n\t\tvar sourceMap = item[3];\r\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\r\n\t\tif(!newStyles[id])\r\n\t\t\tstyles.push(newStyles[id] = {id: id, parts: [part]});\r\n\t\telse\r\n\t\t\tnewStyles[id].parts.push(part);\r\n\t}\r\n\treturn styles;\r\n}\r\n\r\nfunction insertStyleElement(options, styleElement) {\r\n\tvar head = getHeadElement();\r\n\tvar lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];\r\n\tif (options.insertAt === \"top\") {\r\n\t\tif(!lastStyleElementInsertedAtTop) {\r\n\t\t\thead.insertBefore(styleElement, head.firstChild);\r\n\t\t} else if(lastStyleElementInsertedAtTop.nextSibling) {\r\n\t\t\thead.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);\r\n\t\t} else {\r\n\t\t\thead.appendChild(styleElement);\r\n\t\t}\r\n\t\tstyleElementsInsertedAtTop.push(styleElement);\r\n\t} else if (options.insertAt === \"bottom\") {\r\n\t\thead.appendChild(styleElement);\r\n\t} else {\r\n\t\tthrow new Error(\"Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.\");\r\n\t}\r\n}\r\n\r\nfunction removeStyleElement(styleElement) {\r\n\tstyleElement.parentNode.removeChild(styleElement);\r\n\tvar idx = styleElementsInsertedAtTop.indexOf(styleElement);\r\n\tif(idx >= 0) {\r\n\t\tstyleElementsInsertedAtTop.splice(idx, 1);\r\n\t}\r\n}\r\n\r\nfunction createStyleElement(options) {\r\n\tvar styleElement = document.createElement(\"style\");\r\n\tstyleElement.type = \"text/css\";\r\n\tinsertStyleElement(options, styleElement);\r\n\treturn styleElement;\r\n}\r\n\r\nfunction createLinkElement(options) {\r\n\tvar linkElement = document.createElement(\"link\");\r\n\tlinkElement.rel = \"stylesheet\";\r\n\tinsertStyleElement(options, linkElement);\r\n\treturn linkElement;\r\n}\r\n\r\nfunction addStyle(obj, options) {\r\n\tvar styleElement, update, remove;\r\n\r\n\tif (options.singleton) {\r\n\t\tvar styleIndex = singletonCounter++;\r\n\t\tstyleElement = singletonElement || (singletonElement = createStyleElement(options));\r\n\t\tupdate = applyToSingletonTag.bind(null, styleElement, styleIndex, false);\r\n\t\tremove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);\r\n\t} else if(obj.sourceMap &&\r\n\t\ttypeof URL === \"function\" &&\r\n\t\ttypeof URL.createObjectURL === \"function\" &&\r\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\r\n\t\ttypeof Blob === \"function\" &&\r\n\t\ttypeof btoa === \"function\") {\r\n\t\tstyleElement = createLinkElement(options);\r\n\t\tupdate = updateLink.bind(null, styleElement);\r\n\t\tremove = function() {\r\n\t\t\tremoveStyleElement(styleElement);\r\n\t\t\tif(styleElement.href)\r\n\t\t\t\tURL.revokeObjectURL(styleElement.href);\r\n\t\t};\r\n\t} else {\r\n\t\tstyleElement = createStyleElement(options);\r\n\t\tupdate = applyToTag.bind(null, styleElement);\r\n\t\tremove = function() {\r\n\t\t\tremoveStyleElement(styleElement);\r\n\t\t};\r\n\t}\r\n\r\n\tupdate(obj);\r\n\r\n\treturn function updateStyle(newObj) {\r\n\t\tif(newObj) {\r\n\t\t\tif(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)\r\n\t\t\t\treturn;\r\n\t\t\tupdate(obj = newObj);\r\n\t\t} else {\r\n\t\t\tremove();\r\n\t\t}\r\n\t};\r\n}\r\n\r\nvar replaceText = (function () {\r\n\tvar textStore = [];\r\n\r\n\treturn function (index, replacement) {\r\n\t\ttextStore[index] = replacement;\r\n\t\treturn textStore.filter(Boolean).join('\\n');\r\n\t};\r\n})();\r\n\r\nfunction applyToSingletonTag(styleElement, index, remove, obj) {\r\n\tvar css = remove ? \"\" : obj.css;\r\n\r\n\tif (styleElement.styleSheet) {\r\n\t\tstyleElement.styleSheet.cssText = replaceText(index, css);\r\n\t} else {\r\n\t\tvar cssNode = document.createTextNode(css);\r\n\t\tvar childNodes = styleElement.childNodes;\r\n\t\tif (childNodes[index]) styleElement.removeChild(childNodes[index]);\r\n\t\tif (childNodes.length) {\r\n\t\t\tstyleElement.insertBefore(cssNode, childNodes[index]);\r\n\t\t} else {\r\n\t\t\tstyleElement.appendChild(cssNode);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction applyToTag(styleElement, obj) {\r\n\tvar css = obj.css;\r\n\tvar media = obj.media;\r\n\r\n\tif(media) {\r\n\t\tstyleElement.setAttribute(\"media\", media)\r\n\t}\r\n\r\n\tif(styleElement.styleSheet) {\r\n\t\tstyleElement.styleSheet.cssText = css;\r\n\t} else {\r\n\t\twhile(styleElement.firstChild) {\r\n\t\t\tstyleElement.removeChild(styleElement.firstChild);\r\n\t\t}\r\n\t\tstyleElement.appendChild(document.createTextNode(css));\r\n\t}\r\n}\r\n\r\nfunction updateLink(linkElement, obj) {\r\n\tvar css = obj.css;\r\n\tvar sourceMap = obj.sourceMap;\r\n\r\n\tif(sourceMap) {\r\n\t\t// http://stackoverflow.com/a/26603875\r\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\r\n\t}\r\n\r\n\tvar blob = new Blob([css], { type: \"text/css\" });\r\n\r\n\tvar oldSrc = linkElement.href;\r\n\r\n\tlinkElement.href = URL.createObjectURL(blob);\r\n\r\n\tif(oldSrc)\r\n\t\tURL.revokeObjectURL(oldSrc);\r\n}\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/style-loader/addStyles.js\n ** module id = 28\n ** module chunks = 0\n **/","export default ($stateProvider, $urlRouterProvider) => {\r\n    $stateProvider\r\n\r\n        // setup an abstract state for the tabs directive\r\n        .state('tab', {\r\n            url: '/tab',\r\n            abstract: true,\r\n            template: require('./tabs.html')\r\n        })\r\n}\n\n\n/** WEBPACK FOOTER **\n ** ./app/components/tabs/tabs.route.js\n **/","module.exports = \"<ion-tabs class=\\\"tabs-icon-top tabs-color-active-positive\\\"> <ion-tab title= href=#/tab/chats> <ion-nav-view name=tab-chats></ion-nav-view> </ion-tab> <ion-tab title=\\\" \\\" href=#/tab/account> <ion-nav-view name=tab-account></ion-nav-view> </ion-tab> <ion-tab title=\\\" \\\" href=#/tab/account> <ion-nav-view name=tab-account></ion-nav-view> </ion-tab> <ion-tab icon-off=ion-ios-home icon-on=ion-ios-home href=#/tab/dash> <ion-nav-view name=tab-dash></ion-nav-view> </ion-tab> </ion-tabs>\";\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/components/tabs/tabs.html\n ** module id = 30\n ** module chunks = 0\n **/","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!./../../../node_modules/css-loader/index.js!./../../../node_modules/sass-loader/index.js!./tabs.scss\");\nif(typeof content === 'string') content = [[module.id, content, '']];\n// add the styles to the DOM\nvar update = require(\"!./../../../node_modules/style-loader/addStyles.js\")(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(module.hot) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!./../../../node_modules/css-loader/index.js!./../../../node_modules/sass-loader/index.js!./tabs.scss\", function() {\n\t\t\tvar newContent = require(\"!!./../../../node_modules/css-loader/index.js!./../../../node_modules/sass-loader/index.js!./tabs.scss\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/components/tabs/tabs.scss\n ** module id = 31\n ** module chunks = 0\n **/","exports = module.exports = require(\"./../../../node_modules/css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \".tabs-icon-top>.tabs .tab-item{line-height:40px;font-size:15px}\", \"\"]);\n\n// exports\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/css-loader!./~/sass-loader!./app/components/tabs/tabs.scss\n ** module id = 32\n ** module chunks = 0\n **/","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!./../../node_modules/css-loader/index.js!./../../node_modules/sass-loader/index.js!./index.scss\");\nif(typeof content === 'string') content = [[module.id, content, '']];\n// add the styles to the DOM\nvar update = require(\"!./../../node_modules/style-loader/addStyles.js\")(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(module.hot) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!./../../node_modules/css-loader/index.js!./../../node_modules/sass-loader/index.js!./index.scss\", function() {\n\t\t\tvar newContent = require(\"!!./../../node_modules/css-loader/index.js!./../../node_modules/sass-loader/index.js!./index.scss\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/scss/index.scss\n ** module id = 33\n ** module chunks = 0\n **/","exports = module.exports = require(\"./../../node_modules/css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \"\", \"\"]);\n\n// exports\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/css-loader!./~/sass-loader!./app/scss/index.scss\n ** module id = 34\n ** module chunks = 0\n **/"],"sourceRoot":""}