{"version":3,"sources":["webpack:///bundle.js","webpack:///webpack/bootstrap 1ddeeeffac90dc673408","webpack:///./app/index.js","webpack:///./app/components/index.js","webpack:///./app/components/tabs/index.js","webpack:///./app/components/tabs/dashboard/index.js","webpack:///./app/components/tabs/dashboard/dashboard.route.js","webpack:///./app/components/tabs/dashboard/dashboard.controller.js","webpack:///./app/store/index.js","webpack:///./app/store/consts.js","webpack:///./app/store/monkeys/subscriptionData.js","webpack:///./app/store/monkeys/loaders/subscriptionData.js","webpack:///./app/config.js","webpack:///./~/baobab/dist/baobab.js","webpack:///./~/emmett/emmett.js","webpack:///./~/baobab/dist/cursor.js","webpack:///./~/baobab/dist/monkey.js","webpack:///./~/baobab/dist/type.js","webpack:///./~/baobab/dist/update.js","webpack:///./~/baobab/dist/helpers.js","webpack:///./~/baobab/dist/watcher.js","webpack:///./app/components/tabs/dashboard/locationModal.html","webpack:///./app/components/tabs/dashboard/dashboard.html","webpack:///./app/components/tabs/dashboard/dashboard.scss?421f","webpack:///./app/components/tabs/dashboard/dashboard.scss","webpack:///./~/css-loader/lib/css-base.js","webpack:///./~/style-loader/addStyles.js","webpack:///./app/components/tabs/tabs.route.js","webpack:///./app/components/tabs/tabs.html","webpack:///./app/components/tabs/tabs.scss?ec1b","webpack:///./app/components/tabs/tabs.scss","webpack:///./app/scss/index.scss?3a4b","webpack:///./app/scss/index.scss"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","_components","_components2","angular","run","$ionicPlatform","ready","window","cordova","plugins","Keyboard","hideKeyboardAccessoryBar","disableScroll","StatusBar","styleDefault","config","$stateProvider","$urlRouterProvider","otherwise","Object","defineProperty","value","_tabs","_tabs2","name","_dashboard","_dashboard2","_dashboard3","_dashboard4","state","url","views","tab-dash","template","controller","_defineProperty","key","enumerable","configurable","writable","_store","_store2","locationModalTemplate","connectSubscriptions","data","scope","$timeout","hashKey","_data","reduce","curr","next","assign","currentData","forecastData","$ionicModal","subscriptionSelector","select","get","on","e","modal","fromTemplate","animation","addLocation","show","closeModal","hide","_consts","_subscriptionData","_subscriptionData2","Baobab","locations","subscriptions","ids","localStorage","getItem","default_subscriptions","locations_data","subscribedLocations","monkey","cursors","result","map","loading","filter","r","_index","_index2","_config","_config2","length","dataSelector","fetch","apiUrl","method","body","JSON","stringify","then","response","json","forEach","d","set","_interopRequireWildcard","newObj","prototype","hasOwnProperty","_classCallCheck","instance","Constructor","TypeError","_inherits","subClass","superClass","create","constructor","setPrototypeOf","__proto__","hashPath","path","step","_type2","object","uniqid","join","_createClass","defineProperties","target","props","i","descriptor","protoProps","staticProps","_get","_x3","_x4","_x5","_again","property","receiver","Function","desc","getOwnPropertyDescriptor","undefined","getter","parent","getPrototypeOf","_emmett","_emmett2","_cursor","_cursor2","_monkey","_watcher","_watcher2","_type","_update2","_update3","_helpers","helpers","arrayFrom","coercePath","deepFreeze","getIn","makeError","deepClone","deepMerge","shallowClone","shallowMerge","DEFAULTS","autoCommit","asynchronous","immutable","lazyMonkeys","persistent","pure","validate","validationBehavior","_Emitter","initialData","opts","_this","this","arguments","array","options","_identity","_cursors","_future","_transaction","_affectedPathsIndex","_monkeys","_previousData","root","release","bootstrap","apply","_refreshMonkeys","validationError","Error","error","node","operation","_this2","clean","Monkey","type","k","concat","walk","MonkeyDefinition","monkeyInstance","definition","monkeysNode","affectedPaths","_options","behavior","emit","hash","cursor","_this3","operationType","_getIn","solvedPath","exists","monkeyPath","realOperation","test","currentNode","affectedPath","push","setTimeout","commit","clearTimeout","keys","h","split","slice","transaction","previousData","paths","mapping","kill","serialize","_len","args","Array","_key","dynamicNode","Cursor","VERSION","o1","o2","o","isPlainObject","v","isArray","RegExp","forIn","fn","symbols","l","getOwnPropertySymbols","a","__allowedOptions","once","__order","Emitter","_enabled","unbindAll","_handlers","_handlersAll","_handlersComplex","b","event","eArray","handlersList","bindingObject","order","pattern","li","off","events","n","listeners","handlers","complex","search","sort","handler","j","onces","splice","indexOf","disable","enable","version","checkPossibilityOfDynamicTraversal","makeSetter","typeChecker","INTRANSITIVE_SETTERS","fullPath","tree","update","_archive","killed","recording","undoing","_dynamicPath","dynamicPath","_monkeyPath","_writeHandler","_ref","solveUpdate","_getComparedPaths","fireUpdate","self","eventData","archive","add","_updateHandler","_event$data","bind","comparedPaths","bound","_lazyBind","before","additionalPaths","relatedPaths","primitive","isRoot","isLeaf","last","isNaN","up","list","item","_get2","monkeys","dropComputedData","projection","maxRecords","Infinity","Archive","steps","record","back","clear","Symbol","iterator","done","unset","pop","shift","splicer","monkeyType","monkeyDefinition","offset","hasDynamicPaths","some","pathInTree","relative","solveRelativePath","acc","depPaths","writeListener","concerned","recursiveListener","_ref2","_ref2$data","recursive","isRecursive","accumulatedPaths","relatedMonkey","deps","project","lazyGetter","def","cache","alreadyComputed","isLazyGetter","mutableLeaf","monkeyListener","anyOf","allowed","t","Date","Map","Set","string","number","ALLOWED_FOR_PATH","every","subpath","propertyKey","watcherMapping","VALID_OPERATIONS","_toConsumableArray","arr","arr2","from","err","expectedTarget","_operation$options","operationOptions","dummy","dummyPath","currentPath","s","unshift","freeze","global","index","newArray","culprit","decorator","cloneRegexp","re","source","flags","multiline","ignoreCase","sticky","unicode","cloner","deep","ArrayBuffer","getTime","compare","description","ok","freezer","isFrozen","NOT_FOUND_OBJECT","idx","message","merger","objects","base","to","startIndex","nb","Math","max","_len2","elements","_key2","noop","size","records","isFreezeSupported","_x","_x2","Watcher","refresh","watchedPaths","getWatchedPaths","rawPaths","cp","content","locals","toString","mediaQuery","alreadyImportedModules","addStylesToDom","styles","domStyle","stylesInDom","refs","parts","addStyle","listToStyles","newStyles","css","media","sourceMap","part","insertStyleElement","styleElement","head","getHeadElement","lastStyleElementInsertedAtTop","styleElementsInsertedAtTop","insertAt","nextSibling","insertBefore","appendChild","firstChild","removeStyleElement","parentNode","removeChild","createStyleElement","document","createElement","createLinkElement","linkElement","rel","remove","singleton","styleIndex","singletonCounter","singletonElement","applyToSingletonTag","URL","createObjectURL","revokeObjectURL","Blob","btoa","updateLink","href","applyToTag","styleSheet","cssText","replaceText","cssNode","createTextNode","childNodes","setAttribute","unescape","encodeURIComponent","blob","oldSrc","memoize","memo","isOldIE","navigator","userAgent","toLowerCase","getElementsByTagName","newList","mayRemove","textStore","replacement","Boolean","abstract"],"mappings":"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","file":"bundle.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _components = __webpack_require__(1);\n\t\n\tvar _components2 = _interopRequireDefault(_components);\n\t\n\t__webpack_require__(29);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tangular.module('app', ['ionic', _components2.default]).run(function ($ionicPlatform) {\n\t    $ionicPlatform.ready(function () {\n\t        // Hide the accessory bar by default (remove this to show the accessory bar above the keyboard\n\t        // for form inputs)\n\t        if (window.cordova && window.cordova.plugins && window.cordova.plugins.Keyboard) {\n\t            cordova.plugins.Keyboard.hideKeyboardAccessoryBar(true);\n\t            cordova.plugins.Keyboard.disableScroll(true);\n\t        }\n\t        if (window.StatusBar) {\n\t            // org.apache.cordova.statusbar required\n\t            StatusBar.styleDefault();\n\t        }\n\t    });\n\t}).config(function ($stateProvider, $urlRouterProvider) {\n\t    $urlRouterProvider.otherwise('/tab/dash');\n\t});\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _tabs = __webpack_require__(2);\n\t\n\tvar _tabs2 = _interopRequireDefault(_tabs);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = angular.module('app.components', [_tabs2.default]).name;\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _dashboard = __webpack_require__(3);\n\t\n\tvar _dashboard2 = _interopRequireDefault(_dashboard);\n\t\n\tvar _tabs = __webpack_require__(25);\n\t\n\tvar _tabs2 = _interopRequireDefault(_tabs);\n\t\n\t__webpack_require__(27);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = angular.module('app.components.tabs', [_dashboard2.default]).config(_tabs2.default).name;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _dashboard = __webpack_require__(4);\n\t\n\tvar _dashboard2 = _interopRequireDefault(_dashboard);\n\t\n\t__webpack_require__(21);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = angular.module('app.components.tabs.dashboard', []).config(_dashboard2.default).name;\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _dashboard = __webpack_require__(5);\n\t\n\tvar _dashboard2 = _interopRequireDefault(_dashboard);\n\t\n\tvar _dashboard3 = __webpack_require__(20);\n\t\n\tvar _dashboard4 = _interopRequireDefault(_dashboard3);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = function ($stateProvider, $urlRouterProvider) {\n\t    $stateProvider.state('tab.dash', {\n\t        url: '/dash',\n\t        views: {\n\t            'tab-dash': {\n\t                template: _dashboard4.default,\n\t                controller: _dashboard2.default\n\t            }\n\t        }\n\t    });\n\t};\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _store = __webpack_require__(6);\n\t\n\tvar _store2 = _interopRequireDefault(_store);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\t\n\tvar locationModalTemplate = __webpack_require__(19);\n\tvar connectSubscriptions = function connectSubscriptions(data, scope, $timeout) {\n\t    var hashKey = 0;\n\t    $timeout(function () {\n\t        var _data = data.reduce(function (curr, next) {\n\t            return Object.assign(curr, _defineProperty({}, hashKey++, next));\n\t        }, {});\n\t        scope.currentData = scope.forecastData = _data;\n\t    });\n\t};\n\t\n\texports.default = ['$scope', '$timeout', '$ionicModal', function (scope, $timeout, $ionicModal) {\n\t    var subscriptionSelector = _store2.default.select('subscriptions', 'subscribedLocations');\n\t    connectSubscriptions(subscriptionSelector.get(), scope, $timeout);\n\t    subscriptionSelector.on('update', function (e) {\n\t        connectSubscriptions(e.data.currentData, scope, $timeout);\n\t    });\n\t\n\t    scope.modal = $ionicModal.fromTemplate(locationModalTemplate, {\n\t        scope: scope,\n\t        animation: 'slide-in-up'\n\t    });\n\t\n\t    scope.addLocation = function () {\n\t        scope.modal.show();\n\t    };\n\t\n\t    scope.closeModal = function () {\n\t        scope.modal.hide();\n\t    };\n\t}];\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _consts = __webpack_require__(7);\n\t\n\tvar _subscriptionData = __webpack_require__(8);\n\t\n\tvar _subscriptionData2 = _interopRequireDefault(_subscriptionData);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar Baobab = __webpack_require__(11);\n\t\n\texports.default = new Baobab({\n\t    locations: {},\n\t    subscriptions: {\n\t        ids: window.localStorage.getItem(\"subscriptions\") || _consts.default_subscriptions,\n\t        locations_data: [],\n\t        subscribedLocations: _subscriptionData2.default\n\t    }\n\t});\n\n/***/ },\n/* 7 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\tvar default_subscriptions = exports.default_subscriptions = [1, 2];\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _subscriptionData = __webpack_require__(9);\n\t\n\tvar _subscriptionData2 = _interopRequireDefault(_subscriptionData);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar Baobab = __webpack_require__(11);\n\tvar monkey = Baobab.monkey;\n\texports.default = monkey({\n\t    cursors: {\n\t        ids: ['subscriptions', 'ids'],\n\t        locations: ['subscriptions', 'locations_data']\n\t    },\n\t    get: function get(state) {\n\t        var result = state.ids.map(function (id) {\n\t            debugger;\n\t            var data = state.locations_data[id];\n\t            return data || { id: id, loading: true };\n\t        });\n\t        (0, _subscriptionData2.default)(result.filter(function (r) {\n\t            return r.loading;\n\t        }));\n\t        return result;\n\t    }\n\t});\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _index = __webpack_require__(6);\n\t\n\tvar _index2 = _interopRequireDefault(_index);\n\t\n\tvar _config = __webpack_require__(10);\n\t\n\tvar _config2 = _interopRequireDefault(_config);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = function (ids) {\n\t    if (ids.length == 0) return null;\n\t    var dataSelector = _index2.default.select('subscriptions', 'locations_data');\n\t    fetch(_config2.default.apiUrl + '/getSubscriptions', {\n\t        method: 'POST',\n\t        body: JSON.stringify({ ids: ids })\n\t    }).then(function (response) {\n\t        return response.json();\n\t    }).then(function (data) {\n\t        data.forEach(function (d) {\n\t            dataSelector.set(d.id, d);\n\t        });\n\t    });\n\t};\n\n/***/ },\n/* 10 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.default = {\n\t    apiUrl: 'http://some.url.to.api'\n\t};\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Baobab Data Structure\n\t * ======================\n\t *\n\t * A handy data tree with cursors.\n\t */\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\t\n\tvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\t\n\tvar _get = function get(_x3, _x4, _x5) { var _again = true; _function: while (_again) { var object = _x3, property = _x4, receiver = _x5; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x3 = parent; _x4 = property; _x5 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar _emmett = __webpack_require__(12);\n\t\n\tvar _emmett2 = _interopRequireDefault(_emmett);\n\t\n\tvar _cursor = __webpack_require__(13);\n\t\n\tvar _cursor2 = _interopRequireDefault(_cursor);\n\t\n\tvar _monkey = __webpack_require__(14);\n\t\n\tvar _watcher = __webpack_require__(18);\n\t\n\tvar _watcher2 = _interopRequireDefault(_watcher);\n\t\n\tvar _type = __webpack_require__(15);\n\t\n\tvar _type2 = _interopRequireDefault(_type);\n\t\n\tvar _update2 = __webpack_require__(16);\n\t\n\tvar _update3 = _interopRequireDefault(_update2);\n\t\n\tvar _helpers = __webpack_require__(17);\n\t\n\tvar helpers = _interopRequireWildcard(_helpers);\n\t\n\tvar arrayFrom = helpers.arrayFrom;\n\tvar coercePath = helpers.coercePath;\n\tvar deepFreeze = helpers.deepFreeze;\n\tvar getIn = helpers.getIn;\n\tvar makeError = helpers.makeError;\n\tvar deepClone = helpers.deepClone;\n\tvar deepMerge = helpers.deepMerge;\n\tvar shallowClone = helpers.shallowClone;\n\tvar shallowMerge = helpers.shallowMerge;\n\tvar uniqid = helpers.uniqid;\n\t\n\t/**\n\t * Baobab defaults\n\t */\n\tvar DEFAULTS = {\n\t\n\t  // Should the tree handle its transactions on its own?\n\t  autoCommit: true,\n\t\n\t  // Should the transactions be handled asynchronously?\n\t  asynchronous: true,\n\t\n\t  // Should the tree's data be immutable?\n\t  immutable: true,\n\t\n\t  // Should the monkeys be lazy?\n\t  lazyMonkeys: true,\n\t\n\t  // Should the tree be persistent?\n\t  persistent: true,\n\t\n\t  // Should the tree's update be pure?\n\t  pure: true,\n\t\n\t  // Validation specifications\n\t  validate: null,\n\t\n\t  // Validation behavior 'rollback' or 'notify'\n\t  validationBehavior: 'rollback'\n\t};\n\t\n\t/**\n\t * Function returning a string hash from a non-dynamic path expressed as an\n\t * array.\n\t *\n\t * @param  {array}  path - The path to hash.\n\t * @return {string} string - The resultant hash.\n\t */\n\tfunction hashPath(path) {\n\t  return '' + path.map(function (step) {\n\t    if (_type2['default']['function'](step) || _type2['default'].object(step)) return '#' + uniqid() + '#';\n\t\n\t    return step;\n\t  }).join('');\n\t}\n\t\n\t/**\n\t * Baobab class\n\t *\n\t * @constructor\n\t * @param {object|array} [initialData={}]    - Initial data passed to the tree.\n\t * @param {object}       [opts]              - Optional options.\n\t * @param {boolean}      [opts.autoCommit]   - Should the tree auto-commit?\n\t * @param {boolean}      [opts.asynchronous] - Should the tree's transactions\n\t *                                             handled asynchronously?\n\t * @param {boolean}      [opts.immutable]    - Should the tree be immutable?\n\t * @param {boolean}      [opts.persistent]   - Should the tree be persistent?\n\t * @param {boolean}      [opts.pure]         - Should the tree be pure?\n\t * @param {function}     [opts.validate]     - Validation function.\n\t * @param {string}       [opts.validationBehaviour] - \"rollback\" or \"notify\".\n\t */\n\t\n\tvar Baobab = (function (_Emitter) {\n\t  _inherits(Baobab, _Emitter);\n\t\n\t  function Baobab(initialData, opts) {\n\t    var _this = this;\n\t\n\t    _classCallCheck(this, Baobab);\n\t\n\t    _get(Object.getPrototypeOf(Baobab.prototype), 'constructor', this).call(this);\n\t\n\t    // Setting initialData to an empty object if no data is provided by use\n\t    if (arguments.length < 1) initialData = {};\n\t\n\t    // Checking whether given initial data is valid\n\t    if (!_type2['default'].object(initialData) && !_type2['default'].array(initialData)) throw makeError('Baobab: invalid data.', { data: initialData });\n\t\n\t    // Merging given options with defaults\n\t    this.options = shallowMerge({}, DEFAULTS, opts);\n\t\n\t    // Disabling immutability & persistence if persistence if disabled\n\t    if (!this.options.persistent) {\n\t      this.options.immutable = false;\n\t      this.options.pure = false;\n\t    }\n\t\n\t    // Privates\n\t    this._identity = '[object Baobab]';\n\t    this._cursors = {};\n\t    this._future = null;\n\t    this._transaction = [];\n\t    this._affectedPathsIndex = {};\n\t    this._monkeys = {};\n\t    this._previousData = null;\n\t    this._data = initialData;\n\t\n\t    // Properties\n\t    this.root = new _cursor2['default'](this, [], '');\n\t    delete this.root.release;\n\t\n\t    // Does the user want an immutable tree?\n\t    if (this.options.immutable) deepFreeze(this._data);\n\t\n\t    // Bootstrapping root cursor's getters and setters\n\t    var bootstrap = function bootstrap(name) {\n\t      _this[name] = function () {\n\t        var r = this.root[name].apply(this.root, arguments);\n\t        return r instanceof _cursor2['default'] ? this : r;\n\t      };\n\t    };\n\t\n\t    ['apply', 'clone', 'concat', 'deepClone', 'deepMerge', 'exists', 'get', 'push', 'merge', 'pop', 'project', 'serialize', 'set', 'shift', 'splice', 'unset', 'unshift'].forEach(bootstrap);\n\t\n\t    // Registering the initial monkeys\n\t    this._refreshMonkeys();\n\t\n\t    // Initial validation\n\t    var validationError = this.validate();\n\t\n\t    if (validationError) throw Error('Baobab: invalid data.', { error: validationError });\n\t  }\n\t\n\t  /**\n\t   * Monkey helper.\n\t   */\n\t\n\t  /**\n\t   * Internal method used to refresh the tree's monkey register on every\n\t   * update.\n\t   * Note 1) For the time being, placing monkeys beneath array nodes is not\n\t   * allowed for performance reasons.\n\t   *\n\t   * @param  {mixed}   node      - The starting node.\n\t   * @param  {array}   path      - The starting node's path.\n\t   * @param  {string}  operation - The operation that lead to a refreshment.\n\t   * @return {Baobab}            - The tree instance for chaining purposes.\n\t   */\n\t\n\t  _createClass(Baobab, [{\n\t    key: '_refreshMonkeys',\n\t    value: function _refreshMonkeys(node, path, operation) {\n\t      var _this2 = this;\n\t\n\t      var clean = function clean(data) {\n\t        var p = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];\n\t\n\t        if (data instanceof _monkey.Monkey) {\n\t          data.release();\n\t          (0, _update3['default'])(_this2._monkeys, p, { type: 'unset' }, {\n\t            immutable: false,\n\t            persistent: false,\n\t            pure: false\n\t          });\n\t\n\t          return;\n\t        }\n\t\n\t        if (_type2['default'].object(data)) {\n\t          for (var k in data) {\n\t            clean(data[k], p.concat(k));\n\t          }\n\t        }\n\t      };\n\t\n\t      var walk = function walk(data) {\n\t        var p = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];\n\t\n\t        // Should we sit a monkey in the tree?\n\t        if (data instanceof _monkey.MonkeyDefinition || data instanceof _monkey.Monkey) {\n\t          var monkeyInstance = new _monkey.Monkey(_this2, p, data instanceof _monkey.Monkey ? data.definition : data);\n\t\n\t          (0, _update3['default'])(_this2._monkeys, p, { type: 'set', value: monkeyInstance }, {\n\t            immutable: false,\n\t            persistent: false,\n\t            pure: false\n\t          });\n\t\n\t          return;\n\t        }\n\t\n\t        // Object iteration\n\t        if (_type2['default'].object(data)) {\n\t          for (var k in data) {\n\t            walk(data[k], p.concat(k));\n\t          }\n\t        }\n\t      };\n\t\n\t      // Walking the whole tree\n\t      if (!arguments.length) {\n\t        walk(this._data);\n\t      } else {\n\t        var monkeysNode = getIn(this._monkeys, path).data;\n\t\n\t        // Is this required that we clean some already existing monkeys?\n\t        if (monkeysNode) clean(monkeysNode, path);\n\t\n\t        // Let's walk the tree only from the updated point\n\t        if (operation !== 'unset') {\n\t          walk(node, path);\n\t        }\n\t      }\n\t\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Method used to validate the tree's data.\n\t     *\n\t     * @return {boolean} - Is the tree valid?\n\t     */\n\t  }, {\n\t    key: 'validate',\n\t    value: function validate(affectedPaths) {\n\t      var _options = this.options;\n\t      var validate = _options.validate;\n\t      var behavior = _options.validationBehavior;\n\t\n\t      if (typeof validate !== 'function') return null;\n\t\n\t      var error = validate.call(this, this._previousData, this._data, affectedPaths || [[]]);\n\t\n\t      if (error instanceof Error) {\n\t\n\t        if (behavior === 'rollback') {\n\t          this._data = this._previousData;\n\t          this._affectedPathsIndex = {};\n\t          this._transaction = [];\n\t          this._previousData = this._data;\n\t        }\n\t\n\t        this.emit('invalid', { error: error });\n\t\n\t        return error;\n\t      }\n\t\n\t      return null;\n\t    }\n\t\n\t    /**\n\t     * Method used to select data within the tree by creating a cursor. Cursors\n\t     * are kept as singletons by the tree for performance and hygiene reasons.\n\t     *\n\t     * Arity (1):\n\t     * @param {path}    path - Path to select in the tree.\n\t     *\n\t     * Arity (*):\n\t     * @param {...step} path - Path to select in the tree.\n\t     *\n\t     * @return {Cursor}      - The resultant cursor.\n\t     */\n\t  }, {\n\t    key: 'select',\n\t    value: function select(path) {\n\t\n\t      // If no path is given, we simply return the root\n\t      path = path || [];\n\t\n\t      // Variadic\n\t      if (arguments.length > 1) path = arrayFrom(arguments);\n\t\n\t      // Checking that given path is valid\n\t      if (!_type2['default'].path(path)) throw makeError('Baobab.select: invalid path.', { path: path });\n\t\n\t      // Casting to array\n\t      path = [].concat(path);\n\t\n\t      // Computing hash (done here because it would be too late to do it in the\n\t      // cursor's constructor since we need to hit the cursors' index first).\n\t      var hash = hashPath(path);\n\t\n\t      // Creating a new cursor or returning the already existing one for the\n\t      // requested path.\n\t      var cursor = this._cursors[hash];\n\t\n\t      if (!cursor) {\n\t        cursor = new _cursor2['default'](this, path, hash);\n\t        this._cursors[hash] = cursor;\n\t      }\n\t\n\t      // Emitting an event to notify that a part of the tree was selected\n\t      this.emit('select', { path: path, cursor: cursor });\n\t      return cursor;\n\t    }\n\t\n\t    /**\n\t     * Method used to update the tree. Updates are simply expressed by a path,\n\t     * dynamic or not, and an operation.\n\t     *\n\t     * This is where path solving should happen and not in the cursor.\n\t     *\n\t     * @param  {path}   path      - The path where we'll apply the operation.\n\t     * @param  {object} operation - The operation to apply.\n\t     * @return {mixed} - Return the result of the update.\n\t     */\n\t  }, {\n\t    key: 'update',\n\t    value: function update(path, operation) {\n\t      var _this3 = this;\n\t\n\t      // Coercing path\n\t      path = coercePath(path);\n\t\n\t      if (!_type2['default'].operationType(operation.type)) throw makeError('Baobab.update: unknown operation type \"' + operation.type + '\".', { operation: operation });\n\t\n\t      // Solving the given path\n\t\n\t      var _getIn = getIn(this._data, path);\n\t\n\t      var solvedPath = _getIn.solvedPath;\n\t      var exists = _getIn.exists;\n\t\n\t      // If we couldn't solve the path, we throw\n\t      if (!solvedPath) throw makeError('Baobab.update: could not solve the given path.', {\n\t        path: solvedPath\n\t      });\n\t\n\t      // Read-only path?\n\t      var monkeyPath = _type2['default'].monkeyPath(this._monkeys, solvedPath);\n\t      if (monkeyPath && solvedPath.length > monkeyPath.length) throw makeError('Baobab.update: attempting to update a read-only path.', {\n\t        path: solvedPath\n\t      });\n\t\n\t      // We don't unset irrelevant paths\n\t      if (operation.type === 'unset' && !exists) return;\n\t\n\t      // If we merge data, we need to acknowledge monkeys\n\t      var realOperation = operation;\n\t      if (/merge/i.test(operation.type)) {\n\t        var monkeysNode = getIn(this._monkeys, solvedPath).data;\n\t\n\t        if (_type2['default'].object(monkeysNode)) {\n\t\n\t          // Cloning the operation not to create weird behavior for the user\n\t          realOperation = shallowClone(realOperation);\n\t\n\t          // Fetching the existing node in the current data\n\t          var currentNode = getIn(this._data, solvedPath).data;\n\t\n\t          if (/deep/i.test(realOperation.type)) realOperation.value = deepMerge({}, deepMerge({}, currentNode, deepClone(monkeysNode)), realOperation.value);else realOperation.value = shallowMerge({}, deepMerge({}, currentNode, deepClone(monkeysNode)), realOperation.value);\n\t        }\n\t      }\n\t\n\t      // Stashing previous data if this is the frame's first update\n\t      if (!this._transaction.length) this._previousData = this._data;\n\t\n\t      // Applying the operation\n\t      var result = (0, _update3['default'])(this._data, solvedPath, realOperation, this.options);\n\t\n\t      var data = result.data;\n\t      var node = result.node;\n\t\n\t      // If because of purity, the update was moot, we stop here\n\t      if (!('data' in result)) return node;\n\t\n\t      // If the operation is push, the affected path is slightly different\n\t      var affectedPath = solvedPath.concat(operation.type === 'push' ? node.length - 1 : []);\n\t\n\t      var hash = hashPath(affectedPath);\n\t\n\t      // Updating data and transaction\n\t      this._data = data;\n\t      this._affectedPathsIndex[hash] = true;\n\t      this._transaction.push(shallowMerge({}, operation, { path: affectedPath }));\n\t\n\t      // Updating the monkeys\n\t      this._refreshMonkeys(node, solvedPath, operation.type);\n\t\n\t      // Emitting a `write` event\n\t      this.emit('write', { path: affectedPath });\n\t\n\t      // Should we let the user commit?\n\t      if (!this.options.autoCommit) return node;\n\t\n\t      // Should we update asynchronously?\n\t      if (!this.options.asynchronous) {\n\t        this.commit();\n\t        return node;\n\t      }\n\t\n\t      // Updating asynchronously\n\t      if (!this._future) this._future = setTimeout(function () {\n\t        return _this3.commit();\n\t      }, 0);\n\t\n\t      // Finally returning the affected node\n\t      return node;\n\t    }\n\t\n\t    /**\n\t     * Method committing the updates of the tree and firing the tree's events.\n\t     *\n\t     * @return {Baobab} - The tree instance for chaining purposes.\n\t     */\n\t  }, {\n\t    key: 'commit',\n\t    value: function commit() {\n\t\n\t      // Do not fire update if the transaction is empty\n\t      if (!this._transaction.length) return this;\n\t\n\t      // Clearing timeout if one was defined\n\t      if (this._future) this._future = clearTimeout(this._future);\n\t\n\t      var affectedPaths = Object.keys(this._affectedPathsIndex).map(function (h) {\n\t        return h !== '' ? h.split('').slice(1) : [];\n\t      });\n\t\n\t      // Is the tree still valid?\n\t      var validationError = this.validate(affectedPaths);\n\t\n\t      if (validationError) return this;\n\t\n\t      // Caching to keep original references before we change them\n\t      var transaction = this._transaction,\n\t          previousData = this._previousData;\n\t\n\t      this._affectedPathsIndex = {};\n\t      this._transaction = [];\n\t      this._previousData = this._data;\n\t\n\t      // Emitting update event\n\t      this.emit('update', {\n\t        paths: affectedPaths,\n\t        currentData: this._data,\n\t        transaction: transaction,\n\t        previousData: previousData\n\t      });\n\t\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Method returning a monkey at the given path or else `null`.\n\t     *\n\t     * @param  {path}        path - Path of the monkey to retrieve.\n\t     * @return {Monkey|null}      - The Monkey instance of `null`.\n\t     */\n\t  }, {\n\t    key: 'getMonkey',\n\t    value: function getMonkey(path) {\n\t      path = coercePath(path);\n\t\n\t      var monkey = getIn(this._monkeys, [].concat(path)).data;\n\t\n\t      if (monkey instanceof _monkey.Monkey) return monkey;\n\t\n\t      return null;\n\t    }\n\t\n\t    /**\n\t     * Method used to watch a collection of paths within the tree. Very useful\n\t     * to bind UI components and such to the tree.\n\t     *\n\t     * @param  {object} mapping - Mapping of paths to listen.\n\t     * @return {Cursor}         - The created watcher.\n\t     */\n\t  }, {\n\t    key: 'watch',\n\t    value: function watch(mapping) {\n\t      return new _watcher2['default'](this, mapping);\n\t    }\n\t\n\t    /**\n\t     * Method releasing the tree and its attached data from memory.\n\t     */\n\t  }, {\n\t    key: 'release',\n\t    value: function release() {\n\t      var k = undefined;\n\t\n\t      this.emit('release');\n\t\n\t      delete this.root;\n\t\n\t      delete this._data;\n\t      delete this._previousData;\n\t      delete this._transaction;\n\t      delete this._affectedPathsIndex;\n\t      delete this._monkeys;\n\t\n\t      // Releasing cursors\n\t      for (k in this._cursors) this._cursors[k].release();\n\t      delete this._cursors;\n\t\n\t      // Killing event emitter\n\t      this.kill();\n\t    }\n\t\n\t    /**\n\t     * Overriding the `toJSON` method for convenient use with JSON.stringify.\n\t     *\n\t     * @return {mixed} - Data at cursor.\n\t     */\n\t  }, {\n\t    key: 'toJSON',\n\t    value: function toJSON() {\n\t      return this.serialize();\n\t    }\n\t\n\t    /**\n\t     * Overriding the `toString` method for debugging purposes.\n\t     *\n\t     * @return {string} - The baobab's identity.\n\t     */\n\t  }, {\n\t    key: 'toString',\n\t    value: function toString() {\n\t      return this._identity;\n\t    }\n\t  }]);\n\t\n\t  return Baobab;\n\t})(_emmett2['default']);\n\t\n\texports['default'] = Baobab;\n\tBaobab.monkey = function () {\n\t  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t    args[_key] = arguments[_key];\n\t  }\n\t\n\t  if (!args.length) throw new Error('Baobab.monkey: missing definition.');\n\t\n\t  if (args.length === 1 && typeof args[0] !== 'function') return new _monkey.MonkeyDefinition(args[0]);\n\t\n\t  return new _monkey.MonkeyDefinition(args);\n\t};\n\tBaobab.dynamicNode = Baobab.monkey;\n\t\n\t/**\n\t * Exposing some internals for convenience\n\t */\n\tBaobab.Cursor = _cursor2['default'];\n\tBaobab.MonkeyDefinition = _monkey.MonkeyDefinition;\n\tBaobab.Monkey = _monkey.Monkey;\n\tBaobab.type = _type2['default'];\n\tBaobab.helpers = helpers;\n\t\n\t/**\n\t * Version\n\t */\n\tBaobab.VERSION = '2.3.2';\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t(function() {\n\t  'use strict';\n\t\n\t  /**\n\t   * Here is the list of every allowed parameter when using Emitter#on:\n\t   * @type {Object}\n\t   */\n\t  var __allowedOptions = {\n\t    once: 'boolean',\n\t    scope: 'object'\n\t  };\n\t\n\t  /**\n\t   * Incremental id used to order event handlers.\n\t   */\n\t  var __order = 0;\n\t\n\t  /**\n\t   * A simple helper to shallowly merge two objects. The second one will \"win\"\n\t   * over the first one.\n\t   *\n\t   * @param  {object}  o1 First target object.\n\t   * @param  {object}  o2 Second target object.\n\t   * @return {object}     Returns the merged object.\n\t   */\n\t  function shallowMerge(o1, o2) {\n\t    var o = {},\n\t        k;\n\t\n\t    for (k in o1) o[k] = o1[k];\n\t    for (k in o2) o[k] = o2[k];\n\t\n\t    return o;\n\t  }\n\t\n\t  /**\n\t   * Is the given variable a plain JavaScript object?\n\t   *\n\t   * @param  {mixed}  v   Target.\n\t   * @return {boolean}    The boolean result.\n\t   */\n\t  function isPlainObject(v) {\n\t    return v &&\n\t           typeof v === 'object' &&\n\t           !Array.isArray(v) &&\n\t           !(v instanceof Function) &&\n\t           !(v instanceof RegExp);\n\t  }\n\t\n\t  /**\n\t   * Iterate over an object that may have ES6 Symbols.\n\t   *\n\t   * @param  {object}   object  Object on which to iterate.\n\t   * @param  {function} fn      Iterator function.\n\t   * @param  {object}   [scope] Optional scope.\n\t   */\n\t  function forIn(object, fn, scope) {\n\t    var symbols,\n\t        k,\n\t        i,\n\t        l;\n\t\n\t    for (k in object)\n\t      fn.call(scope || null, k, object[k]);\n\t\n\t    if (Object.getOwnPropertySymbols) {\n\t      symbols = Object.getOwnPropertySymbols(object);\n\t\n\t      for (i = 0, l = symbols.length; i < l; i++)\n\t        fn.call(scope || null, symbols[i], object[symbols[i]]);\n\t    }\n\t  }\n\t\n\t  /**\n\t   * The emitter's constructor. It initializes the handlers-per-events store and\n\t   * the global handlers store.\n\t   *\n\t   * Emitters are useful for non-DOM events communication. Read its methods\n\t   * documentation for more information about how it works.\n\t   *\n\t   * @return {Emitter}         The fresh new instance.\n\t   */\n\t  var Emitter = function() {\n\t    this._enabled = true;\n\t\n\t    // Dirty trick that will set the necessary properties to the emitter\n\t    this.unbindAll();\n\t  };\n\t\n\t  /**\n\t   * This method unbinds every handlers attached to every or any events. So,\n\t   * these functions will no more be executed when the related events are\n\t   * emitted. If the functions were not bound to the events, nothing will\n\t   * happen, and no error will be thrown.\n\t   *\n\t   * Usage:\n\t   * ******\n\t   * > myEmitter.unbindAll();\n\t   *\n\t   * @return {Emitter}      Returns this.\n\t   */\n\t  Emitter.prototype.unbindAll = function() {\n\t\n\t    this._handlers = {};\n\t    this._handlersAll = [];\n\t    this._handlersComplex = [];\n\t\n\t    return this;\n\t  };\n\t\n\t\n\t  /**\n\t   * This method binds one or more functions to the emitter, handled to one or a\n\t   * suite of events. So, these functions will be executed anytime one related\n\t   * event is emitted.\n\t   *\n\t   * It is also possible to bind a function to any emitted event by not\n\t   * specifying any event to bind the function to.\n\t   *\n\t   * Recognized options:\n\t   * *******************\n\t   *  - {?boolean} once   If true, the handlers will be unbound after the first\n\t   *                      execution. Default value: false.\n\t   *  - {?object}  scope  If a scope is given, then the listeners will be called\n\t   *                      with this scope as \"this\".\n\t   *\n\t   * Variant 1:\n\t   * **********\n\t   * > myEmitter.on('myEvent', function(e) { console.log(e); });\n\t   * > // Or:\n\t   * > myEmitter.on('myEvent', function(e) { console.log(e); }, { once: true });\n\t   *\n\t   * @param  {string}   event   The event to listen to.\n\t   * @param  {function} handler The function to bind.\n\t   * @param  {?object}  options Eventually some options.\n\t   * @return {Emitter}          Returns this.\n\t   *\n\t   * Variant 2:\n\t   * **********\n\t   * > myEmitter.on(\n\t   * >   ['myEvent1', 'myEvent2'],\n\t   * >   function(e) { console.log(e); }\n\t   * >);\n\t   * > // Or:\n\t   * > myEmitter.on(\n\t   * >   ['myEvent1', 'myEvent2'],\n\t   * >   function(e) { console.log(e); }\n\t   * >   { once: true }}\n\t   * >);\n\t   *\n\t   * @param  {array}    events  The events to listen to.\n\t   * @param  {function} handler The function to bind.\n\t   * @param  {?object}  options Eventually some options.\n\t   * @return {Emitter}          Returns this.\n\t   *\n\t   * Variant 3:\n\t   * **********\n\t   * > myEmitter.on({\n\t   * >   myEvent1: function(e) { console.log(e); },\n\t   * >   myEvent2: function(e) { console.log(e); }\n\t   * > });\n\t   * > // Or:\n\t   * > myEmitter.on({\n\t   * >   myEvent1: function(e) { console.log(e); },\n\t   * >   myEvent2: function(e) { console.log(e); }\n\t   * > }, { once: true });\n\t   *\n\t   * @param  {object}  bindings An object containing pairs event / function.\n\t   * @param  {?object}  options Eventually some options.\n\t   * @return {Emitter}          Returns this.\n\t   *\n\t   * Variant 4:\n\t   * **********\n\t   * > myEmitter.on(function(e) { console.log(e); });\n\t   * > // Or:\n\t   * > myEmitter.on(function(e) { console.log(e); }, { once: true});\n\t   *\n\t   * @param  {function} handler The function to bind to every events.\n\t   * @param  {?object}  options Eventually some options.\n\t   * @return {Emitter}          Returns this.\n\t   */\n\t  Emitter.prototype.on = function(a, b, c) {\n\t    var i,\n\t        l,\n\t        k,\n\t        event,\n\t        eArray,\n\t        handlersList,\n\t        bindingObject;\n\t\n\t    // Variant 3\n\t    if (isPlainObject(a)) {\n\t      forIn(a, function(name, fn) {\n\t        this.on(name, fn, b);\n\t      }, this);\n\t\n\t      return this;\n\t    }\n\t\n\t    // Variant 1, 2 and 4\n\t    if (typeof a === 'function') {\n\t      c = b;\n\t      b = a;\n\t      a = null;\n\t    }\n\t\n\t    eArray = [].concat(a);\n\t\n\t    for (i = 0, l = eArray.length; i < l; i++) {\n\t      event = eArray[i];\n\t\n\t      bindingObject = {\n\t        order: __order++,\n\t        fn: b\n\t      };\n\t\n\t      // Defining the list in which the handler should be inserted\n\t      if (typeof event === 'string' || typeof event === 'symbol') {\n\t        if (!this._handlers[event])\n\t          this._handlers[event] = [];\n\t        handlersList = this._handlers[event];\n\t        bindingObject.type = event;\n\t      }\n\t      else if (event instanceof RegExp) {\n\t        handlersList = this._handlersComplex;\n\t        bindingObject.pattern = event;\n\t      }\n\t      else if (event === null) {\n\t        handlersList = this._handlersAll;\n\t      }\n\t      else {\n\t        throw Error('Emitter.on: invalid event.');\n\t      }\n\t\n\t      // Appending needed properties\n\t      for (k in c || {})\n\t        if (__allowedOptions[k])\n\t          bindingObject[k] = c[k];\n\t\n\t      handlersList.push(bindingObject);\n\t    }\n\t\n\t    return this;\n\t  };\n\t\n\t\n\t  /**\n\t   * This method works exactly as the previous #on, but will add an options\n\t   * object if none is given, and set the option \"once\" to true.\n\t   *\n\t   * The polymorphism works exactly as with the #on method.\n\t   */\n\t  Emitter.prototype.once = function() {\n\t    var args = Array.prototype.slice.call(arguments),\n\t        li = args.length - 1;\n\t\n\t    if (isPlainObject(args[li]) && args.length > 1)\n\t      args[li] = shallowMerge(args[li], {once: true});\n\t    else\n\t      args.push({once: true});\n\t\n\t    return this.on.apply(this, args);\n\t  };\n\t\n\t\n\t  /**\n\t   * This method unbinds one or more functions from events of the emitter. So,\n\t   * these functions will no more be executed when the related events are\n\t   * emitted. If the functions were not bound to the events, nothing will\n\t   * happen, and no error will be thrown.\n\t   *\n\t   * Variant 1:\n\t   * **********\n\t   * > myEmitter.off('myEvent', myHandler);\n\t   *\n\t   * @param  {string}   event   The event to unbind the handler from.\n\t   * @param  {function} handler The function to unbind.\n\t   * @return {Emitter}          Returns this.\n\t   *\n\t   * Variant 2:\n\t   * **********\n\t   * > myEmitter.off(['myEvent1', 'myEvent2'], myHandler);\n\t   *\n\t   * @param  {array}    events  The events to unbind the handler from.\n\t   * @param  {function} handler The function to unbind.\n\t   * @return {Emitter}          Returns this.\n\t   *\n\t   * Variant 3:\n\t   * **********\n\t   * > myEmitter.off({\n\t   * >   myEvent1: myHandler1,\n\t   * >   myEvent2: myHandler2\n\t   * > });\n\t   *\n\t   * @param  {object} bindings An object containing pairs event / function.\n\t   * @return {Emitter}         Returns this.\n\t   *\n\t   * Variant 4:\n\t   * **********\n\t   * > myEmitter.off(myHandler);\n\t   *\n\t   * @param  {function} handler The function to unbind from every events.\n\t   * @return {Emitter}          Returns this.\n\t   *\n\t   * Variant 5:\n\t   * **********\n\t   * > myEmitter.off(event);\n\t   *\n\t   * @param  {string} event     The event we should unbind.\n\t   * @return {Emitter}          Returns this.\n\t   */\n\t  function filter(target, fn) {\n\t    target = target || [];\n\t\n\t    var a = [],\n\t        l,\n\t        i;\n\t\n\t    for (i = 0, l = target.length; i < l; i++)\n\t      if (target[i].fn !== fn)\n\t        a.push(target[i]);\n\t\n\t    return a;\n\t  }\n\t\n\t  Emitter.prototype.off = function(events, fn) {\n\t    var i,\n\t        n,\n\t        k,\n\t        event;\n\t\n\t    // Variant 4:\n\t    if (arguments.length === 1 && typeof events === 'function') {\n\t      fn = arguments[0];\n\t\n\t      // Handlers bound to events:\n\t      for (k in this._handlers) {\n\t        this._handlers[k] = filter(this._handlers[k], fn);\n\t\n\t        if (this._handlers[k].length === 0)\n\t          delete this._handlers[k];\n\t      }\n\t\n\t      // Generic Handlers\n\t      this._handlersAll = filter(this._handlersAll, fn);\n\t\n\t      // Complex handlers\n\t      this._handlersComplex = filter(this._handlersComplex, fn);\n\t    }\n\t\n\t    // Variant 5\n\t    else if (arguments.length === 1 &&\n\t             (typeof events === 'string' || typeof events === 'symbol')) {\n\t      delete this._handlers[events];\n\t    }\n\t\n\t    // Variant 1 and 2:\n\t    else if (arguments.length === 2) {\n\t      var eArray = [].concat(events);\n\t\n\t      for (i = 0, n = eArray.length; i < n; i++) {\n\t        event = eArray[i];\n\t\n\t        this._handlers[event] = filter(this._handlers[event], fn);\n\t\n\t        if ((this._handlers[event] || []).length === 0)\n\t          delete this._handlers[event];\n\t      }\n\t    }\n\t\n\t    // Variant 3\n\t    else if (isPlainObject(events)) {\n\t      forIn(events, this.off, this);\n\t    }\n\t\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * This method retrieve the listeners attached to a particular event.\n\t   *\n\t   * @param  {?string}    Name of the event.\n\t   * @return {array}      Array of handler functions.\n\t   */\n\t  Emitter.prototype.listeners = function(event) {\n\t    var handlers = this._handlersAll || [],\n\t        complex = false,\n\t        h,\n\t        i,\n\t        l;\n\t\n\t    if (!event)\n\t      throw Error('Emitter.listeners: no event provided.');\n\t\n\t    handlers = handlers.concat(this._handlers[event] || []);\n\t\n\t    for (i = 0, l = this._handlersComplex.length; i < l; i++) {\n\t      h = this._handlersComplex[i];\n\t\n\t      if (~event.search(h.pattern)) {\n\t        complex = true;\n\t        handlers.push(h);\n\t      }\n\t    }\n\t\n\t    // If we have any complex handlers, we need to sort\n\t    if (this._handlersAll.length || complex)\n\t      return handlers.sort(function(a, b) {\n\t        return a.order - b.order;\n\t      });\n\t    else\n\t      return handlers.slice(0);\n\t  };\n\t\n\t  /**\n\t   * This method emits the specified event(s), and executes every handlers bound\n\t   * to the event(s).\n\t   *\n\t   * Use cases:\n\t   * **********\n\t   * > myEmitter.emit('myEvent');\n\t   * > myEmitter.emit('myEvent', myData);\n\t   * > myEmitter.emit(['myEvent1', 'myEvent2']);\n\t   * > myEmitter.emit(['myEvent1', 'myEvent2'], myData);\n\t   * > myEmitter.emit({myEvent1: myData1, myEvent2: myData2});\n\t   *\n\t   * @param  {string|array} events The event(s) to emit.\n\t   * @param  {object?}      data   The data.\n\t   * @return {Emitter}             Returns this.\n\t   */\n\t  Emitter.prototype.emit = function(events, data) {\n\t\n\t    // Short exit if the emitter is disabled\n\t    if (!this._enabled)\n\t      return this;\n\t\n\t    // Object variant\n\t    if (isPlainObject(events)) {\n\t      forIn(events, this.emit, this);\n\t      return this;\n\t    }\n\t\n\t    var eArray = [].concat(events),\n\t        onces = [],\n\t        event,\n\t        parent,\n\t        handlers,\n\t        handler,\n\t        i,\n\t        j,\n\t        l,\n\t        m;\n\t\n\t    for (i = 0, l = eArray.length; i < l; i++) {\n\t      handlers = this.listeners(eArray[i]);\n\t\n\t      for (j = 0, m = handlers.length; j < m; j++) {\n\t        handler = handlers[j];\n\t        event = {\n\t          type: eArray[i],\n\t          target: this\n\t        };\n\t\n\t        if (arguments.length > 1)\n\t          event.data = data;\n\t\n\t        handler.fn.call('scope' in handler ? handler.scope : this, event);\n\t\n\t        if (handler.once)\n\t          onces.push(handler);\n\t      }\n\t\n\t      // Cleaning onces\n\t      for (j = onces.length - 1; j >= 0; j--) {\n\t        parent = onces[j].type ?\n\t          this._handlers[onces[j].type] :\n\t          onces[j].pattern ?\n\t            this._handlersComplex :\n\t            this._handlersAll;\n\t\n\t        parent.splice(parent.indexOf(onces[j]), 1);\n\t      }\n\t    }\n\t\n\t    return this;\n\t  };\n\t\n\t\n\t  /**\n\t   * This method will unbind all listeners and make it impossible to ever\n\t   * rebind any listener to any event.\n\t   */\n\t  Emitter.prototype.kill = function() {\n\t\n\t    this.unbindAll();\n\t    this._handlers = null;\n\t    this._handlersAll = null;\n\t    this._handlersComplex = null;\n\t    this._enabled = false;\n\t\n\t    // Nooping methods\n\t    this.unbindAll =\n\t    this.on =\n\t    this.once =\n\t    this.off =\n\t    this.emit =\n\t    this.listeners = Function.prototype;\n\t  };\n\t\n\t\n\t  /**\n\t   * This method disabled the emitter, which means its emit method will do\n\t   * nothing.\n\t   *\n\t   * @return {Emitter} Returns this.\n\t   */\n\t  Emitter.prototype.disable = function() {\n\t    this._enabled = false;\n\t\n\t    return this;\n\t  };\n\t\n\t\n\t  /**\n\t   * This method enables the emitter.\n\t   *\n\t   * @return {Emitter} Returns this.\n\t   */\n\t  Emitter.prototype.enable = function() {\n\t    this._enabled = true;\n\t\n\t    return this;\n\t  };\n\t\n\t\n\t  /**\n\t   * Version:\n\t   */\n\t  Emitter.version = '3.1.1';\n\t\n\t\n\t  // Export:\n\t  if (true) {\n\t    if (typeof module !== 'undefined' && module.exports)\n\t      exports = module.exports = Emitter;\n\t    exports.Emitter = Emitter;\n\t  } else if (typeof define === 'function' && define.amd)\n\t    define('emmett', [], function() {\n\t      return Emitter;\n\t    });\n\t  else\n\t    this.Emitter = Emitter;\n\t}).call(this);\n\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Baobab Cursors\n\t * ===============\n\t *\n\t * Cursors created by selecting some data within a Baobab tree.\n\t */\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\t\n\tvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\t\n\tvar _get = function get(_x3, _x4, _x5) { var _again = true; _function: while (_again) { var object = _x3, property = _x4, receiver = _x5; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x3 = parent; _x4 = property; _x5 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar _emmett = __webpack_require__(12);\n\t\n\tvar _emmett2 = _interopRequireDefault(_emmett);\n\t\n\tvar _monkey = __webpack_require__(14);\n\t\n\tvar _type = __webpack_require__(15);\n\t\n\tvar _type2 = _interopRequireDefault(_type);\n\t\n\tvar _helpers = __webpack_require__(17);\n\t\n\t/**\n\t * Traversal helper function for dynamic cursors. Will throw a legible error\n\t * if traversal is not possible.\n\t *\n\t * @param {string} method     - The method name, to create a correct error msg.\n\t * @param {array}  solvedPath - The cursor's solved path.\n\t */\n\tfunction checkPossibilityOfDynamicTraversal(method, solvedPath) {\n\t  if (!solvedPath) throw (0, _helpers.makeError)('Baobab.Cursor.' + method + ': ' + ('cannot use ' + method + ' on an unresolved dynamic path.'), { path: solvedPath });\n\t}\n\t\n\t/**\n\t * Cursor class\n\t *\n\t * @constructor\n\t * @param {Baobab} tree   - The cursor's root.\n\t * @param {array}  path   - The cursor's path in the tree.\n\t * @param {string} hash   - The path's hash computed ahead by the tree.\n\t */\n\t\n\tvar Cursor = (function (_Emitter) {\n\t  _inherits(Cursor, _Emitter);\n\t\n\t  function Cursor(tree, path, hash) {\n\t    var _this = this;\n\t\n\t    _classCallCheck(this, Cursor);\n\t\n\t    _get(Object.getPrototypeOf(Cursor.prototype), 'constructor', this).call(this);\n\t\n\t    // If no path were to be provided, we fallback to an empty path (root)\n\t    path = path || [];\n\t\n\t    // Privates\n\t    this._identity = '[object Cursor]';\n\t    this._archive = null;\n\t\n\t    // Properties\n\t    this.tree = tree;\n\t    this.path = path;\n\t    this.hash = hash;\n\t\n\t    // State\n\t    this.state = {\n\t      killed: false,\n\t      recording: false,\n\t      undoing: false\n\t    };\n\t\n\t    // Checking whether the given path is dynamic or not\n\t    this._dynamicPath = _type2['default'].dynamicPath(this.path);\n\t\n\t    // Checking whether the given path will meet a monkey\n\t    this._monkeyPath = _type2['default'].monkeyPath(this.tree._monkeys, this.path);\n\t\n\t    if (!this._dynamicPath) this.solvedPath = this.path;else this.solvedPath = (0, _helpers.getIn)(this.tree._data, this.path).solvedPath;\n\t\n\t    /**\n\t     * Listener bound to the tree's writes so that cursors with dynamic paths\n\t     * may update their solved path correctly.\n\t     *\n\t     * @param {object} event - The event fired by the tree.\n\t     */\n\t    this._writeHandler = function (_ref) {\n\t      var data = _ref.data;\n\t\n\t      if (_this.state.killed || !(0, _helpers.solveUpdate)([data.path], _this._getComparedPaths())) return;\n\t\n\t      _this.solvedPath = (0, _helpers.getIn)(_this.tree._data, _this.path).solvedPath;\n\t    };\n\t\n\t    /**\n\t     * Function in charge of actually trigger the cursor's updates and\n\t     * deal with the archived records.\n\t     *\n\t     * @note: probably should wrap the current solvedPath in closure to avoid\n\t     * for tricky cases where it would fail.\n\t     *\n\t     * @param {mixed} previousData - the tree's previous data.\n\t     */\n\t    var fireUpdate = function fireUpdate(previousData) {\n\t      var self = _this;\n\t\n\t      var eventData = Object.defineProperties({}, {\n\t        previousData: {\n\t          get: function get() {\n\t            return (0, _helpers.getIn)(previousData, self.solvedPath).data;\n\t          },\n\t          configurable: true,\n\t          enumerable: true\n\t        },\n\t        currentData: {\n\t          get: function get() {\n\t            return self.get();\n\t          },\n\t          configurable: true,\n\t          enumerable: true\n\t        }\n\t      });\n\t\n\t      if (_this.state.recording && !_this.state.undoing) _this.archive.add(eventData.previousData);\n\t\n\t      _this.state.undoing = false;\n\t\n\t      return _this.emit('update', eventData);\n\t    };\n\t\n\t    /**\n\t     * Listener bound to the tree's updates and determining whether the\n\t     * cursor is affected and should react accordingly.\n\t     *\n\t     * Note that this listener is lazily bound to the tree to be sure\n\t     * one wouldn't leak listeners when only creating cursors for convenience\n\t     * and not to listen to updates specifically.\n\t     *\n\t     * @param {object} event - The event fired by the tree.\n\t     */\n\t    this._updateHandler = function (event) {\n\t      if (_this.state.killed) return;\n\t\n\t      var _event$data = event.data;\n\t      var paths = _event$data.paths;\n\t      var previousData = _event$data.previousData;\n\t      var update = fireUpdate.bind(_this, previousData);\n\t      var comparedPaths = _this._getComparedPaths();\n\t\n\t      if ((0, _helpers.solveUpdate)(paths, comparedPaths)) return update();\n\t    };\n\t\n\t    // Lazy binding\n\t    var bound = false;\n\t    this._lazyBind = function () {\n\t      if (bound) return;\n\t\n\t      bound = true;\n\t\n\t      if (_this._dynamicPath) _this.tree.on('write', _this._writeHandler);\n\t\n\t      return _this.tree.on('update', _this._updateHandler);\n\t    };\n\t\n\t    // If the path is dynamic, we actually need to listen to the tree\n\t    if (this._dynamicPath) {\n\t      this._lazyBind();\n\t    } else {\n\t\n\t      // Overriding the emitter `on` and `once` methods\n\t      this.on = (0, _helpers.before)(this._lazyBind, this.on.bind(this));\n\t      this.once = (0, _helpers.before)(this._lazyBind, this.once.bind(this));\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Method used to allow iterating over cursors containing list-type data.\n\t   *\n\t   * e.g. for(let i of cursor) { ... }\n\t   *\n\t   * @returns {object} -  Each item sequentially.\n\t   */\n\t\n\t  /**\n\t   * Internal helpers\n\t   * -----------------\n\t   */\n\t\n\t  /**\n\t   * Method returning the paths of the tree watched over by the cursor and that\n\t   * should be taken into account when solving a potential update.\n\t   *\n\t   * @return {array} - Array of paths to compare with a given update.\n\t   */\n\t\n\t  _createClass(Cursor, [{\n\t    key: '_getComparedPaths',\n\t    value: function _getComparedPaths() {\n\t\n\t      // Checking whether we should keep track of some dependencies\n\t      var additionalPaths = this._monkeyPath ? (0, _helpers.getIn)(this.tree._monkeys, this._monkeyPath).data.relatedPaths() : [];\n\t\n\t      return [this.solvedPath].concat(additionalPaths);\n\t    }\n\t\n\t    /**\n\t     * Predicates\n\t     * -----------\n\t     */\n\t\n\t    /**\n\t     * Method returning whether the cursor is at root level.\n\t     *\n\t     * @return {boolean} - Is the cursor the root?\n\t     */\n\t  }, {\n\t    key: 'isRoot',\n\t    value: function isRoot() {\n\t      return !this.path.length;\n\t    }\n\t\n\t    /**\n\t     * Method returning whether the cursor is at leaf level.\n\t     *\n\t     * @return {boolean} - Is the cursor a leaf?\n\t     */\n\t  }, {\n\t    key: 'isLeaf',\n\t    value: function isLeaf() {\n\t      return _type2['default'].primitive(this._get().data);\n\t    }\n\t\n\t    /**\n\t     * Method returning whether the cursor is at branch level.\n\t     *\n\t     * @return {boolean} - Is the cursor a branch?\n\t     */\n\t  }, {\n\t    key: 'isBranch',\n\t    value: function isBranch() {\n\t      return !this.isRoot() && !this.isLeaf();\n\t    }\n\t\n\t    /**\n\t     * Traversal Methods\n\t     * ------------------\n\t     */\n\t\n\t    /**\n\t     * Method returning the root cursor.\n\t     *\n\t     * @return {Baobab} - The root cursor.\n\t     */\n\t  }, {\n\t    key: 'root',\n\t    value: function root() {\n\t      return this.tree.select();\n\t    }\n\t\n\t    /**\n\t     * Method selecting a subpath as a new cursor.\n\t     *\n\t     * Arity (1):\n\t     * @param  {path} path    - The path to select.\n\t     *\n\t     * Arity (*):\n\t     * @param  {...step} path - The path to select.\n\t     *\n\t     * @return {Cursor}       - The created cursor.\n\t     */\n\t  }, {\n\t    key: 'select',\n\t    value: function select(path) {\n\t      if (arguments.length > 1) path = (0, _helpers.arrayFrom)(arguments);\n\t\n\t      return this.tree.select(this.path.concat(path));\n\t    }\n\t\n\t    /**\n\t     * Method returning the parent node of the cursor or else `null` if the\n\t     * cursor is already at root level.\n\t     *\n\t     * @return {Baobab} - The parent cursor.\n\t     */\n\t  }, {\n\t    key: 'up',\n\t    value: function up() {\n\t      if (!this.isRoot()) return this.tree.select(this.path.slice(0, -1));\n\t\n\t      return null;\n\t    }\n\t\n\t    /**\n\t     * Method returning the child node of the cursor.\n\t     *\n\t     * @return {Baobab} - The child cursor.\n\t     */\n\t  }, {\n\t    key: 'down',\n\t    value: function down() {\n\t      checkPossibilityOfDynamicTraversal('down', this.solvedPath);\n\t\n\t      if (!(this._get().data instanceof Array)) throw Error('Baobab.Cursor.down: cannot go down on a non-list type.');\n\t\n\t      return this.tree.select(this.solvedPath.concat(0));\n\t    }\n\t\n\t    /**\n\t     * Method returning the left sibling node of the cursor if this one is\n\t     * pointing at a list. Returns `null` if this cursor is already leftmost.\n\t     *\n\t     * @return {Baobab} - The left sibling cursor.\n\t     */\n\t  }, {\n\t    key: 'left',\n\t    value: function left() {\n\t      checkPossibilityOfDynamicTraversal('left', this.solvedPath);\n\t\n\t      var last = +this.solvedPath[this.solvedPath.length - 1];\n\t\n\t      if (isNaN(last)) throw Error('Baobab.Cursor.left: cannot go left on a non-list type.');\n\t\n\t      return last ? this.tree.select(this.solvedPath.slice(0, -1).concat(last - 1)) : null;\n\t    }\n\t\n\t    /**\n\t     * Method returning the right sibling node of the cursor if this one is\n\t     * pointing at a list. Returns `null` if this cursor is already rightmost.\n\t     *\n\t     * @return {Baobab} - The right sibling cursor.\n\t     */\n\t  }, {\n\t    key: 'right',\n\t    value: function right() {\n\t      checkPossibilityOfDynamicTraversal('right', this.solvedPath);\n\t\n\t      var last = +this.solvedPath[this.solvedPath.length - 1];\n\t\n\t      if (isNaN(last)) throw Error('Baobab.Cursor.right: cannot go right on a non-list type.');\n\t\n\t      if (last + 1 === this.up()._get().data.length) return null;\n\t\n\t      return this.tree.select(this.solvedPath.slice(0, -1).concat(last + 1));\n\t    }\n\t\n\t    /**\n\t     * Method returning the leftmost sibling node of the cursor if this one is\n\t     * pointing at a list.\n\t     *\n\t     * @return {Baobab} - The leftmost sibling cursor.\n\t     */\n\t  }, {\n\t    key: 'leftmost',\n\t    value: function leftmost() {\n\t      checkPossibilityOfDynamicTraversal('leftmost', this.solvedPath);\n\t\n\t      var last = +this.solvedPath[this.solvedPath.length - 1];\n\t\n\t      if (isNaN(last)) throw Error('Baobab.Cursor.leftmost: cannot go left on a non-list type.');\n\t\n\t      return this.tree.select(this.solvedPath.slice(0, -1).concat(0));\n\t    }\n\t\n\t    /**\n\t     * Method returning the rightmost sibling node of the cursor if this one is\n\t     * pointing at a list.\n\t     *\n\t     * @return {Baobab} - The rightmost sibling cursor.\n\t     */\n\t  }, {\n\t    key: 'rightmost',\n\t    value: function rightmost() {\n\t      checkPossibilityOfDynamicTraversal('rightmost', this.solvedPath);\n\t\n\t      var last = +this.solvedPath[this.solvedPath.length - 1];\n\t\n\t      if (isNaN(last)) throw Error('Baobab.Cursor.rightmost: cannot go right on a non-list type.');\n\t\n\t      var list = this.up()._get().data;\n\t\n\t      return this.tree.select(this.solvedPath.slice(0, -1).concat(list.length - 1));\n\t    }\n\t\n\t    /**\n\t     * Method mapping the children nodes of the cursor.\n\t     *\n\t     * @param  {function} fn      - The function to map.\n\t     * @param  {object}   [scope] - An optional scope.\n\t     * @return {array}            - The resultant array.\n\t     */\n\t  }, {\n\t    key: 'map',\n\t    value: function map(fn, scope) {\n\t      checkPossibilityOfDynamicTraversal('map', this.solvedPath);\n\t\n\t      var array = this._get().data,\n\t          l = arguments.length;\n\t\n\t      if (!_type2['default'].array(array)) throw Error('baobab.Cursor.map: cannot map a non-list type.');\n\t\n\t      return array.map(function (item, i) {\n\t        return fn.call(l > 1 ? scope : this, this.select(i), i, array);\n\t      }, this);\n\t    }\n\t\n\t    /**\n\t     * Getter Methods\n\t     * ---------------\n\t     */\n\t\n\t    /**\n\t     * Internal get method. Basically contains the main body of the `get` method\n\t     * without the event emitting. This is sometimes needed not to fire useless\n\t     * events.\n\t     *\n\t     * @param  {path}   [path=[]]       - Path to get in the tree.\n\t     * @return {object} info            - The resultant information.\n\t     * @return {mixed}  info.data       - Data at path.\n\t     * @return {array}  info.solvedPath - The path solved when getting.\n\t     */\n\t  }, {\n\t    key: '_get',\n\t    value: function _get() {\n\t      var path = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];\n\t\n\t      if (!_type2['default'].path(path)) throw (0, _helpers.makeError)('Baobab.Cursor.getters: invalid path.', { path: path });\n\t\n\t      if (!this.solvedPath) return { data: undefined, solvedPath: null, exists: false };\n\t\n\t      return (0, _helpers.getIn)(this.tree._data, this.solvedPath.concat(path));\n\t    }\n\t\n\t    /**\n\t     * Method used to check whether a certain path exists in the tree starting\n\t     * from the current cursor.\n\t     *\n\t     * Arity (1):\n\t     * @param  {path}   path           - Path to check in the tree.\n\t     *\n\t     * Arity (2):\n\t     * @param {..step}  path           - Path to check in the tree.\n\t     *\n\t     * @return {boolean}               - Does the given path exists?\n\t     */\n\t  }, {\n\t    key: 'exists',\n\t    value: function exists(path) {\n\t      path = (0, _helpers.coercePath)(path);\n\t\n\t      if (arguments.length > 1) path = (0, _helpers.arrayFrom)(arguments);\n\t\n\t      return this._get(path).exists;\n\t    }\n\t\n\t    /**\n\t     * Method used to get data from the tree. Will fire a `get` event from the\n\t     * tree so that the user may sometimes react upon it to fetch data, for\n\t     * instance.\n\t     *\n\t     * Arity (1):\n\t     * @param  {path}   path           - Path to get in the tree.\n\t     *\n\t     * Arity (2):\n\t     * @param  {..step} path           - Path to get in the tree.\n\t     *\n\t     * @return {mixed}                 - Data at path.\n\t     */\n\t  }, {\n\t    key: 'get',\n\t    value: function get(path) {\n\t      path = (0, _helpers.coercePath)(path);\n\t\n\t      if (arguments.length > 1) path = (0, _helpers.arrayFrom)(arguments);\n\t\n\t      var _get2 = this._get(path);\n\t\n\t      var data = _get2.data;\n\t      var solvedPath = _get2.solvedPath;\n\t\n\t      // Emitting the event\n\t      this.tree.emit('get', { data: data, solvedPath: solvedPath, path: this.path.concat(path) });\n\t\n\t      return data;\n\t    }\n\t\n\t    /**\n\t     * Method used to shallow clone data from the tree.\n\t     *\n\t     * Arity (1):\n\t     * @param  {path}   path           - Path to get in the tree.\n\t     *\n\t     * Arity (2):\n\t     * @param  {..step} path           - Path to get in the tree.\n\t     *\n\t     * @return {mixed}                 - Cloned data at path.\n\t     */\n\t  }, {\n\t    key: 'clone',\n\t    value: function clone() {\n\t      var data = this.get.apply(this, arguments);\n\t\n\t      return (0, _helpers.shallowClone)(data);\n\t    }\n\t\n\t    /**\n\t     * Method used to deep clone data from the tree.\n\t     *\n\t     * Arity (1):\n\t     * @param  {path}   path           - Path to get in the tree.\n\t     *\n\t     * Arity (2):\n\t     * @param  {..step} path           - Path to get in the tree.\n\t     *\n\t     * @return {mixed}                 - Cloned data at path.\n\t     */\n\t  }, {\n\t    key: 'deepClone',\n\t    value: function deepClone() {\n\t      var data = this.get.apply(this, arguments);\n\t\n\t      return (0, _helpers.deepClone)(data);\n\t    }\n\t\n\t    /**\n\t     * Method used to return raw data from the tree, by carefully avoiding\n\t     * computed one.\n\t     *\n\t     * @todo: should be more performant as the cloning should happen as well as\n\t     * when dropping computed data.\n\t     *\n\t     * Arity (1):\n\t     * @param  {path}   path           - Path to serialize in the tree.\n\t     *\n\t     * Arity (2):\n\t     * @param  {..step} path           - Path to serialize in the tree.\n\t     *\n\t     * @return {mixed}                 - The retrieved raw data.\n\t     */\n\t  }, {\n\t    key: 'serialize',\n\t    value: function serialize(path) {\n\t      path = (0, _helpers.coercePath)(path);\n\t\n\t      if (arguments.length > 1) path = (0, _helpers.arrayFrom)(arguments);\n\t\n\t      if (!_type2['default'].path(path)) throw (0, _helpers.makeError)('Baobab.Cursor.getters: invalid path.', { path: path });\n\t\n\t      if (!this.solvedPath) return undefined;\n\t\n\t      var fullPath = this.solvedPath.concat(path);\n\t\n\t      var data = (0, _helpers.deepClone)((0, _helpers.getIn)(this.tree._data, fullPath).data),\n\t          monkeys = (0, _helpers.getIn)(this.tree._monkeys, fullPath).data;\n\t\n\t      var dropComputedData = function dropComputedData(d, m) {\n\t        if (!_type2['default'].object(m) || !_type2['default'].object(d)) return;\n\t\n\t        for (var k in m) {\n\t          if (m[k] instanceof _monkey.Monkey) delete d[k];else dropComputedData(d[k], m[k]);\n\t        }\n\t      };\n\t\n\t      dropComputedData(data, monkeys);\n\t      return data;\n\t    }\n\t\n\t    /**\n\t     * Method used to project some of the data at cursor onto a map or a list.\n\t     *\n\t     * @param  {object|array} projection - The projection's formal definition.\n\t     * @return {object|array}            - The resultant map/list.\n\t     */\n\t  }, {\n\t    key: 'project',\n\t    value: function project(projection) {\n\t      if (_type2['default'].object(projection)) {\n\t        var data = {};\n\t\n\t        for (var k in projection) {\n\t          data[k] = this.get(projection[k]);\n\t        }return data;\n\t      } else if (_type2['default'].array(projection)) {\n\t        var data = [];\n\t\n\t        for (var i = 0, l = projection.length; i < l; i++) {\n\t          data.push(this.get(projection[i]));\n\t        }return data;\n\t      }\n\t\n\t      throw (0, _helpers.makeError)('Baobab.Cursor.project: wrong projection.', { projection: projection });\n\t    }\n\t\n\t    /**\n\t     * History Methods\n\t     * ----------------\n\t     */\n\t\n\t    /**\n\t     * Methods starting to record the cursor's successive states.\n\t     *\n\t     * @param  {integer} [maxRecords] - Maximum records to keep in memory. Note\n\t     *                                  that if no number is provided, the cursor\n\t     *                                  will keep everything.\n\t     * @return {Cursor}               - The cursor instance for chaining purposes.\n\t     */\n\t  }, {\n\t    key: 'startRecording',\n\t    value: function startRecording(maxRecords) {\n\t      maxRecords = maxRecords || Infinity;\n\t\n\t      if (maxRecords < 1) throw (0, _helpers.makeError)('Baobab.Cursor.startRecording: invalid max records.', {\n\t        value: maxRecords\n\t      });\n\t\n\t      this.state.recording = true;\n\t\n\t      if (this.archive) return this;\n\t\n\t      // Lazy binding\n\t      this._lazyBind();\n\t\n\t      this.archive = new _helpers.Archive(maxRecords);\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Methods stopping to record the cursor's successive states.\n\t     *\n\t     * @return {Cursor} - The cursor instance for chaining purposes.\n\t     */\n\t  }, {\n\t    key: 'stopRecording',\n\t    value: function stopRecording() {\n\t      this.state.recording = false;\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Methods undoing n steps of the cursor's recorded states.\n\t     *\n\t     * @param  {integer} [steps=1] - The number of steps to rollback.\n\t     * @return {Cursor}            - The cursor instance for chaining purposes.\n\t     */\n\t  }, {\n\t    key: 'undo',\n\t    value: function undo() {\n\t      var steps = arguments.length <= 0 || arguments[0] === undefined ? 1 : arguments[0];\n\t\n\t      if (!this.state.recording) throw new Error('Baobab.Cursor.undo: cursor is not recording.');\n\t\n\t      var record = this.archive.back(steps);\n\t\n\t      if (!record) throw Error('Baobab.Cursor.undo: cannot find a relevant record.');\n\t\n\t      this.state.undoing = true;\n\t      this.set(record);\n\t\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Methods returning whether the cursor has a recorded history.\n\t     *\n\t     * @return {boolean} - `true` if the cursor has a recorded history?\n\t     */\n\t  }, {\n\t    key: 'hasHistory',\n\t    value: function hasHistory() {\n\t      return !!(this.archive && this.archive.get().length);\n\t    }\n\t\n\t    /**\n\t     * Methods returning the cursor's history.\n\t     *\n\t     * @return {array} - The cursor's history.\n\t     */\n\t  }, {\n\t    key: 'getHistory',\n\t    value: function getHistory() {\n\t      return this.archive ? this.archive.get() : [];\n\t    }\n\t\n\t    /**\n\t     * Methods clearing the cursor's history.\n\t     *\n\t     * @return {Cursor} - The cursor instance for chaining purposes.\n\t     */\n\t  }, {\n\t    key: 'clearHistory',\n\t    value: function clearHistory() {\n\t      if (this.archive) this.archive.clear();\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Releasing\n\t     * ----------\n\t     */\n\t\n\t    /**\n\t     * Methods releasing the cursor from memory.\n\t     */\n\t  }, {\n\t    key: 'release',\n\t    value: function release() {\n\t\n\t      // Removing listeners on parent\n\t      if (this._dynamicPath) this.tree.off('write', this._writeHandler);\n\t\n\t      this.tree.off('update', this._updateHandler);\n\t\n\t      // Unsubscribe from the parent\n\t      if (this.hash) delete this.tree._cursors[this.hash];\n\t\n\t      // Dereferencing\n\t      delete this.tree;\n\t      delete this.path;\n\t      delete this.solvedPath;\n\t      delete this.archive;\n\t\n\t      // Killing emitter\n\t      this.kill();\n\t      this.state.killed = true;\n\t    }\n\t\n\t    /**\n\t     * Output\n\t     * -------\n\t     */\n\t\n\t    /**\n\t     * Overriding the `toJSON` method for convenient use with JSON.stringify.\n\t     *\n\t     * @return {mixed} - Data at cursor.\n\t     */\n\t  }, {\n\t    key: 'toJSON',\n\t    value: function toJSON() {\n\t      return this.serialize();\n\t    }\n\t\n\t    /**\n\t     * Overriding the `toString` method for debugging purposes.\n\t     *\n\t     * @return {string} - The cursor's identity.\n\t     */\n\t  }, {\n\t    key: 'toString',\n\t    value: function toString() {\n\t      return this._identity;\n\t    }\n\t  }]);\n\t\n\t  return Cursor;\n\t})(_emmett2['default']);\n\t\n\texports['default'] = Cursor;\n\tif (typeof Symbol === 'function' && typeof Symbol.iterator !== 'undefined') {\n\t  Cursor.prototype[Symbol.iterator] = function () {\n\t    var array = this._get().data;\n\t\n\t    if (!_type2['default'].array(array)) throw Error('baobab.Cursor.@@iterate: cannot iterate a non-list type.');\n\t\n\t    var i = 0;\n\t\n\t    var cursor = this,\n\t        length = array.length;\n\t\n\t    return {\n\t      next: function next() {\n\t        if (i < length) {\n\t          return {\n\t            value: cursor.select(i++)\n\t          };\n\t        }\n\t\n\t        return {\n\t          done: true\n\t        };\n\t      }\n\t    };\n\t  };\n\t}\n\t\n\t/**\n\t * Setter Methods\n\t * ---------------\n\t *\n\t * Those methods are dynamically assigned to the class for DRY reasons.\n\t */\n\t\n\t// Not using a Set so that ES5 consumers don't pay a bundle size price\n\tvar INTRANSITIVE_SETTERS = {\n\t  unset: true,\n\t  pop: true,\n\t  shift: true\n\t};\n\t\n\t/**\n\t * Function creating a setter method for the Cursor class.\n\t *\n\t * @param {string}   name          - the method's name.\n\t * @param {function} [typeChecker] - a function checking that the given value is\n\t *                                   valid for the given operation.\n\t */\n\tfunction makeSetter(name, typeChecker) {\n\t\n\t  /**\n\t   * Binding a setter method to the Cursor class and having the following\n\t   * definition.\n\t   *\n\t   * Note: this is not really possible to make those setters variadic because\n\t   * it would create an impossible polymorphism with path.\n\t   *\n\t   * @todo: perform value validation elsewhere so that tree.update can\n\t   * beneficiate from it.\n\t   *\n\t   * Arity (1):\n\t   * @param  {mixed} value - New value to set at cursor's path.\n\t   *\n\t   * Arity (2):\n\t   * @param  {path}  path  - Subpath to update starting from cursor's.\n\t   * @param  {mixed} value - New value to set.\n\t   *\n\t   * @return {mixed}       - Data at path.\n\t   */\n\t  Cursor.prototype[name] = function (path, value) {\n\t\n\t    // We should warn the user if he applies to many arguments to the function\n\t    if (arguments.length > 2) throw (0, _helpers.makeError)('Baobab.Cursor.' + name + ': too many arguments.');\n\t\n\t    // Handling arities\n\t    if (arguments.length === 1 && !INTRANSITIVE_SETTERS[name]) {\n\t      value = path;\n\t      path = [];\n\t    }\n\t\n\t    // Coerce path\n\t    path = (0, _helpers.coercePath)(path);\n\t\n\t    // Checking the path's validity\n\t    if (!_type2['default'].path(path)) throw (0, _helpers.makeError)('Baobab.Cursor.' + name + ': invalid path.', { path: path });\n\t\n\t    // Checking the value's validity\n\t    if (typeChecker && !typeChecker(value)) throw (0, _helpers.makeError)('Baobab.Cursor.' + name + ': invalid value.', { path: path, value: value });\n\t\n\t    // Checking the solvability of the cursor's dynamic path\n\t    if (!this.solvedPath) throw (0, _helpers.makeError)('Baobab.Cursor.' + name + ': the dynamic path of the cursor cannot be solved.', { path: this.path });\n\t\n\t    var fullPath = this.solvedPath.concat(path);\n\t\n\t    // Filing the update to the tree\n\t    return this.tree.update(fullPath, {\n\t      type: name,\n\t      value: value\n\t    });\n\t  };\n\t}\n\t\n\t/**\n\t * Making the necessary setters.\n\t */\n\tmakeSetter('set');\n\tmakeSetter('unset');\n\tmakeSetter('apply', _type2['default']['function']);\n\tmakeSetter('push');\n\tmakeSetter('concat', _type2['default'].array);\n\tmakeSetter('unshift');\n\tmakeSetter('pop');\n\tmakeSetter('shift');\n\tmakeSetter('splice', _type2['default'].splicer);\n\tmakeSetter('merge', _type2['default'].object);\n\tmakeSetter('deepMerge', _type2['default'].object);\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Baobab Monkeys\n\t * ===============\n\t *\n\t * Exposing both handy monkey definitions and the underlying working class.\n\t */\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\t\n\tvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\t\n\tvar _type = __webpack_require__(15);\n\t\n\tvar _type2 = _interopRequireDefault(_type);\n\t\n\tvar _update2 = __webpack_require__(16);\n\t\n\tvar _update3 = _interopRequireDefault(_update2);\n\t\n\tvar _helpers = __webpack_require__(17);\n\t\n\t/**\n\t * Monkey Definition class\n\t * Note: The only reason why this is a class is to be able to spot it within\n\t * otherwise ordinary data.\n\t *\n\t * @constructor\n\t * @param {array|object} definition - The formal definition of the monkey.\n\t */\n\t\n\tvar MonkeyDefinition = function MonkeyDefinition(definition) {\n\t  var _this = this;\n\t\n\t  _classCallCheck(this, MonkeyDefinition);\n\t\n\t  var monkeyType = _type2['default'].monkeyDefinition(definition);\n\t\n\t  if (!monkeyType) throw (0, _helpers.makeError)('Baobab.monkey: invalid definition.', { definition: definition });\n\t\n\t  this.type = monkeyType;\n\t\n\t  if (this.type === 'object') {\n\t    this.getter = definition.get;\n\t    this.projection = definition.cursors || {};\n\t    this.paths = Object.keys(this.projection).map(function (k) {\n\t      return _this.projection[k];\n\t    });\n\t    this.options = definition.options || {};\n\t  } else {\n\t    var offset = 1,\n\t        options = {};\n\t\n\t    if (_type2['default'].object(definition[definition.length - 1])) {\n\t      offset++;\n\t      options = definition[definition.length - 1];\n\t    }\n\t\n\t    this.getter = definition[definition.length - offset];\n\t    this.projection = definition.slice(0, -offset);\n\t    this.paths = this.projection;\n\t    this.options = options;\n\t  }\n\t\n\t  // Coercing paths for convenience\n\t  this.paths = this.paths.map(function (p) {\n\t    return [].concat(p);\n\t  });\n\t\n\t  // Does the definition contain dynamic paths\n\t  this.hasDynamicPaths = this.paths.some(_type2['default'].dynamicPath);\n\t}\n\t\n\t/**\n\t * Monkey core class\n\t *\n\t * @constructor\n\t * @param {Baobab}           tree       - The bound tree.\n\t * @param {MonkeyDefinition} definition - A definition instance.\n\t */\n\t;\n\t\n\texports.MonkeyDefinition = MonkeyDefinition;\n\t\n\tvar Monkey = (function () {\n\t  function Monkey(tree, pathInTree, definition) {\n\t    var _this2 = this;\n\t\n\t    _classCallCheck(this, Monkey);\n\t\n\t    // Properties\n\t    this.tree = tree;\n\t    this.path = pathInTree;\n\t    this.definition = definition;\n\t\n\t    // Adapting the definition's paths & projection to this monkey's case\n\t    var projection = definition.projection,\n\t        relative = _helpers.solveRelativePath.bind(null, pathInTree.slice(0, -1));\n\t\n\t    if (definition.type === 'object') {\n\t      this.projection = Object.keys(projection).reduce(function (acc, k) {\n\t        acc[k] = relative(projection[k]);\n\t        return acc;\n\t      }, {});\n\t      this.depPaths = Object.keys(this.projection).map(function (k) {\n\t        return _this2.projection[k];\n\t      });\n\t    } else {\n\t      this.projection = projection.map(relative);\n\t      this.depPaths = this.projection;\n\t    }\n\t\n\t    // Internal state\n\t    this.state = {\n\t      killed: false\n\t    };\n\t\n\t    /**\n\t     * Listener on the tree's `write` event.\n\t     *\n\t     * When the tree writes, this listener will check whether the updated paths\n\t     * are of any use to the monkey and, if so, will update the tree's node\n\t     * where the monkey sits.\n\t     */\n\t    this.writeListener = function (_ref) {\n\t      var path = _ref.data.path;\n\t\n\t      if (_this2.state.killed) return;\n\t\n\t      // Is the monkey affected by the current write event?\n\t      var concerned = (0, _helpers.solveUpdate)([path], _this2.relatedPaths());\n\t\n\t      if (concerned) _this2.update();\n\t    };\n\t\n\t    /**\n\t     * Listener on the tree's `monkey` event.\n\t     *\n\t     * When another monkey updates, this listener will check whether the\n\t     * updated paths are of any use to the monkey and, if so, will update the\n\t     * tree's node where the monkey sits.\n\t     */\n\t    this.recursiveListener = function (_ref2) {\n\t      var _ref2$data = _ref2.data;\n\t      var monkey = _ref2$data.monkey;\n\t      var path = _ref2$data.path;\n\t\n\t      if (_this2.state.killed) return;\n\t\n\t      // Breaking if this is the same monkey\n\t      if (_this2 === monkey) return;\n\t\n\t      // Is the monkey affected by the current monkey event?\n\t      var concerned = (0, _helpers.solveUpdate)([path], _this2.relatedPaths(false));\n\t\n\t      if (concerned) _this2.update();\n\t    };\n\t\n\t    // Binding listeners\n\t    this.tree.on('write', this.writeListener);\n\t    this.tree.on('_monkey', this.recursiveListener);\n\t\n\t    // Updating relevant node\n\t    this.update();\n\t  }\n\t\n\t  /**\n\t   * Method returning solved paths related to the monkey.\n\t   *\n\t   * @param  {boolean} recursive - Should we compute recursive paths?\n\t   * @return {array}             - An array of related paths.\n\t   */\n\t\n\t  _createClass(Monkey, [{\n\t    key: 'relatedPaths',\n\t    value: function relatedPaths() {\n\t      var _this3 = this;\n\t\n\t      var recursive = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];\n\t\n\t      var paths = undefined;\n\t\n\t      if (this.definition.hasDynamicPaths) paths = this.depPaths.map(function (p) {\n\t        return (0, _helpers.getIn)(_this3.tree._data, p).solvedPath;\n\t      });else paths = this.depPaths;\n\t\n\t      var isRecursive = recursive && this.depPaths.some(function (p) {\n\t        return !!_type2['default'].monkeyPath(_this3.tree._monkeys, p);\n\t      });\n\t\n\t      if (!isRecursive) return paths;\n\t\n\t      return paths.reduce(function (accumulatedPaths, path) {\n\t        var monkeyPath = _type2['default'].monkeyPath(_this3.tree._monkeys, path);\n\t\n\t        if (!monkeyPath) return accumulatedPaths.concat([path]);\n\t\n\t        // Solving recursive path\n\t        var relatedMonkey = (0, _helpers.getIn)(_this3.tree._monkeys, monkeyPath).data;\n\t\n\t        return accumulatedPaths.concat(relatedMonkey.relatedPaths());\n\t      }, []);\n\t    }\n\t\n\t    /**\n\t     * Method used to update the tree's internal data with a lazy getter holding\n\t     * the computed data.\n\t     *\n\t     * @return {Monkey} - Returns itself for chaining purposes.\n\t     */\n\t  }, {\n\t    key: 'update',\n\t    value: function update() {\n\t      var deps = this.tree.project(this.projection);\n\t\n\t      var lazyGetter = (function (tree, def, data) {\n\t        var cache = null,\n\t            alreadyComputed = false;\n\t\n\t        return function () {\n\t\n\t          if (!alreadyComputed) {\n\t            cache = def.getter.apply(tree, def.type === 'object' ? [data] : data);\n\t\n\t            if (tree.options.immutable && def.options.immutable !== false) (0, _helpers.deepFreeze)(cache);\n\t\n\t            alreadyComputed = true;\n\t          }\n\t\n\t          return cache;\n\t        };\n\t      })(this.tree, this.definition, deps);\n\t\n\t      lazyGetter.isLazyGetter = true;\n\t\n\t      // Should we write the lazy getter in the tree or solve it right now?\n\t      if (this.tree.options.lazyMonkeys) {\n\t        this.tree._data = (0, _update3['default'])(this.tree._data, this.path, {\n\t          type: 'monkey',\n\t          value: lazyGetter\n\t        }, this.tree.options).data;\n\t      } else {\n\t        var result = (0, _update3['default'])(this.tree._data, this.path, {\n\t          type: 'set',\n\t          value: lazyGetter(),\n\t          options: {\n\t            mutableLeaf: !this.definition.options.immutable\n\t          }\n\t        }, this.tree.options);\n\t\n\t        if ('data' in result) this.tree._data = result.data;\n\t      }\n\t\n\t      // Notifying the monkey's update so we can handle recursivity\n\t      this.tree.emit('_monkey', { monkey: this, path: this.path });\n\t\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Method releasing the monkey from memory.\n\t     */\n\t  }, {\n\t    key: 'release',\n\t    value: function release() {\n\t\n\t      // Unbinding events\n\t      this.tree.off('write', this.writeListener);\n\t      this.tree.off('_monkey', this.monkeyListener);\n\t      this.state.killed = true;\n\t\n\t      // Deleting properties\n\t      // NOTE: not deleting this.definition because some strange things happen\n\t      // in the _refreshMonkeys method. See #372.\n\t      delete this.projection;\n\t      delete this.depPaths;\n\t      delete this.tree;\n\t    }\n\t  }]);\n\t\n\t  return Monkey;\n\t})();\n\t\n\texports.Monkey = Monkey;\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Baobab Type Checking\n\t * =====================\n\t *\n\t * Helpers functions used throughout the library to perform some type\n\t * tests at runtime.\n\t *\n\t */\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\t\n\tvar _monkey = __webpack_require__(14);\n\t\n\tvar type = {};\n\t\n\t/**\n\t * Helpers\n\t * --------\n\t */\n\t\n\t/**\n\t * Checking whether the given variable is of any of the given types.\n\t *\n\t * @todo   Optimize this function by dropping `some`.\n\t *\n\t * @param  {mixed} target  - Variable to test.\n\t * @param  {array} allowed - Array of allowed types.\n\t * @return {boolean}\n\t */\n\tfunction anyOf(target, allowed) {\n\t  return allowed.some(function (t) {\n\t    return type[t](target);\n\t  });\n\t}\n\t\n\t/**\n\t * Simple types\n\t * -------------\n\t */\n\t\n\t/**\n\t * Checking whether the given variable is an array.\n\t *\n\t * @param  {mixed} target - Variable to test.\n\t * @return {boolean}\n\t */\n\ttype.array = function (target) {\n\t  return Array.isArray(target);\n\t};\n\t\n\t/**\n\t * Checking whether the given variable is an object.\n\t *\n\t * @param  {mixed} target - Variable to test.\n\t * @return {boolean}\n\t */\n\ttype.object = function (target) {\n\t  return target && typeof target === 'object' && !Array.isArray(target) && !(target instanceof Date) && !(target instanceof RegExp) && !(typeof Map === 'function' && target instanceof Map) && !(typeof Set === 'function' && target instanceof Set);\n\t};\n\t\n\t/**\n\t * Checking whether the given variable is a string.\n\t *\n\t * @param  {mixed} target - Variable to test.\n\t * @return {boolean}\n\t */\n\ttype.string = function (target) {\n\t  return typeof target === 'string';\n\t};\n\t\n\t/**\n\t * Checking whether the given variable is a number.\n\t *\n\t * @param  {mixed} target - Variable to test.\n\t * @return {boolean}\n\t */\n\ttype.number = function (target) {\n\t  return typeof target === 'number';\n\t};\n\t\n\t/**\n\t * Checking whether the given variable is a function.\n\t *\n\t * @param  {mixed} target - Variable to test.\n\t * @return {boolean}\n\t */\n\ttype['function'] = function (target) {\n\t  return typeof target === 'function';\n\t};\n\t\n\t/**\n\t * Checking whether the given variable is a JavaScript primitive.\n\t *\n\t * @param  {mixed} target - Variable to test.\n\t * @return {boolean}\n\t */\n\ttype.primitive = function (target) {\n\t  return target !== Object(target);\n\t};\n\t\n\t/**\n\t * Complex types\n\t * --------------\n\t */\n\t\n\t/**\n\t * Checking whether the given variable is a valid splicer.\n\t *\n\t * @param  {mixed} target    - Variable to test.\n\t * @param  {array} [allowed] - Optional valid types in path.\n\t * @return {boolean}\n\t */\n\ttype.splicer = function (target) {\n\t  if (!type.array(target) || target.length < 2) return false;\n\t\n\t  return anyOf(target[0], ['number', 'function', 'object']) && type.number(target[1]);\n\t};\n\t\n\t/**\n\t * Checking whether the given variable is a valid cursor path.\n\t *\n\t * @param  {mixed} target    - Variable to test.\n\t * @param  {array} [allowed] - Optional valid types in path.\n\t * @return {boolean}\n\t */\n\t\n\t// Order is important for performance reasons\n\tvar ALLOWED_FOR_PATH = ['string', 'number', 'function', 'object'];\n\t\n\ttype.path = function (target) {\n\t  if (!target && target !== 0 && target !== '') return false;\n\t\n\t  return [].concat(target).every(function (step) {\n\t    return anyOf(step, ALLOWED_FOR_PATH);\n\t  });\n\t};\n\t\n\t/**\n\t * Checking whether the given path is a dynamic one.\n\t *\n\t * @param  {mixed} path - The path to test.\n\t * @return {boolean}\n\t */\n\ttype.dynamicPath = function (path) {\n\t  return path.some(function (step) {\n\t    return type['function'](step) || type.object(step);\n\t  });\n\t};\n\t\n\t/**\n\t * Retrieve any monkey subpath in the given path or null if the path never comes\n\t * across computed data.\n\t *\n\t * @param  {mixed} data - The data to test.\n\t * @param  {array} path - The path to test.\n\t * @return {boolean}\n\t */\n\ttype.monkeyPath = function (data, path) {\n\t  var subpath = [];\n\t\n\t  var c = data,\n\t      i = undefined,\n\t      l = undefined;\n\t\n\t  for (i = 0, l = path.length; i < l; i++) {\n\t    subpath.push(path[i]);\n\t\n\t    if (typeof c !== 'object') return null;\n\t\n\t    c = c[path[i]];\n\t\n\t    if (c instanceof _monkey.Monkey) return subpath;\n\t  }\n\t\n\t  return null;\n\t};\n\t\n\t/**\n\t * Check if the given object property is a lazy getter used by a monkey.\n\t *\n\t * @param  {mixed}   o           - The target object.\n\t * @param  {string}  propertyKey - The property to test.\n\t * @return {boolean}\n\t */\n\ttype.lazyGetter = function (o, propertyKey) {\n\t  var descriptor = Object.getOwnPropertyDescriptor(o, propertyKey);\n\t\n\t  return descriptor && descriptor.get && descriptor.get.isLazyGetter === true;\n\t};\n\t\n\t/**\n\t * Returns the type of the given monkey definition or `null` if invalid.\n\t *\n\t * @param  {mixed} definition - The definition to check.\n\t * @return {string|null}\n\t */\n\ttype.monkeyDefinition = function (definition) {\n\t\n\t  if (type.object(definition)) {\n\t    if (!type['function'](definition.get) || definition.cursors && (!type.object(definition.cursors) || !Object.keys(definition.cursors).every(function (k) {\n\t      return type.path(definition.cursors[k]);\n\t    }))) return null;\n\t\n\t    return 'object';\n\t  } else if (type.array(definition)) {\n\t    var offset = 1;\n\t\n\t    if (type.object(definition[definition.length - 1])) offset++;\n\t\n\t    if (!type['function'](definition[definition.length - offset]) || !definition.slice(0, -offset).every(function (p) {\n\t      return type.path(p);\n\t    })) return null;\n\t\n\t    return 'array';\n\t  }\n\t\n\t  return null;\n\t};\n\t\n\t/**\n\t * Checking whether the given watcher definition is valid.\n\t *\n\t * @param  {mixed}   definition - The definition to check.\n\t * @return {boolean}\n\t */\n\ttype.watcherMapping = function (definition) {\n\t  return type.object(definition) && Object.keys(definition).every(function (k) {\n\t    return type.path(definition[k]);\n\t  });\n\t};\n\t\n\t/**\n\t * Checking whether the given string is a valid operation type.\n\t *\n\t * @param  {mixed} string - The string to test.\n\t * @return {boolean}\n\t */\n\t\n\t// Ordered by likeliness\n\tvar VALID_OPERATIONS = ['set', 'apply', 'push', 'unshift', 'concat', 'pop', 'shift', 'deepMerge', 'merge', 'splice', 'unset'];\n\t\n\ttype.operationType = function (string) {\n\t  return typeof string === 'string' && !! ~VALID_OPERATIONS.indexOf(string);\n\t};\n\t\n\texports['default'] = type;\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Baobab Update\n\t * ==============\n\t *\n\t * The tree's update scheme.\n\t */\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\texports['default'] = update;\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }\n\t\n\tvar _type = __webpack_require__(15);\n\t\n\tvar _type2 = _interopRequireDefault(_type);\n\t\n\tvar _helpers = __webpack_require__(17);\n\t\n\tfunction err(operation, expectedTarget, path) {\n\t  return (0, _helpers.makeError)('Baobab.update: cannot apply the \"' + operation + '\" on ' + ('a non ' + expectedTarget + ' (path: /' + path.join('/') + ').'), { path: path });\n\t}\n\t\n\t/**\n\t * Function aiming at applying a single update operation on the given tree's\n\t * data.\n\t *\n\t * @param  {mixed}  data      - The tree's data.\n\t * @param  {path}   path      - Path of the update.\n\t * @param  {object} operation - The operation to apply.\n\t * @param  {object} [opts]    - Optional options.\n\t * @return {mixed}            - Both the new tree's data and the updated node.\n\t */\n\t\n\tfunction update(data, path, operation) {\n\t  var opts = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];\n\t  var operationType = operation.type;\n\t  var value = operation.value;\n\t  var _operation$options = operation.options;\n\t  var operationOptions = _operation$options === undefined ? {} : _operation$options;\n\t\n\t  // Dummy root, so we can shift and alter the root\n\t  var dummy = { root: data },\n\t      dummyPath = ['root'].concat(_toConsumableArray(path)),\n\t      currentPath = [];\n\t\n\t  // Walking the path\n\t  var p = dummy,\n\t      i = undefined,\n\t      l = undefined,\n\t      s = undefined;\n\t\n\t  for (i = 0, l = dummyPath.length; i < l; i++) {\n\t\n\t    // Current item's reference is therefore p[s]\n\t    // The reason why we don't create a variable here for convenience\n\t    // is because we actually need to mutate the reference.\n\t    s = dummyPath[i];\n\t\n\t    // Updating the path\n\t    if (i > 0) currentPath.push(s);\n\t\n\t    // If we reached the end of the path, we apply the operation\n\t    if (i === l - 1) {\n\t\n\t      /**\n\t       * Set\n\t       */\n\t      if (operationType === 'set') {\n\t\n\t        // Purity check\n\t        if (opts.pure && p[s] === value) return { node: p[s] };\n\t\n\t        if (_type2['default'].lazyGetter(p, s)) {\n\t          Object.defineProperty(p, s, {\n\t            value: value,\n\t            enumerable: true,\n\t            configurable: true\n\t          });\n\t        } else if (opts.persistent && !operationOptions.mutableLeaf) {\n\t          p[s] = (0, _helpers.shallowClone)(value);\n\t        } else {\n\t          p[s] = value;\n\t        }\n\t      }\n\t\n\t      /**\n\t       * Monkey\n\t       */\n\t      else if (operationType === 'monkey') {\n\t          Object.defineProperty(p, s, {\n\t            get: value,\n\t            enumerable: true,\n\t            configurable: true\n\t          });\n\t        }\n\t\n\t        /**\n\t         * Apply\n\t         */\n\t        else if (operationType === 'apply') {\n\t            var result = value(p[s]);\n\t\n\t            // Purity check\n\t            if (opts.pure && p[s] === result) return { node: p[s] };\n\t\n\t            if (_type2['default'].lazyGetter(p, s)) {\n\t              Object.defineProperty(p, s, {\n\t                value: result,\n\t                enumerable: true,\n\t                configurable: true\n\t              });\n\t            } else if (opts.persistent) {\n\t              p[s] = (0, _helpers.shallowClone)(result);\n\t            } else {\n\t              p[s] = result;\n\t            }\n\t          }\n\t\n\t          /**\n\t           * Push\n\t           */\n\t          else if (operationType === 'push') {\n\t              if (!_type2['default'].array(p[s])) throw err('push', 'array', currentPath);\n\t\n\t              if (opts.persistent) p[s] = p[s].concat([value]);else p[s].push(value);\n\t            }\n\t\n\t            /**\n\t             * Unshift\n\t             */\n\t            else if (operationType === 'unshift') {\n\t                if (!_type2['default'].array(p[s])) throw err('unshift', 'array', currentPath);\n\t\n\t                if (opts.persistent) p[s] = [value].concat(p[s]);else p[s].unshift(value);\n\t              }\n\t\n\t              /**\n\t               * Concat\n\t               */\n\t              else if (operationType === 'concat') {\n\t                  if (!_type2['default'].array(p[s])) throw err('concat', 'array', currentPath);\n\t\n\t                  if (opts.persistent) p[s] = p[s].concat(value);else p[s].push.apply(p[s], value);\n\t                }\n\t\n\t                /**\n\t                 * Splice\n\t                 */\n\t                else if (operationType === 'splice') {\n\t                    if (!_type2['default'].array(p[s])) throw err('splice', 'array', currentPath);\n\t\n\t                    if (opts.persistent) p[s] = _helpers.splice.apply(null, [p[s]].concat(value));else p[s].splice.apply(p[s], value);\n\t                  }\n\t\n\t                  /**\n\t                   * Pop\n\t                   */\n\t                  else if (operationType === 'pop') {\n\t                      if (!_type2['default'].array(p[s])) throw err('pop', 'array', currentPath);\n\t\n\t                      if (opts.persistent) p[s] = (0, _helpers.splice)(p[s], -1, 1);else p[s].pop();\n\t                    }\n\t\n\t                    /**\n\t                     * Shift\n\t                     */\n\t                    else if (operationType === 'shift') {\n\t                        if (!_type2['default'].array(p[s])) throw err('shift', 'array', currentPath);\n\t\n\t                        if (opts.persistent) p[s] = (0, _helpers.splice)(p[s], 0, 1);else p[s].shift();\n\t                      }\n\t\n\t                      /**\n\t                       * Unset\n\t                       */\n\t                      else if (operationType === 'unset') {\n\t                          if (_type2['default'].object(p)) delete p[s];else if (_type2['default'].array(p)) p.splice(s, 1);\n\t                        }\n\t\n\t                        /**\n\t                         * Merge\n\t                         */\n\t                        else if (operationType === 'merge') {\n\t                            if (!_type2['default'].object(p[s])) throw err('merge', 'object', currentPath);\n\t\n\t                            if (opts.persistent) p[s] = (0, _helpers.shallowMerge)({}, p[s], value);else p[s] = (0, _helpers.shallowMerge)(p[s], value);\n\t                          }\n\t\n\t                          /**\n\t                           * Deep merge\n\t                           */\n\t                          else if (operationType === 'deepMerge') {\n\t                              if (!_type2['default'].object(p[s])) throw err('deepMerge', 'object', currentPath);\n\t\n\t                              if (opts.persistent) p[s] = (0, _helpers.deepMerge)({}, p[s], value);else p[s] = (0, _helpers.deepMerge)(p[s], value);\n\t                            }\n\t\n\t      // Deep freezing the resulting value\n\t      if (opts.immutable && !operationOptions.mutableLeaf) (0, _helpers.deepFreeze)(p);\n\t\n\t      break;\n\t    }\n\t\n\t    // If we reached a leaf, we override by setting an empty object\n\t    else if (_type2['default'].primitive(p[s])) {\n\t        p[s] = {};\n\t      }\n\t\n\t      // Else, we shift the reference and continue the path\n\t      else if (opts.persistent) {\n\t          p[s] = (0, _helpers.shallowClone)(p[s]);\n\t        }\n\t\n\t    // Should we freeze the current step before continuing?\n\t    if (opts.immutable && l > 0) (0, _helpers.freeze)(p);\n\t\n\t    p = p[s];\n\t  }\n\t\n\t  // If we are updating a dynamic node, we need not return the affected node\n\t  if (_type2['default'].lazyGetter(p, s)) return { data: dummy.root };\n\t\n\t  // Returning new data object\n\t  return { data: dummy.root, node: p[s] };\n\t}\n\t\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {/* eslint eqeqeq: 0 */\n\t\n\t/**\n\t * Baobab Helpers\n\t * ===============\n\t *\n\t * Miscellaneous helper functions.\n\t */\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\t\n\tvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\t\n\texports.arrayFrom = arrayFrom;\n\texports.before = before;\n\texports.coercePath = coercePath;\n\texports.getIn = getIn;\n\texports.makeError = makeError;\n\texports.solveRelativePath = solveRelativePath;\n\texports.solveUpdate = solveUpdate;\n\texports.splice = splice;\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\t\n\tvar _monkey = __webpack_require__(14);\n\t\n\tvar _type = __webpack_require__(15);\n\t\n\tvar _type2 = _interopRequireDefault(_type);\n\t\n\t/**\n\t * Noop function\n\t */\n\tvar noop = Function.prototype;\n\t\n\t/**\n\t * Function returning the index of the first element of a list matching the\n\t * given predicate.\n\t *\n\t * @param  {array}     a  - The target array.\n\t * @param  {function}  fn - The predicate function.\n\t * @return {mixed}        - The index of the first matching item or -1.\n\t */\n\tfunction index(a, fn) {\n\t  var i = undefined,\n\t      l = undefined;\n\t  for (i = 0, l = a.length; i < l; i++) {\n\t    if (fn(a[i])) return i;\n\t  }\n\t  return -1;\n\t}\n\t\n\t/**\n\t * Efficient slice function used to clone arrays or parts of them.\n\t *\n\t * @param  {array} array - The array to slice.\n\t * @return {array}       - The sliced array.\n\t */\n\tfunction slice(array) {\n\t  var newArray = new Array(array.length);\n\t\n\t  var i = undefined,\n\t      l = undefined;\n\t\n\t  for (i = 0, l = array.length; i < l; i++) newArray[i] = array[i];\n\t\n\t  return newArray;\n\t}\n\t\n\t/**\n\t * Archive abstraction\n\t *\n\t * @constructor\n\t * @param {integer} size - Maximum number of records to store.\n\t */\n\t\n\tvar Archive = (function () {\n\t  function Archive(size) {\n\t    _classCallCheck(this, Archive);\n\t\n\t    this.size = size;\n\t    this.records = [];\n\t  }\n\t\n\t  /**\n\t   * Function creating a real array from what should be an array but is not.\n\t   * I'm looking at you nasty `arguments`...\n\t   *\n\t   * @param  {mixed} culprit - The culprit to convert.\n\t   * @return {array}         - The real array.\n\t   */\n\t\n\t  /**\n\t   * Method retrieving the records.\n\t   *\n\t   * @return {array} - The records.\n\t   */\n\t\n\t  _createClass(Archive, [{\n\t    key: 'get',\n\t    value: function get() {\n\t      return this.records;\n\t    }\n\t\n\t    /**\n\t     * Method adding a record to the archive\n\t     *\n\t     * @param {object}  record - The record to store.\n\t     * @return {Archive}       - The archive itself for chaining purposes.\n\t     */\n\t  }, {\n\t    key: 'add',\n\t    value: function add(record) {\n\t      this.records.unshift(record);\n\t\n\t      // If the number of records is exceeded, we truncate the records\n\t      if (this.records.length > this.size) this.records.length = this.size;\n\t\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Method clearing the records.\n\t     *\n\t     * @return {Archive} - The archive itself for chaining purposes.\n\t     */\n\t  }, {\n\t    key: 'clear',\n\t    value: function clear() {\n\t      this.records = [];\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Method to go back in time.\n\t     *\n\t     * @param {integer} steps - Number of steps we should go back by.\n\t     * @return {number}       - The last record.\n\t     */\n\t  }, {\n\t    key: 'back',\n\t    value: function back(steps) {\n\t      var record = this.records[steps - 1];\n\t\n\t      if (record) this.records = this.records.slice(steps);\n\t      return record;\n\t    }\n\t  }]);\n\t\n\t  return Archive;\n\t})();\n\t\n\texports.Archive = Archive;\n\t\n\tfunction arrayFrom(culprit) {\n\t  return slice(culprit);\n\t}\n\t\n\t/**\n\t * Function decorating one function with another that will be called before the\n\t * decorated one.\n\t *\n\t * @param  {function} decorator - The decorating function.\n\t * @param  {function} fn        - The function to decorate.\n\t * @return {function}           - The decorated function.\n\t */\n\t\n\tfunction before(decorator, fn) {\n\t  return function () {\n\t    decorator.apply(null, arguments);\n\t    fn.apply(null, arguments);\n\t  };\n\t}\n\t\n\t/**\n\t * Function cloning the given regular expression. Supports `y` and `u` flags\n\t * already.\n\t *\n\t * @param  {RegExp} re - The target regular expression.\n\t * @return {RegExp}    - The cloned regular expression.\n\t */\n\tfunction cloneRegexp(re) {\n\t  var pattern = re.source;\n\t\n\t  var flags = '';\n\t\n\t  if (re.global) flags += 'g';\n\t  if (re.multiline) flags += 'm';\n\t  if (re.ignoreCase) flags += 'i';\n\t  if (re.sticky) flags += 'y';\n\t  if (re.unicode) flags += 'u';\n\t\n\t  return new RegExp(pattern, flags);\n\t}\n\t\n\t/**\n\t * Function cloning the given variable.\n\t *\n\t * @todo: implement a faster way to clone an array.\n\t *\n\t * @param  {boolean} deep - Should we deep clone the variable.\n\t * @param  {mixed}   item - The variable to clone\n\t * @return {mixed}        - The cloned variable.\n\t */\n\tfunction cloner(deep, item) {\n\t  if (!item || typeof item !== 'object' || item instanceof Error || item instanceof _monkey.MonkeyDefinition || item instanceof _monkey.Monkey || 'ArrayBuffer' in global && item instanceof ArrayBuffer) return item;\n\t\n\t  // Array\n\t  if (_type2['default'].array(item)) {\n\t    if (deep) {\n\t      var a = [];\n\t\n\t      var i = undefined,\n\t          l = undefined;\n\t\n\t      for (i = 0, l = item.length; i < l; i++) a.push(cloner(true, item[i]));\n\t      return a;\n\t    }\n\t\n\t    return slice(item);\n\t  }\n\t\n\t  // Date\n\t  if (item instanceof Date) return new Date(item.getTime());\n\t\n\t  // RegExp\n\t  if (item instanceof RegExp) return cloneRegexp(item);\n\t\n\t  // Object\n\t  if (_type2['default'].object(item)) {\n\t    var o = {};\n\t\n\t    var k = undefined;\n\t\n\t    // NOTE: could be possible to erase computed properties through `null`.\n\t    for (k in item) {\n\t      if (_type2['default'].lazyGetter(item, k)) {\n\t        Object.defineProperty(o, k, {\n\t          get: Object.getOwnPropertyDescriptor(item, k).get,\n\t          enumerable: true,\n\t          configurable: true\n\t        });\n\t      } else if (item.hasOwnProperty(k)) {\n\t        o[k] = deep ? cloner(true, item[k]) : item[k];\n\t      }\n\t    }\n\t    return o;\n\t  }\n\t\n\t  return item;\n\t}\n\t\n\t/**\n\t * Exporting shallow and deep cloning functions.\n\t */\n\tvar shallowClone = cloner.bind(null, false),\n\t    deepClone = cloner.bind(null, true);\n\t\n\texports.shallowClone = shallowClone;\n\texports.deepClone = deepClone;\n\t\n\t/**\n\t * Coerce the given variable into a full-fledged path.\n\t *\n\t * @param  {mixed} target - The variable to coerce.\n\t * @return {array}        - The array path.\n\t */\n\t\n\tfunction coercePath(target) {\n\t  if (target || target === 0 || target === '') return target;\n\t  return [];\n\t}\n\t\n\t/**\n\t * Function comparing an object's properties to a given descriptive\n\t * object.\n\t *\n\t * @param  {object} object      - The object to compare.\n\t * @param  {object} description - The description's mapping.\n\t * @return {boolean}            - Whether the object matches the description.\n\t */\n\tfunction compare(object, description) {\n\t  var ok = true,\n\t      k = undefined;\n\t\n\t  // If we reached here via a recursive call, object may be undefined because\n\t  // not all items in a collection will have the same deep nesting structure.\n\t  if (!object) return false;\n\t\n\t  for (k in description) {\n\t    if (_type2['default'].object(description[k])) {\n\t      ok = ok && compare(object[k], description[k]);\n\t    } else if (_type2['default'].array(description[k])) {\n\t      ok = ok && !! ~description[k].indexOf(object[k]);\n\t    } else {\n\t      if (object[k] !== description[k]) return false;\n\t    }\n\t  }\n\t\n\t  return ok;\n\t}\n\t\n\t/**\n\t * Function freezing the given variable if possible.\n\t *\n\t * @param  {boolean} deep - Should we recursively freeze the given objects?\n\t * @param  {object}  o    - The variable to freeze.\n\t * @return {object}    - The merged object.\n\t */\n\tfunction freezer(deep, o) {\n\t  if (typeof o !== 'object' || o === null || o instanceof _monkey.Monkey) return;\n\t\n\t  Object.freeze(o);\n\t\n\t  if (!deep) return;\n\t\n\t  if (Array.isArray(o)) {\n\t\n\t    // Iterating through the elements\n\t    var i = undefined,\n\t        l = undefined;\n\t\n\t    for (i = 0, l = o.length; i < l; i++) freezer(true, o[i]);\n\t  } else {\n\t    var p = undefined,\n\t        k = undefined;\n\t\n\t    for (k in o) {\n\t      if (_type2['default'].lazyGetter(o, k)) continue;\n\t\n\t      p = o[k];\n\t\n\t      if (!p || !o.hasOwnProperty(k) || typeof p !== 'object' || Object.isFrozen(p)) continue;\n\t\n\t      freezer(true, p);\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t * Exporting both `freeze` and `deepFreeze` functions.\n\t * Note that if the engine does not support `Object.freeze` then this will\n\t * export noop functions instead.\n\t */\n\tvar isFreezeSupported = typeof Object.freeze === 'function';\n\t\n\tvar freeze = isFreezeSupported ? freezer.bind(null, false) : noop,\n\t    deepFreeze = isFreezeSupported ? freezer.bind(null, true) : noop;\n\t\n\texports.freeze = freeze;\n\texports.deepFreeze = deepFreeze;\n\t\n\t/**\n\t * Function retrieving nested data within the given object and according to\n\t * the given path.\n\t *\n\t * @todo: work if dynamic path hit objects also.\n\t * @todo: memoized perfgetters.\n\t *\n\t * @param  {object}  object - The object we need to get data from.\n\t * @param  {array}   path   - The path to follow.\n\t * @return {object}  result            - The result.\n\t * @return {mixed}   result.data       - The data at path, or `undefined`.\n\t * @return {array}   result.solvedPath - The solved path or `null`.\n\t * @return {boolean} result.exists     - Does the path exists in the tree?\n\t */\n\tvar NOT_FOUND_OBJECT = { data: undefined, solvedPath: null, exists: false };\n\t\n\tfunction getIn(object, path) {\n\t  if (!path) return NOT_FOUND_OBJECT;\n\t\n\t  var solvedPath = [];\n\t\n\t  var exists = true,\n\t      c = object,\n\t      idx = undefined,\n\t      i = undefined,\n\t      l = undefined;\n\t\n\t  for (i = 0, l = path.length; i < l; i++) {\n\t    if (!c) return {\n\t      data: undefined,\n\t      solvedPath: solvedPath.concat(path.slice(i)),\n\t      exists: false\n\t    };\n\t\n\t    if (typeof path[i] === 'function') {\n\t      if (!_type2['default'].array(c)) return NOT_FOUND_OBJECT;\n\t\n\t      idx = index(c, path[i]);\n\t      if (! ~idx) return NOT_FOUND_OBJECT;\n\t\n\t      solvedPath.push(idx);\n\t      c = c[idx];\n\t    } else if (typeof path[i] === 'object') {\n\t      if (!_type2['default'].array(c)) return NOT_FOUND_OBJECT;\n\t\n\t      idx = index(c, function (e) {\n\t        return compare(e, path[i]);\n\t      });\n\t      if (! ~idx) return NOT_FOUND_OBJECT;\n\t\n\t      solvedPath.push(idx);\n\t      c = c[idx];\n\t    } else {\n\t      solvedPath.push(path[i]);\n\t      exists = typeof c === 'object' && path[i] in c;\n\t      c = c[path[i]];\n\t    }\n\t  }\n\t\n\t  return { data: c, solvedPath: solvedPath, exists: exists };\n\t}\n\t\n\t/**\n\t * Little helper returning a JavaScript error carrying some data with it.\n\t *\n\t * @param  {string} message - The error message.\n\t * @param  {object} [data]  - Optional data to assign to the error.\n\t * @return {Error}          - The created error.\n\t */\n\t\n\tfunction makeError(message, data) {\n\t  var err = new Error(message);\n\t\n\t  for (var k in data) {\n\t    err[k] = data[k];\n\t  }return err;\n\t}\n\t\n\t/**\n\t * Function taking n objects to merge them together.\n\t * Note 1): the latter object will take precedence over the first one.\n\t * Note 2): the first object will be mutated to allow for perf scenarios.\n\t * Note 3): this function will consider monkeys as leaves.\n\t *\n\t * @param  {boolean}   deep    - Whether the merge should be deep or not.\n\t * @param  {...object} objects - Objects to merge.\n\t * @return {object}            - The merged object.\n\t */\n\tfunction merger(deep) {\n\t  for (var _len = arguments.length, objects = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t    objects[_key - 1] = arguments[_key];\n\t  }\n\t\n\t  var o = objects[0];\n\t\n\t  var t = undefined,\n\t      i = undefined,\n\t      l = undefined,\n\t      k = undefined;\n\t\n\t  for (i = 1, l = objects.length; i < l; i++) {\n\t    t = objects[i];\n\t\n\t    for (k in t) {\n\t      if (deep && _type2['default'].object(t[k]) && !(t[k] instanceof _monkey.Monkey)) {\n\t        o[k] = merger(true, o[k] || {}, t[k]);\n\t      } else {\n\t        o[k] = t[k];\n\t      }\n\t    }\n\t  }\n\t\n\t  return o;\n\t}\n\t\n\t/**\n\t * Exporting both `shallowMerge` and `deepMerge` functions.\n\t */\n\tvar shallowMerge = merger.bind(null, false),\n\t    deepMerge = merger.bind(null, true);\n\t\n\texports.shallowMerge = shallowMerge;\n\texports.deepMerge = deepMerge;\n\t\n\t/**\n\t * Solving a potentially relative path.\n\t *\n\t * @param  {array} base - The base path from which to solve the path.\n\t * @param  {array} to   - The subpath to reach.\n\t * @param  {array}      - The solved absolute path.\n\t */\n\t\n\tfunction solveRelativePath(base, to) {\n\t  var solvedPath = [];\n\t\n\t  // Coercing to array\n\t  to = [].concat(to);\n\t\n\t  for (var i = 0, l = to.length; i < l; i++) {\n\t    var step = to[i];\n\t\n\t    if (step === '.') {\n\t      if (!i) solvedPath = base.slice(0);\n\t    } else if (step === '..') {\n\t      solvedPath = (!i ? base : solvedPath).slice(0, -1);\n\t    } else {\n\t      solvedPath.push(step);\n\t    }\n\t  }\n\t\n\t  return solvedPath;\n\t}\n\t\n\t/**\n\t * Function determining whether some paths in the tree were affected by some\n\t * updates that occurred at the given paths. This helper is mainly used at\n\t * cursor level to determine whether the cursor is concerned by the updates\n\t * fired at tree level.\n\t *\n\t * NOTES: 1) If performance become an issue, the following threefold loop\n\t *           can be simplified to a complex twofold one.\n\t *        2) A regex version could also work but I am not confident it would\n\t *           be faster.\n\t *        3) Another solution would be to keep a register of cursors like with\n\t *           the monkeys and update along this tree.\n\t *\n\t * @param  {array} affectedPaths - The paths that were updated.\n\t * @param  {array} comparedPaths - The paths that we are actually interested in.\n\t * @return {boolean}             - Is the update relevant to the compared\n\t *                                 paths?\n\t */\n\t\n\tfunction solveUpdate(affectedPaths, comparedPaths) {\n\t  var i = undefined,\n\t      j = undefined,\n\t      k = undefined,\n\t      l = undefined,\n\t      m = undefined,\n\t      n = undefined,\n\t      p = undefined,\n\t      c = undefined,\n\t      s = undefined;\n\t\n\t  // Looping through possible paths\n\t  for (i = 0, l = affectedPaths.length; i < l; i++) {\n\t    p = affectedPaths[i];\n\t\n\t    if (!p.length) return true;\n\t\n\t    // Looping through logged paths\n\t    for (j = 0, m = comparedPaths.length; j < m; j++) {\n\t      c = comparedPaths[j];\n\t\n\t      if (!c || !c.length) return true;\n\t\n\t      // Looping through steps\n\t      for (k = 0, n = c.length; k < n; k++) {\n\t        s = c[k];\n\t\n\t        // If path is not relevant, we break\n\t        // NOTE: the '!=' instead of '!==' is required here!\n\t        if (s != p[k]) break;\n\t\n\t        // If we reached last item and we are relevant\n\t        if (k + 1 === n || k + 1 === p.length) return true;\n\t      }\n\t    }\n\t  }\n\t\n\t  return false;\n\t}\n\t\n\t/**\n\t * Non-mutative version of the splice array method.\n\t *\n\t * @param  {array}    array        - The array to splice.\n\t * @param  {integer}  startIndex   - The start index.\n\t * @param  {integer}  nb           - Number of elements to remove.\n\t * @param  {...mixed} elements     - Elements to append after splicing.\n\t * @return {array}                 - The spliced array.\n\t */\n\t\n\tfunction splice(array, startIndex, nb) {\n\t  nb = Math.max(0, nb);\n\t\n\t  // Solving startIndex\n\t  if (_type2['default']['function'](startIndex)) startIndex = index(array, startIndex);\n\t  if (_type2['default'].object(startIndex)) startIndex = index(array, function (e) {\n\t    return compare(e, startIndex);\n\t  });\n\t\n\t  // Positive index\n\t\n\t  for (var _len2 = arguments.length, elements = Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {\n\t    elements[_key2 - 3] = arguments[_key2];\n\t  }\n\t\n\t  if (startIndex >= 0) return array.slice(0, startIndex).concat(elements).concat(array.slice(startIndex + nb));\n\t\n\t  // Negative index\n\t  return array.slice(0, array.length + startIndex).concat(elements).concat(array.slice(array.length + startIndex + nb));\n\t}\n\t\n\t/**\n\t * Function returning a unique incremental id each time it is called.\n\t *\n\t * @return {integer} - The latest unique id.\n\t */\n\tvar uniqid = (function () {\n\t  var i = 0;\n\t\n\t  return function () {\n\t    return i++;\n\t  };\n\t})();\n\t\n\texports.uniqid = uniqid;\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 18 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Baobab Watchers\n\t * ================\n\t *\n\t * Abstraction used to listen and retrieve data from multiple parts of a\n\t * Baobab tree at once.\n\t */\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\t\n\tvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\t\n\tvar _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar _emmett = __webpack_require__(12);\n\t\n\tvar _emmett2 = _interopRequireDefault(_emmett);\n\t\n\tvar _cursor = __webpack_require__(13);\n\t\n\tvar _cursor2 = _interopRequireDefault(_cursor);\n\t\n\tvar _type = __webpack_require__(15);\n\t\n\tvar _type2 = _interopRequireDefault(_type);\n\t\n\tvar _helpers = __webpack_require__(17);\n\t\n\t/**\n\t * Watcher class.\n\t *\n\t * @constructor\n\t * @param {Baobab} tree     - The watched tree.\n\t * @param {object} mapping  - A mapping of the paths to watch in the tree.\n\t */\n\t\n\tvar Watcher = (function (_Emitter) {\n\t  _inherits(Watcher, _Emitter);\n\t\n\t  function Watcher(tree, mapping) {\n\t    var _this = this;\n\t\n\t    _classCallCheck(this, Watcher);\n\t\n\t    _get(Object.getPrototypeOf(Watcher.prototype), 'constructor', this).call(this);\n\t\n\t    // Properties\n\t    this.tree = tree;\n\t    this.mapping = null;\n\t\n\t    this.state = {\n\t      killed: false\n\t    };\n\t\n\t    // Initializing\n\t    this.refresh(mapping);\n\t\n\t    // Listening\n\t    this.handler = function (e) {\n\t      if (_this.state.killed) return;\n\t\n\t      var watchedPaths = _this.getWatchedPaths();\n\t\n\t      if ((0, _helpers.solveUpdate)(e.data.paths, watchedPaths)) return _this.emit('update');\n\t    };\n\t\n\t    this.tree.on('update', this.handler);\n\t  }\n\t\n\t  /**\n\t   * Method used to get the current watched paths.\n\t   *\n\t   * @return {array} - The array of watched paths.\n\t   */\n\t\n\t  _createClass(Watcher, [{\n\t    key: 'getWatchedPaths',\n\t    value: function getWatchedPaths() {\n\t      var _this2 = this;\n\t\n\t      var rawPaths = Object.keys(this.mapping).map(function (k) {\n\t        var v = _this2.mapping[k];\n\t\n\t        // Watcher mappings can accept a cursor\n\t        if (v instanceof _cursor2['default']) return v.solvedPath;\n\t\n\t        return _this2.mapping[k];\n\t      });\n\t\n\t      return rawPaths.reduce(function (cp, p) {\n\t\n\t        // Handling path polymorphisms\n\t        p = [].concat(p);\n\t\n\t        // Dynamic path?\n\t        if (_type2['default'].dynamicPath(p)) p = (0, _helpers.getIn)(_this2.tree._data, p).solvedPath;\n\t\n\t        if (!p) return cp;\n\t\n\t        // Facet path?\n\t        var monkeyPath = _type2['default'].monkeyPath(_this2.tree._monkeys, p);\n\t\n\t        if (monkeyPath) return cp.concat((0, _helpers.getIn)(_this2.tree._monkeys, monkeyPath).data.relatedPaths());\n\t\n\t        return cp.concat([p]);\n\t      }, []);\n\t    }\n\t\n\t    /**\n\t     * Method used to return a map of the watcher's cursors.\n\t     *\n\t     * @return {object} - TMap of relevant cursors.\n\t     */\n\t  }, {\n\t    key: 'getCursors',\n\t    value: function getCursors() {\n\t      var _this3 = this;\n\t\n\t      var cursors = {};\n\t\n\t      Object.keys(this.mapping).forEach(function (k) {\n\t        var path = _this3.mapping[k];\n\t\n\t        if (path instanceof _cursor2['default']) cursors[k] = path;else cursors[k] = _this3.tree.select(path);\n\t      });\n\t\n\t      return cursors;\n\t    }\n\t\n\t    /**\n\t     * Method used to refresh the watcher's mapping.\n\t     *\n\t     * @param  {object}  mapping  - The new mapping to apply.\n\t     * @return {Watcher}          - Itself for chaining purposes.\n\t     */\n\t  }, {\n\t    key: 'refresh',\n\t    value: function refresh(mapping) {\n\t\n\t      if (!_type2['default'].watcherMapping(mapping)) throw (0, _helpers.makeError)('Baobab.watch: invalid mapping.', { mapping: mapping });\n\t\n\t      this.mapping = mapping;\n\t\n\t      // Creating the get method\n\t      var projection = {};\n\t\n\t      for (var k in mapping) {\n\t        projection[k] = mapping[k] instanceof _cursor2['default'] ? mapping[k].path : mapping[k];\n\t      }this.get = this.tree.project.bind(this.tree, projection);\n\t    }\n\t\n\t    /**\n\t     * Methods releasing the watcher from memory.\n\t     */\n\t  }, {\n\t    key: 'release',\n\t    value: function release() {\n\t\n\t      this.tree.off('update', this.handler);\n\t      this.state.killed = true;\n\t      this.kill();\n\t    }\n\t  }]);\n\t\n\t  return Watcher;\n\t})(_emmett2['default']);\n\t\n\texports['default'] = Watcher;\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 19 */\n/***/ function(module, exports) {\n\n\tmodule.exports = \"<ion-modal-view> <ion-header-bar> <h1 class=title>Modal Title</h1> </ion-header-bar> <ion-content> <button class=\\\"button icon icon-left ion-ios-close-outline\\\" ng-click=closeModal()>Close Modal</button> </ion-content> </ion-modal-view>\";\n\n/***/ },\n/* 20 */\n/***/ function(module, exports) {\n\n\tmodule.exports = \"<ion-view view-title=Dashboard> <ion-nav-title> WEATHER GONG </ion-nav-title> <ion-content class=padding id=dashboard-page-container> <div class=current-weather-container> <div class=\\\"row header\\\"> <div class=col> </div> <div class=col></div> <div class=col></div> <div class=col> </div> <div class=col></div> <div class=col>'</div> <div class=col> </div> <div class=col></div> <div class=col></div> </div> <div class=row ng-repeat=\\\"row in currentData\\\"> <div class=col> <button class=\\\"icon ion-ios-minus-outline\\\"></button> </div> <div class=col>{{ row.location }}</div> <div class=col>{{ row.time }}</div> <div class=col>{{ row.wind }}</div> <div class=col>{{ row.windDirection }}</div> <div class=col>{{ row.temperature }}</div> <div class=col>{{ row.wave }}</div> <div class=col>{{ row.waveDirection }}</div> <div class=col> <button class=\\\"icon ion-ios-camera-outline\\\"/></div> </div> <div class=row> <div class=col> <button class=\\\"button icon ion-ios-plus-outline\\\" ng-click=addLocation()></button> </div> </div> </div> <div class=forecast-container> <h3> ( )</h3> <div class=\\\"row header\\\"> <div class=col> </div> <div class=col></div> <div class=col></div> <div class=col></div> <div class=col></div> <div class=col>'</div> <div class=col> </div> <div class=col></div> <div class=col></div> </div> <div class=row ng-repeat=\\\"row in forecastData\\\"> <div class=col> <button class=\\\"icon ion-ios-minus-outline\\\"></button> </div> <div class=col>{{ row.location }}</div> <div class=col>{{ row.time }}</div> <div class=col>{{ row.wind }}</div> <div class=col>{{ row.windDirection }}</div> <div class=col>{{ row.temperature }}</div> <div class=col>{{ row.wave }}</div> <div class=col>{{ row.waveDirection }}</div> </div> <div class=row> <div class=col> <button class=\\\"button icon ion-ios-plus-outline\\\" ng-click=addLocation()></button> </div> </div> </div> </ion-content> </ion-view>\";\n\n/***/ },\n/* 21 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// style-loader: Adds some css to the DOM by adding a <style> tag\n\t\n\t// load the styles\n\tvar content = __webpack_require__(22);\n\tif(typeof content === 'string') content = [[module.id, content, '']];\n\t// add the styles to the DOM\n\tvar update = __webpack_require__(24)(content, {});\n\tif(content.locals) module.exports = content.locals;\n\t// Hot Module Replacement\n\tif(false) {\n\t\t// When the styles change, update the <style> tags\n\t\tif(!content.locals) {\n\t\t\tmodule.hot.accept(\"!!./../../../../node_modules/css-loader/index.js!./../../../../node_modules/sass-loader/index.js!./dashboard.scss\", function() {\n\t\t\t\tvar newContent = require(\"!!./../../../../node_modules/css-loader/index.js!./../../../../node_modules/sass-loader/index.js!./dashboard.scss\");\n\t\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\t\tupdate(newContent);\n\t\t\t});\n\t\t}\n\t\t// When the module is disposed, remove the <style> tags\n\t\tmodule.hot.dispose(function() { update(); });\n\t}\n\n/***/ },\n/* 22 */\n/***/ function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(23)();\n\t// imports\n\t\n\t\n\t// module\n\texports.push([module.id, \"#dashboard-page-container .scroll>div{margin-bottom:60px}#dashboard-page-container .scroll>div .col{text-align:right}#dashboard-page-container .scroll>div .col button.icon{font-size:21px;line-height:0;background:none;padding:0;margin:0;outline:0;border:none}\", \"\"]);\n\t\n\t// exports\n\n\n/***/ },\n/* 23 */\n/***/ function(module, exports) {\n\n\t/*\r\n\t\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\t\tAuthor Tobias Koppers @sokra\r\n\t*/\r\n\t// css base code, injected by the css-loader\r\n\tmodule.exports = function() {\r\n\t\tvar list = [];\r\n\t\r\n\t\t// return the list of modules as css string\r\n\t\tlist.toString = function toString() {\r\n\t\t\tvar result = [];\r\n\t\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\t\tvar item = this[i];\r\n\t\t\t\tif(item[2]) {\r\n\t\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\r\n\t\t\t\t} else {\r\n\t\t\t\t\tresult.push(item[1]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn result.join(\"\");\r\n\t\t};\r\n\t\r\n\t\t// import a list of modules into the list\r\n\t\tlist.i = function(modules, mediaQuery) {\r\n\t\t\tif(typeof modules === \"string\")\r\n\t\t\t\tmodules = [[null, modules, \"\"]];\r\n\t\t\tvar alreadyImportedModules = {};\r\n\t\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\t\tvar id = this[i][0];\r\n\t\t\t\tif(typeof id === \"number\")\r\n\t\t\t\t\talreadyImportedModules[id] = true;\r\n\t\t\t}\r\n\t\t\tfor(i = 0; i < modules.length; i++) {\r\n\t\t\t\tvar item = modules[i];\r\n\t\t\t\t// skip already imported module\r\n\t\t\t\t// this implementation is not 100% perfect for weird media query combinations\r\n\t\t\t\t//  when a module is imported multiple times with different media queries.\r\n\t\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\r\n\t\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\r\n\t\t\t\t\tif(mediaQuery && !item[2]) {\r\n\t\t\t\t\t\titem[2] = mediaQuery;\r\n\t\t\t\t\t} else if(mediaQuery) {\r\n\t\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\r\n\t\t\t\t\t}\r\n\t\t\t\t\tlist.push(item);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t\treturn list;\r\n\t};\r\n\n\n/***/ },\n/* 24 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*\r\n\t\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\t\tAuthor Tobias Koppers @sokra\r\n\t*/\r\n\tvar stylesInDom = {},\r\n\t\tmemoize = function(fn) {\r\n\t\t\tvar memo;\r\n\t\t\treturn function () {\r\n\t\t\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\r\n\t\t\t\treturn memo;\r\n\t\t\t};\r\n\t\t},\r\n\t\tisOldIE = memoize(function() {\r\n\t\t\treturn /msie [6-9]\\b/.test(window.navigator.userAgent.toLowerCase());\r\n\t\t}),\r\n\t\tgetHeadElement = memoize(function () {\r\n\t\t\treturn document.head || document.getElementsByTagName(\"head\")[0];\r\n\t\t}),\r\n\t\tsingletonElement = null,\r\n\t\tsingletonCounter = 0,\r\n\t\tstyleElementsInsertedAtTop = [];\r\n\t\r\n\tmodule.exports = function(list, options) {\r\n\t\tif(true) {\r\n\t\t\tif(typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\r\n\t\t}\r\n\t\r\n\t\toptions = options || {};\r\n\t\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\r\n\t\t// tags it will allow on a page\r\n\t\tif (typeof options.singleton === \"undefined\") options.singleton = isOldIE();\r\n\t\r\n\t\t// By default, add <style> tags to the bottom of <head>.\r\n\t\tif (typeof options.insertAt === \"undefined\") options.insertAt = \"bottom\";\r\n\t\r\n\t\tvar styles = listToStyles(list);\r\n\t\taddStylesToDom(styles, options);\r\n\t\r\n\t\treturn function update(newList) {\r\n\t\t\tvar mayRemove = [];\r\n\t\t\tfor(var i = 0; i < styles.length; i++) {\r\n\t\t\t\tvar item = styles[i];\r\n\t\t\t\tvar domStyle = stylesInDom[item.id];\r\n\t\t\t\tdomStyle.refs--;\r\n\t\t\t\tmayRemove.push(domStyle);\r\n\t\t\t}\r\n\t\t\tif(newList) {\r\n\t\t\t\tvar newStyles = listToStyles(newList);\r\n\t\t\t\taddStylesToDom(newStyles, options);\r\n\t\t\t}\r\n\t\t\tfor(var i = 0; i < mayRemove.length; i++) {\r\n\t\t\t\tvar domStyle = mayRemove[i];\r\n\t\t\t\tif(domStyle.refs === 0) {\r\n\t\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++)\r\n\t\t\t\t\t\tdomStyle.parts[j]();\r\n\t\t\t\t\tdelete stylesInDom[domStyle.id];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n\t\r\n\tfunction addStylesToDom(styles, options) {\r\n\t\tfor(var i = 0; i < styles.length; i++) {\r\n\t\t\tvar item = styles[i];\r\n\t\t\tvar domStyle = stylesInDom[item.id];\r\n\t\t\tif(domStyle) {\r\n\t\t\t\tdomStyle.refs++;\r\n\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\r\n\t\t\t\t\tdomStyle.parts[j](item.parts[j]);\r\n\t\t\t\t}\r\n\t\t\t\tfor(; j < item.parts.length; j++) {\r\n\t\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tvar parts = [];\r\n\t\t\t\tfor(var j = 0; j < item.parts.length; j++) {\r\n\t\t\t\t\tparts.push(addStyle(item.parts[j], options));\r\n\t\t\t\t}\r\n\t\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction listToStyles(list) {\r\n\t\tvar styles = [];\r\n\t\tvar newStyles = {};\r\n\t\tfor(var i = 0; i < list.length; i++) {\r\n\t\t\tvar item = list[i];\r\n\t\t\tvar id = item[0];\r\n\t\t\tvar css = item[1];\r\n\t\t\tvar media = item[2];\r\n\t\t\tvar sourceMap = item[3];\r\n\t\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\r\n\t\t\tif(!newStyles[id])\r\n\t\t\t\tstyles.push(newStyles[id] = {id: id, parts: [part]});\r\n\t\t\telse\r\n\t\t\t\tnewStyles[id].parts.push(part);\r\n\t\t}\r\n\t\treturn styles;\r\n\t}\r\n\t\r\n\tfunction insertStyleElement(options, styleElement) {\r\n\t\tvar head = getHeadElement();\r\n\t\tvar lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];\r\n\t\tif (options.insertAt === \"top\") {\r\n\t\t\tif(!lastStyleElementInsertedAtTop) {\r\n\t\t\t\thead.insertBefore(styleElement, head.firstChild);\r\n\t\t\t} else if(lastStyleElementInsertedAtTop.nextSibling) {\r\n\t\t\t\thead.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);\r\n\t\t\t} else {\r\n\t\t\t\thead.appendChild(styleElement);\r\n\t\t\t}\r\n\t\t\tstyleElementsInsertedAtTop.push(styleElement);\r\n\t\t} else if (options.insertAt === \"bottom\") {\r\n\t\t\thead.appendChild(styleElement);\r\n\t\t} else {\r\n\t\t\tthrow new Error(\"Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.\");\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction removeStyleElement(styleElement) {\r\n\t\tstyleElement.parentNode.removeChild(styleElement);\r\n\t\tvar idx = styleElementsInsertedAtTop.indexOf(styleElement);\r\n\t\tif(idx >= 0) {\r\n\t\t\tstyleElementsInsertedAtTop.splice(idx, 1);\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction createStyleElement(options) {\r\n\t\tvar styleElement = document.createElement(\"style\");\r\n\t\tstyleElement.type = \"text/css\";\r\n\t\tinsertStyleElement(options, styleElement);\r\n\t\treturn styleElement;\r\n\t}\r\n\t\r\n\tfunction createLinkElement(options) {\r\n\t\tvar linkElement = document.createElement(\"link\");\r\n\t\tlinkElement.rel = \"stylesheet\";\r\n\t\tinsertStyleElement(options, linkElement);\r\n\t\treturn linkElement;\r\n\t}\r\n\t\r\n\tfunction addStyle(obj, options) {\r\n\t\tvar styleElement, update, remove;\r\n\t\r\n\t\tif (options.singleton) {\r\n\t\t\tvar styleIndex = singletonCounter++;\r\n\t\t\tstyleElement = singletonElement || (singletonElement = createStyleElement(options));\r\n\t\t\tupdate = applyToSingletonTag.bind(null, styleElement, styleIndex, false);\r\n\t\t\tremove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);\r\n\t\t} else if(obj.sourceMap &&\r\n\t\t\ttypeof URL === \"function\" &&\r\n\t\t\ttypeof URL.createObjectURL === \"function\" &&\r\n\t\t\ttypeof URL.revokeObjectURL === \"function\" &&\r\n\t\t\ttypeof Blob === \"function\" &&\r\n\t\t\ttypeof btoa === \"function\") {\r\n\t\t\tstyleElement = createLinkElement(options);\r\n\t\t\tupdate = updateLink.bind(null, styleElement);\r\n\t\t\tremove = function() {\r\n\t\t\t\tremoveStyleElement(styleElement);\r\n\t\t\t\tif(styleElement.href)\r\n\t\t\t\t\tURL.revokeObjectURL(styleElement.href);\r\n\t\t\t};\r\n\t\t} else {\r\n\t\t\tstyleElement = createStyleElement(options);\r\n\t\t\tupdate = applyToTag.bind(null, styleElement);\r\n\t\t\tremove = function() {\r\n\t\t\t\tremoveStyleElement(styleElement);\r\n\t\t\t};\r\n\t\t}\r\n\t\r\n\t\tupdate(obj);\r\n\t\r\n\t\treturn function updateStyle(newObj) {\r\n\t\t\tif(newObj) {\r\n\t\t\t\tif(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)\r\n\t\t\t\t\treturn;\r\n\t\t\t\tupdate(obj = newObj);\r\n\t\t\t} else {\r\n\t\t\t\tremove();\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n\t\r\n\tvar replaceText = (function () {\r\n\t\tvar textStore = [];\r\n\t\r\n\t\treturn function (index, replacement) {\r\n\t\t\ttextStore[index] = replacement;\r\n\t\t\treturn textStore.filter(Boolean).join('\\n');\r\n\t\t};\r\n\t})();\r\n\t\r\n\tfunction applyToSingletonTag(styleElement, index, remove, obj) {\r\n\t\tvar css = remove ? \"\" : obj.css;\r\n\t\r\n\t\tif (styleElement.styleSheet) {\r\n\t\t\tstyleElement.styleSheet.cssText = replaceText(index, css);\r\n\t\t} else {\r\n\t\t\tvar cssNode = document.createTextNode(css);\r\n\t\t\tvar childNodes = styleElement.childNodes;\r\n\t\t\tif (childNodes[index]) styleElement.removeChild(childNodes[index]);\r\n\t\t\tif (childNodes.length) {\r\n\t\t\t\tstyleElement.insertBefore(cssNode, childNodes[index]);\r\n\t\t\t} else {\r\n\t\t\t\tstyleElement.appendChild(cssNode);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction applyToTag(styleElement, obj) {\r\n\t\tvar css = obj.css;\r\n\t\tvar media = obj.media;\r\n\t\r\n\t\tif(media) {\r\n\t\t\tstyleElement.setAttribute(\"media\", media)\r\n\t\t}\r\n\t\r\n\t\tif(styleElement.styleSheet) {\r\n\t\t\tstyleElement.styleSheet.cssText = css;\r\n\t\t} else {\r\n\t\t\twhile(styleElement.firstChild) {\r\n\t\t\t\tstyleElement.removeChild(styleElement.firstChild);\r\n\t\t\t}\r\n\t\t\tstyleElement.appendChild(document.createTextNode(css));\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction updateLink(linkElement, obj) {\r\n\t\tvar css = obj.css;\r\n\t\tvar sourceMap = obj.sourceMap;\r\n\t\r\n\t\tif(sourceMap) {\r\n\t\t\t// http://stackoverflow.com/a/26603875\r\n\t\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\r\n\t\t}\r\n\t\r\n\t\tvar blob = new Blob([css], { type: \"text/css\" });\r\n\t\r\n\t\tvar oldSrc = linkElement.href;\r\n\t\r\n\t\tlinkElement.href = URL.createObjectURL(blob);\r\n\t\r\n\t\tif(oldSrc)\r\n\t\t\tURL.revokeObjectURL(oldSrc);\r\n\t}\r\n\n\n/***/ },\n/* 25 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\texports.default = function ($stateProvider, $urlRouterProvider) {\n\t    $stateProvider\n\t\n\t    // setup an abstract state for the tabs directive\n\t    .state('tab', {\n\t        url: '/tab',\n\t        abstract: true,\n\t        template: __webpack_require__(26)\n\t    });\n\t};\n\n/***/ },\n/* 26 */\n/***/ function(module, exports) {\n\n\tmodule.exports = \"<ion-tabs class=\\\"tabs-icon-top tabs-color-active-positive\\\"> <ion-tab icon-off=ion-ios-home icon-on=ion-ios-home href=#/tab/dash> <ion-nav-view name=tab-dash></ion-nav-view> </ion-tab> <ion-tab title= href=#/tab/chats> <ion-nav-view name=tab-chats></ion-nav-view> </ion-tab> <ion-tab title=\\\" \\\" href=#/tab/account> <ion-nav-view name=tab-account></ion-nav-view> </ion-tab> <ion-tab title=\\\" \\\" href=#/tab/account> <ion-nav-view name=tab-account></ion-nav-view> </ion-tab> </ion-tabs>\";\n\n/***/ },\n/* 27 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// style-loader: Adds some css to the DOM by adding a <style> tag\n\t\n\t// load the styles\n\tvar content = __webpack_require__(28);\n\tif(typeof content === 'string') content = [[module.id, content, '']];\n\t// add the styles to the DOM\n\tvar update = __webpack_require__(24)(content, {});\n\tif(content.locals) module.exports = content.locals;\n\t// Hot Module Replacement\n\tif(false) {\n\t\t// When the styles change, update the <style> tags\n\t\tif(!content.locals) {\n\t\t\tmodule.hot.accept(\"!!./../../../node_modules/css-loader/index.js!./../../../node_modules/sass-loader/index.js!./tabs.scss\", function() {\n\t\t\t\tvar newContent = require(\"!!./../../../node_modules/css-loader/index.js!./../../../node_modules/sass-loader/index.js!./tabs.scss\");\n\t\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\t\tupdate(newContent);\n\t\t\t});\n\t\t}\n\t\t// When the module is disposed, remove the <style> tags\n\t\tmodule.hot.dispose(function() { update(); });\n\t}\n\n/***/ },\n/* 28 */\n/***/ function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(23)();\n\t// imports\n\t\n\t\n\t// module\n\texports.push([module.id, \".tabs-icon-top>.tabs .tab-item{line-height:40px;font-size:15px}\", \"\"]);\n\t\n\t// exports\n\n\n/***/ },\n/* 29 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// style-loader: Adds some css to the DOM by adding a <style> tag\n\t\n\t// load the styles\n\tvar content = __webpack_require__(30);\n\tif(typeof content === 'string') content = [[module.id, content, '']];\n\t// add the styles to the DOM\n\tvar update = __webpack_require__(24)(content, {});\n\tif(content.locals) module.exports = content.locals;\n\t// Hot Module Replacement\n\tif(false) {\n\t\t// When the styles change, update the <style> tags\n\t\tif(!content.locals) {\n\t\t\tmodule.hot.accept(\"!!./../../node_modules/css-loader/index.js!./../../node_modules/sass-loader/index.js!./index.scss\", function() {\n\t\t\t\tvar newContent = require(\"!!./../../node_modules/css-loader/index.js!./../../node_modules/sass-loader/index.js!./index.scss\");\n\t\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\t\tupdate(newContent);\n\t\t\t});\n\t\t}\n\t\t// When the module is disposed, remove the <style> tags\n\t\tmodule.hot.dispose(function() { update(); });\n\t}\n\n/***/ },\n/* 30 */\n/***/ function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(23)();\n\t// imports\n\t\n\t\n\t// module\n\texports.push([module.id, \"body{direction:rtl}\", \"\"]);\n\t\n\t// exports\n\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** bundle.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 1ddeeeffac90dc673408\n **/","import components from './components';\r\nimport './scss/index.scss';\r\nangular.module('app', ['ionic', components])\r\n.run(function($ionicPlatform) {\r\n    $ionicPlatform.ready(function() {\r\n        // Hide the accessory bar by default (remove this to show the accessory bar above the keyboard\r\n        // for form inputs)\r\n        if (window.cordova && window.cordova.plugins && window.cordova.plugins.Keyboard) {\r\n            cordova.plugins.Keyboard.hideKeyboardAccessoryBar(true);\r\n            cordova.plugins.Keyboard.disableScroll(true);\r\n\r\n        }\r\n        if (window.StatusBar) {\r\n            // org.apache.cordova.statusbar required\r\n            StatusBar.styleDefault();\r\n        }\r\n    });\r\n}).config(function($stateProvider, $urlRouterProvider) {\r\n    $urlRouterProvider.otherwise('/tab/dash');\r\n});\n\n\n/** WEBPACK FOOTER **\n ** ./app/index.js\n **/","import tabs from './tabs';\r\n\r\nexport default angular.module('app.components', [tabs])\r\n  .name;\n\n\n/** WEBPACK FOOTER **\n ** ./app/components/index.js\n **/","import dashboard from './dashboard';\r\nimport routing from './tabs.route';\r\nimport './tabs.scss';\r\nexport default angular.module('app.components.tabs', [dashboard])\r\n  .config(routing)\r\n  .name;\n\n\n/** WEBPACK FOOTER **\n ** ./app/components/tabs/index.js\n **/","import routing from './dashboard.route';\r\nimport './dashboard.scss';\r\n\r\nexport default angular.module('app.components.tabs.dashboard', [])\r\n  .config(routing)\r\n  .name;\n\n\n/** WEBPACK FOOTER **\n ** ./app/components/tabs/dashboard/index.js\n **/","import controller from './dashboard.controller';\r\nimport template from './dashboard.html';\r\n\r\nexport default ($stateProvider, $urlRouterProvider) => {\r\n    $stateProvider\r\n        .state('tab.dash', {\r\n            url: '/dash',\r\n            views: {\r\n                'tab-dash': {\r\n                    template,\r\n                    controller\r\n                }\r\n            }\r\n        })\r\n}\n\n\n/** WEBPACK FOOTER **\n ** ./app/components/tabs/dashboard/dashboard.route.js\n **/","import tree from '../../../store';\r\nvar locationModalTemplate = require('./locationModal.html');\r\nconst connectSubscriptions = (data, scope, $timeout) => {\r\n    let hashKey = 0;\r\n    $timeout(() => {\r\n        var _data = data.reduce((curr, next) => {\r\n            return Object.assign(curr, { [hashKey++]: next });\r\n        }, {});\r\n        scope.currentData = scope.forecastData = _data;\r\n    });\r\n}\r\n\r\nexport default ['$scope', '$timeout', '$ionicModal',\r\n    (scope, $timeout, $ionicModal) => {\r\n        const subscriptionSelector = tree.select('subscriptions', 'subscribedLocations');\r\n        connectSubscriptions(subscriptionSelector.get(), scope, $timeout);\r\n        subscriptionSelector.on('update', function (e) {\r\n            connectSubscriptions(e.data.currentData, scope, $timeout);\r\n        });\r\n\r\n        scope.modal = $ionicModal.fromTemplate(locationModalTemplate, {\r\n            scope,\r\n            animation: 'slide-in-up'\r\n        });\r\n    \r\n        scope.addLocation = function(){\r\n            scope.modal.show();\r\n        }\r\n\r\n        scope.closeModal = function() {\r\n            scope.modal.hide();\r\n        };\r\n    }]\n\n\n/** WEBPACK FOOTER **\n ** ./app/components/tabs/dashboard/dashboard.controller.js\n **/","import { default_subscriptions } from './consts';\r\nimport subscript_data_monkey from './monkeys/subscriptionData';\r\n\r\nvar Baobab = require('baobab');\r\n\r\nexport default new Baobab({\r\n    locations: {\r\n\r\n    },\r\n    subscriptions: {\r\n        ids: window.localStorage.getItem(\"subscriptions\") || default_subscriptions,\r\n        locations_data: [],\r\n        subscribedLocations: subscript_data_monkey\r\n    }\r\n});\n\n\n/** WEBPACK FOOTER **\n ** ./app/store/index.js\n **/","export const default_subscriptions = [1,2];\n\n\n/** WEBPACK FOOTER **\n ** ./app/store/consts.js\n **/","\r\nvar Baobab = require('baobab');\r\nvar monkey = Baobab.monkey;\r\nimport loadSubscriptions from './loaders/subscriptionData';\r\nexport default monkey({\r\n    cursors: {\r\n        ids: ['subscriptions', 'ids'],\r\n        locations: ['subscriptions', 'locations_data']\r\n    },\r\n    get: function (state) {\r\n        const result = state.ids.map((id) => {\r\n            debugger;\r\n            let data = state.locations_data[id];\r\n            return data || { id, loading: true };\r\n        });     \r\n        loadSubscriptions(result.filter((r) => r.loading));   \r\n        return result;\r\n    }\r\n});\r\n\r\n\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./app/store/monkeys/subscriptionData.js\n **/","import tree from '../../index.js';\r\nimport config from '../../../config';\r\n\r\nexport default (ids) => {\r\n    if (ids.length == 0)\r\n        return null;\r\n    let dataSelector = tree.select('subscriptions', 'locations_data');\r\n    fetch(`${config.apiUrl}/getSubscriptions`, {\r\n        method: 'POST',\r\n        body: JSON.stringify({ ids })\r\n    })\r\n        .then((response) => response.json())\r\n        .then((data) => {\r\n            data.forEach((d) => {\r\n                dataSelector.set(d.id, d);\r\n            });\r\n        });\r\n}\n\n\n/** WEBPACK FOOTER **\n ** ./app/store/monkeys/loaders/subscriptionData.js\n **/","export default {\r\n    apiUrl: 'http://some.url.to.api'\r\n}\n\n\n/** WEBPACK FOOTER **\n ** ./app/config.js\n **/","/**\n * Baobab Data Structure\n * ======================\n *\n * A handy data tree with cursors.\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nvar _get = function get(_x3, _x4, _x5) { var _again = true; _function: while (_again) { var object = _x3, property = _x4, receiver = _x5; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x3 = parent; _x4 = property; _x5 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _emmett = require('emmett');\n\nvar _emmett2 = _interopRequireDefault(_emmett);\n\nvar _cursor = require('./cursor');\n\nvar _cursor2 = _interopRequireDefault(_cursor);\n\nvar _monkey = require('./monkey');\n\nvar _watcher = require('./watcher');\n\nvar _watcher2 = _interopRequireDefault(_watcher);\n\nvar _type = require('./type');\n\nvar _type2 = _interopRequireDefault(_type);\n\nvar _update2 = require('./update');\n\nvar _update3 = _interopRequireDefault(_update2);\n\nvar _helpers = require('./helpers');\n\nvar helpers = _interopRequireWildcard(_helpers);\n\nvar arrayFrom = helpers.arrayFrom;\nvar coercePath = helpers.coercePath;\nvar deepFreeze = helpers.deepFreeze;\nvar getIn = helpers.getIn;\nvar makeError = helpers.makeError;\nvar deepClone = helpers.deepClone;\nvar deepMerge = helpers.deepMerge;\nvar shallowClone = helpers.shallowClone;\nvar shallowMerge = helpers.shallowMerge;\nvar uniqid = helpers.uniqid;\n\n/**\n * Baobab defaults\n */\nvar DEFAULTS = {\n\n  // Should the tree handle its transactions on its own?\n  autoCommit: true,\n\n  // Should the transactions be handled asynchronously?\n  asynchronous: true,\n\n  // Should the tree's data be immutable?\n  immutable: true,\n\n  // Should the monkeys be lazy?\n  lazyMonkeys: true,\n\n  // Should the tree be persistent?\n  persistent: true,\n\n  // Should the tree's update be pure?\n  pure: true,\n\n  // Validation specifications\n  validate: null,\n\n  // Validation behavior 'rollback' or 'notify'\n  validationBehavior: 'rollback'\n};\n\n/**\n * Function returning a string hash from a non-dynamic path expressed as an\n * array.\n *\n * @param  {array}  path - The path to hash.\n * @return {string} string - The resultant hash.\n */\nfunction hashPath(path) {\n  return '' + path.map(function (step) {\n    if (_type2['default']['function'](step) || _type2['default'].object(step)) return '#' + uniqid() + '#';\n\n    return step;\n  }).join('');\n}\n\n/**\n * Baobab class\n *\n * @constructor\n * @param {object|array} [initialData={}]    - Initial data passed to the tree.\n * @param {object}       [opts]              - Optional options.\n * @param {boolean}      [opts.autoCommit]   - Should the tree auto-commit?\n * @param {boolean}      [opts.asynchronous] - Should the tree's transactions\n *                                             handled asynchronously?\n * @param {boolean}      [opts.immutable]    - Should the tree be immutable?\n * @param {boolean}      [opts.persistent]   - Should the tree be persistent?\n * @param {boolean}      [opts.pure]         - Should the tree be pure?\n * @param {function}     [opts.validate]     - Validation function.\n * @param {string}       [opts.validationBehaviour] - \"rollback\" or \"notify\".\n */\n\nvar Baobab = (function (_Emitter) {\n  _inherits(Baobab, _Emitter);\n\n  function Baobab(initialData, opts) {\n    var _this = this;\n\n    _classCallCheck(this, Baobab);\n\n    _get(Object.getPrototypeOf(Baobab.prototype), 'constructor', this).call(this);\n\n    // Setting initialData to an empty object if no data is provided by use\n    if (arguments.length < 1) initialData = {};\n\n    // Checking whether given initial data is valid\n    if (!_type2['default'].object(initialData) && !_type2['default'].array(initialData)) throw makeError('Baobab: invalid data.', { data: initialData });\n\n    // Merging given options with defaults\n    this.options = shallowMerge({}, DEFAULTS, opts);\n\n    // Disabling immutability & persistence if persistence if disabled\n    if (!this.options.persistent) {\n      this.options.immutable = false;\n      this.options.pure = false;\n    }\n\n    // Privates\n    this._identity = '[object Baobab]';\n    this._cursors = {};\n    this._future = null;\n    this._transaction = [];\n    this._affectedPathsIndex = {};\n    this._monkeys = {};\n    this._previousData = null;\n    this._data = initialData;\n\n    // Properties\n    this.root = new _cursor2['default'](this, [], '');\n    delete this.root.release;\n\n    // Does the user want an immutable tree?\n    if (this.options.immutable) deepFreeze(this._data);\n\n    // Bootstrapping root cursor's getters and setters\n    var bootstrap = function bootstrap(name) {\n      _this[name] = function () {\n        var r = this.root[name].apply(this.root, arguments);\n        return r instanceof _cursor2['default'] ? this : r;\n      };\n    };\n\n    ['apply', 'clone', 'concat', 'deepClone', 'deepMerge', 'exists', 'get', 'push', 'merge', 'pop', 'project', 'serialize', 'set', 'shift', 'splice', 'unset', 'unshift'].forEach(bootstrap);\n\n    // Registering the initial monkeys\n    this._refreshMonkeys();\n\n    // Initial validation\n    var validationError = this.validate();\n\n    if (validationError) throw Error('Baobab: invalid data.', { error: validationError });\n  }\n\n  /**\n   * Monkey helper.\n   */\n\n  /**\n   * Internal method used to refresh the tree's monkey register on every\n   * update.\n   * Note 1) For the time being, placing monkeys beneath array nodes is not\n   * allowed for performance reasons.\n   *\n   * @param  {mixed}   node      - The starting node.\n   * @param  {array}   path      - The starting node's path.\n   * @param  {string}  operation - The operation that lead to a refreshment.\n   * @return {Baobab}            - The tree instance for chaining purposes.\n   */\n\n  _createClass(Baobab, [{\n    key: '_refreshMonkeys',\n    value: function _refreshMonkeys(node, path, operation) {\n      var _this2 = this;\n\n      var clean = function clean(data) {\n        var p = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];\n\n        if (data instanceof _monkey.Monkey) {\n          data.release();\n          (0, _update3['default'])(_this2._monkeys, p, { type: 'unset' }, {\n            immutable: false,\n            persistent: false,\n            pure: false\n          });\n\n          return;\n        }\n\n        if (_type2['default'].object(data)) {\n          for (var k in data) {\n            clean(data[k], p.concat(k));\n          }\n        }\n      };\n\n      var walk = function walk(data) {\n        var p = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];\n\n        // Should we sit a monkey in the tree?\n        if (data instanceof _monkey.MonkeyDefinition || data instanceof _monkey.Monkey) {\n          var monkeyInstance = new _monkey.Monkey(_this2, p, data instanceof _monkey.Monkey ? data.definition : data);\n\n          (0, _update3['default'])(_this2._monkeys, p, { type: 'set', value: monkeyInstance }, {\n            immutable: false,\n            persistent: false,\n            pure: false\n          });\n\n          return;\n        }\n\n        // Object iteration\n        if (_type2['default'].object(data)) {\n          for (var k in data) {\n            walk(data[k], p.concat(k));\n          }\n        }\n      };\n\n      // Walking the whole tree\n      if (!arguments.length) {\n        walk(this._data);\n      } else {\n        var monkeysNode = getIn(this._monkeys, path).data;\n\n        // Is this required that we clean some already existing monkeys?\n        if (monkeysNode) clean(monkeysNode, path);\n\n        // Let's walk the tree only from the updated point\n        if (operation !== 'unset') {\n          walk(node, path);\n        }\n      }\n\n      return this;\n    }\n\n    /**\n     * Method used to validate the tree's data.\n     *\n     * @return {boolean} - Is the tree valid?\n     */\n  }, {\n    key: 'validate',\n    value: function validate(affectedPaths) {\n      var _options = this.options;\n      var validate = _options.validate;\n      var behavior = _options.validationBehavior;\n\n      if (typeof validate !== 'function') return null;\n\n      var error = validate.call(this, this._previousData, this._data, affectedPaths || [[]]);\n\n      if (error instanceof Error) {\n\n        if (behavior === 'rollback') {\n          this._data = this._previousData;\n          this._affectedPathsIndex = {};\n          this._transaction = [];\n          this._previousData = this._data;\n        }\n\n        this.emit('invalid', { error: error });\n\n        return error;\n      }\n\n      return null;\n    }\n\n    /**\n     * Method used to select data within the tree by creating a cursor. Cursors\n     * are kept as singletons by the tree for performance and hygiene reasons.\n     *\n     * Arity (1):\n     * @param {path}    path - Path to select in the tree.\n     *\n     * Arity (*):\n     * @param {...step} path - Path to select in the tree.\n     *\n     * @return {Cursor}      - The resultant cursor.\n     */\n  }, {\n    key: 'select',\n    value: function select(path) {\n\n      // If no path is given, we simply return the root\n      path = path || [];\n\n      // Variadic\n      if (arguments.length > 1) path = arrayFrom(arguments);\n\n      // Checking that given path is valid\n      if (!_type2['default'].path(path)) throw makeError('Baobab.select: invalid path.', { path: path });\n\n      // Casting to array\n      path = [].concat(path);\n\n      // Computing hash (done here because it would be too late to do it in the\n      // cursor's constructor since we need to hit the cursors' index first).\n      var hash = hashPath(path);\n\n      // Creating a new cursor or returning the already existing one for the\n      // requested path.\n      var cursor = this._cursors[hash];\n\n      if (!cursor) {\n        cursor = new _cursor2['default'](this, path, hash);\n        this._cursors[hash] = cursor;\n      }\n\n      // Emitting an event to notify that a part of the tree was selected\n      this.emit('select', { path: path, cursor: cursor });\n      return cursor;\n    }\n\n    /**\n     * Method used to update the tree. Updates are simply expressed by a path,\n     * dynamic or not, and an operation.\n     *\n     * This is where path solving should happen and not in the cursor.\n     *\n     * @param  {path}   path      - The path where we'll apply the operation.\n     * @param  {object} operation - The operation to apply.\n     * @return {mixed} - Return the result of the update.\n     */\n  }, {\n    key: 'update',\n    value: function update(path, operation) {\n      var _this3 = this;\n\n      // Coercing path\n      path = coercePath(path);\n\n      if (!_type2['default'].operationType(operation.type)) throw makeError('Baobab.update: unknown operation type \"' + operation.type + '\".', { operation: operation });\n\n      // Solving the given path\n\n      var _getIn = getIn(this._data, path);\n\n      var solvedPath = _getIn.solvedPath;\n      var exists = _getIn.exists;\n\n      // If we couldn't solve the path, we throw\n      if (!solvedPath) throw makeError('Baobab.update: could not solve the given path.', {\n        path: solvedPath\n      });\n\n      // Read-only path?\n      var monkeyPath = _type2['default'].monkeyPath(this._monkeys, solvedPath);\n      if (monkeyPath && solvedPath.length > monkeyPath.length) throw makeError('Baobab.update: attempting to update a read-only path.', {\n        path: solvedPath\n      });\n\n      // We don't unset irrelevant paths\n      if (operation.type === 'unset' && !exists) return;\n\n      // If we merge data, we need to acknowledge monkeys\n      var realOperation = operation;\n      if (/merge/i.test(operation.type)) {\n        var monkeysNode = getIn(this._monkeys, solvedPath).data;\n\n        if (_type2['default'].object(monkeysNode)) {\n\n          // Cloning the operation not to create weird behavior for the user\n          realOperation = shallowClone(realOperation);\n\n          // Fetching the existing node in the current data\n          var currentNode = getIn(this._data, solvedPath).data;\n\n          if (/deep/i.test(realOperation.type)) realOperation.value = deepMerge({}, deepMerge({}, currentNode, deepClone(monkeysNode)), realOperation.value);else realOperation.value = shallowMerge({}, deepMerge({}, currentNode, deepClone(monkeysNode)), realOperation.value);\n        }\n      }\n\n      // Stashing previous data if this is the frame's first update\n      if (!this._transaction.length) this._previousData = this._data;\n\n      // Applying the operation\n      var result = (0, _update3['default'])(this._data, solvedPath, realOperation, this.options);\n\n      var data = result.data;\n      var node = result.node;\n\n      // If because of purity, the update was moot, we stop here\n      if (!('data' in result)) return node;\n\n      // If the operation is push, the affected path is slightly different\n      var affectedPath = solvedPath.concat(operation.type === 'push' ? node.length - 1 : []);\n\n      var hash = hashPath(affectedPath);\n\n      // Updating data and transaction\n      this._data = data;\n      this._affectedPathsIndex[hash] = true;\n      this._transaction.push(shallowMerge({}, operation, { path: affectedPath }));\n\n      // Updating the monkeys\n      this._refreshMonkeys(node, solvedPath, operation.type);\n\n      // Emitting a `write` event\n      this.emit('write', { path: affectedPath });\n\n      // Should we let the user commit?\n      if (!this.options.autoCommit) return node;\n\n      // Should we update asynchronously?\n      if (!this.options.asynchronous) {\n        this.commit();\n        return node;\n      }\n\n      // Updating asynchronously\n      if (!this._future) this._future = setTimeout(function () {\n        return _this3.commit();\n      }, 0);\n\n      // Finally returning the affected node\n      return node;\n    }\n\n    /**\n     * Method committing the updates of the tree and firing the tree's events.\n     *\n     * @return {Baobab} - The tree instance for chaining purposes.\n     */\n  }, {\n    key: 'commit',\n    value: function commit() {\n\n      // Do not fire update if the transaction is empty\n      if (!this._transaction.length) return this;\n\n      // Clearing timeout if one was defined\n      if (this._future) this._future = clearTimeout(this._future);\n\n      var affectedPaths = Object.keys(this._affectedPathsIndex).map(function (h) {\n        return h !== '' ? h.split('').slice(1) : [];\n      });\n\n      // Is the tree still valid?\n      var validationError = this.validate(affectedPaths);\n\n      if (validationError) return this;\n\n      // Caching to keep original references before we change them\n      var transaction = this._transaction,\n          previousData = this._previousData;\n\n      this._affectedPathsIndex = {};\n      this._transaction = [];\n      this._previousData = this._data;\n\n      // Emitting update event\n      this.emit('update', {\n        paths: affectedPaths,\n        currentData: this._data,\n        transaction: transaction,\n        previousData: previousData\n      });\n\n      return this;\n    }\n\n    /**\n     * Method returning a monkey at the given path or else `null`.\n     *\n     * @param  {path}        path - Path of the monkey to retrieve.\n     * @return {Monkey|null}      - The Monkey instance of `null`.\n     */\n  }, {\n    key: 'getMonkey',\n    value: function getMonkey(path) {\n      path = coercePath(path);\n\n      var monkey = getIn(this._monkeys, [].concat(path)).data;\n\n      if (monkey instanceof _monkey.Monkey) return monkey;\n\n      return null;\n    }\n\n    /**\n     * Method used to watch a collection of paths within the tree. Very useful\n     * to bind UI components and such to the tree.\n     *\n     * @param  {object} mapping - Mapping of paths to listen.\n     * @return {Cursor}         - The created watcher.\n     */\n  }, {\n    key: 'watch',\n    value: function watch(mapping) {\n      return new _watcher2['default'](this, mapping);\n    }\n\n    /**\n     * Method releasing the tree and its attached data from memory.\n     */\n  }, {\n    key: 'release',\n    value: function release() {\n      var k = undefined;\n\n      this.emit('release');\n\n      delete this.root;\n\n      delete this._data;\n      delete this._previousData;\n      delete this._transaction;\n      delete this._affectedPathsIndex;\n      delete this._monkeys;\n\n      // Releasing cursors\n      for (k in this._cursors) this._cursors[k].release();\n      delete this._cursors;\n\n      // Killing event emitter\n      this.kill();\n    }\n\n    /**\n     * Overriding the `toJSON` method for convenient use with JSON.stringify.\n     *\n     * @return {mixed} - Data at cursor.\n     */\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return this.serialize();\n    }\n\n    /**\n     * Overriding the `toString` method for debugging purposes.\n     *\n     * @return {string} - The baobab's identity.\n     */\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return this._identity;\n    }\n  }]);\n\n  return Baobab;\n})(_emmett2['default']);\n\nexports['default'] = Baobab;\nBaobab.monkey = function () {\n  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  if (!args.length) throw new Error('Baobab.monkey: missing definition.');\n\n  if (args.length === 1 && typeof args[0] !== 'function') return new _monkey.MonkeyDefinition(args[0]);\n\n  return new _monkey.MonkeyDefinition(args);\n};\nBaobab.dynamicNode = Baobab.monkey;\n\n/**\n * Exposing some internals for convenience\n */\nBaobab.Cursor = _cursor2['default'];\nBaobab.MonkeyDefinition = _monkey.MonkeyDefinition;\nBaobab.Monkey = _monkey.Monkey;\nBaobab.type = _type2['default'];\nBaobab.helpers = helpers;\n\n/**\n * Version\n */\nBaobab.VERSION = '2.3.2';\nmodule.exports = exports['default'];\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/baobab/dist/baobab.js\n ** module id = 11\n ** module chunks = 0\n **/","(function() {\n  'use strict';\n\n  /**\n   * Here is the list of every allowed parameter when using Emitter#on:\n   * @type {Object}\n   */\n  var __allowedOptions = {\n    once: 'boolean',\n    scope: 'object'\n  };\n\n  /**\n   * Incremental id used to order event handlers.\n   */\n  var __order = 0;\n\n  /**\n   * A simple helper to shallowly merge two objects. The second one will \"win\"\n   * over the first one.\n   *\n   * @param  {object}  o1 First target object.\n   * @param  {object}  o2 Second target object.\n   * @return {object}     Returns the merged object.\n   */\n  function shallowMerge(o1, o2) {\n    var o = {},\n        k;\n\n    for (k in o1) o[k] = o1[k];\n    for (k in o2) o[k] = o2[k];\n\n    return o;\n  }\n\n  /**\n   * Is the given variable a plain JavaScript object?\n   *\n   * @param  {mixed}  v   Target.\n   * @return {boolean}    The boolean result.\n   */\n  function isPlainObject(v) {\n    return v &&\n           typeof v === 'object' &&\n           !Array.isArray(v) &&\n           !(v instanceof Function) &&\n           !(v instanceof RegExp);\n  }\n\n  /**\n   * Iterate over an object that may have ES6 Symbols.\n   *\n   * @param  {object}   object  Object on which to iterate.\n   * @param  {function} fn      Iterator function.\n   * @param  {object}   [scope] Optional scope.\n   */\n  function forIn(object, fn, scope) {\n    var symbols,\n        k,\n        i,\n        l;\n\n    for (k in object)\n      fn.call(scope || null, k, object[k]);\n\n    if (Object.getOwnPropertySymbols) {\n      symbols = Object.getOwnPropertySymbols(object);\n\n      for (i = 0, l = symbols.length; i < l; i++)\n        fn.call(scope || null, symbols[i], object[symbols[i]]);\n    }\n  }\n\n  /**\n   * The emitter's constructor. It initializes the handlers-per-events store and\n   * the global handlers store.\n   *\n   * Emitters are useful for non-DOM events communication. Read its methods\n   * documentation for more information about how it works.\n   *\n   * @return {Emitter}         The fresh new instance.\n   */\n  var Emitter = function() {\n    this._enabled = true;\n\n    // Dirty trick that will set the necessary properties to the emitter\n    this.unbindAll();\n  };\n\n  /**\n   * This method unbinds every handlers attached to every or any events. So,\n   * these functions will no more be executed when the related events are\n   * emitted. If the functions were not bound to the events, nothing will\n   * happen, and no error will be thrown.\n   *\n   * Usage:\n   * ******\n   * > myEmitter.unbindAll();\n   *\n   * @return {Emitter}      Returns this.\n   */\n  Emitter.prototype.unbindAll = function() {\n\n    this._handlers = {};\n    this._handlersAll = [];\n    this._handlersComplex = [];\n\n    return this;\n  };\n\n\n  /**\n   * This method binds one or more functions to the emitter, handled to one or a\n   * suite of events. So, these functions will be executed anytime one related\n   * event is emitted.\n   *\n   * It is also possible to bind a function to any emitted event by not\n   * specifying any event to bind the function to.\n   *\n   * Recognized options:\n   * *******************\n   *  - {?boolean} once   If true, the handlers will be unbound after the first\n   *                      execution. Default value: false.\n   *  - {?object}  scope  If a scope is given, then the listeners will be called\n   *                      with this scope as \"this\".\n   *\n   * Variant 1:\n   * **********\n   * > myEmitter.on('myEvent', function(e) { console.log(e); });\n   * > // Or:\n   * > myEmitter.on('myEvent', function(e) { console.log(e); }, { once: true });\n   *\n   * @param  {string}   event   The event to listen to.\n   * @param  {function} handler The function to bind.\n   * @param  {?object}  options Eventually some options.\n   * @return {Emitter}          Returns this.\n   *\n   * Variant 2:\n   * **********\n   * > myEmitter.on(\n   * >   ['myEvent1', 'myEvent2'],\n   * >   function(e) { console.log(e); }\n   * >);\n   * > // Or:\n   * > myEmitter.on(\n   * >   ['myEvent1', 'myEvent2'],\n   * >   function(e) { console.log(e); }\n   * >   { once: true }}\n   * >);\n   *\n   * @param  {array}    events  The events to listen to.\n   * @param  {function} handler The function to bind.\n   * @param  {?object}  options Eventually some options.\n   * @return {Emitter}          Returns this.\n   *\n   * Variant 3:\n   * **********\n   * > myEmitter.on({\n   * >   myEvent1: function(e) { console.log(e); },\n   * >   myEvent2: function(e) { console.log(e); }\n   * > });\n   * > // Or:\n   * > myEmitter.on({\n   * >   myEvent1: function(e) { console.log(e); },\n   * >   myEvent2: function(e) { console.log(e); }\n   * > }, { once: true });\n   *\n   * @param  {object}  bindings An object containing pairs event / function.\n   * @param  {?object}  options Eventually some options.\n   * @return {Emitter}          Returns this.\n   *\n   * Variant 4:\n   * **********\n   * > myEmitter.on(function(e) { console.log(e); });\n   * > // Or:\n   * > myEmitter.on(function(e) { console.log(e); }, { once: true});\n   *\n   * @param  {function} handler The function to bind to every events.\n   * @param  {?object}  options Eventually some options.\n   * @return {Emitter}          Returns this.\n   */\n  Emitter.prototype.on = function(a, b, c) {\n    var i,\n        l,\n        k,\n        event,\n        eArray,\n        handlersList,\n        bindingObject;\n\n    // Variant 3\n    if (isPlainObject(a)) {\n      forIn(a, function(name, fn) {\n        this.on(name, fn, b);\n      }, this);\n\n      return this;\n    }\n\n    // Variant 1, 2 and 4\n    if (typeof a === 'function') {\n      c = b;\n      b = a;\n      a = null;\n    }\n\n    eArray = [].concat(a);\n\n    for (i = 0, l = eArray.length; i < l; i++) {\n      event = eArray[i];\n\n      bindingObject = {\n        order: __order++,\n        fn: b\n      };\n\n      // Defining the list in which the handler should be inserted\n      if (typeof event === 'string' || typeof event === 'symbol') {\n        if (!this._handlers[event])\n          this._handlers[event] = [];\n        handlersList = this._handlers[event];\n        bindingObject.type = event;\n      }\n      else if (event instanceof RegExp) {\n        handlersList = this._handlersComplex;\n        bindingObject.pattern = event;\n      }\n      else if (event === null) {\n        handlersList = this._handlersAll;\n      }\n      else {\n        throw Error('Emitter.on: invalid event.');\n      }\n\n      // Appending needed properties\n      for (k in c || {})\n        if (__allowedOptions[k])\n          bindingObject[k] = c[k];\n\n      handlersList.push(bindingObject);\n    }\n\n    return this;\n  };\n\n\n  /**\n   * This method works exactly as the previous #on, but will add an options\n   * object if none is given, and set the option \"once\" to true.\n   *\n   * The polymorphism works exactly as with the #on method.\n   */\n  Emitter.prototype.once = function() {\n    var args = Array.prototype.slice.call(arguments),\n        li = args.length - 1;\n\n    if (isPlainObject(args[li]) && args.length > 1)\n      args[li] = shallowMerge(args[li], {once: true});\n    else\n      args.push({once: true});\n\n    return this.on.apply(this, args);\n  };\n\n\n  /**\n   * This method unbinds one or more functions from events of the emitter. So,\n   * these functions will no more be executed when the related events are\n   * emitted. If the functions were not bound to the events, nothing will\n   * happen, and no error will be thrown.\n   *\n   * Variant 1:\n   * **********\n   * > myEmitter.off('myEvent', myHandler);\n   *\n   * @param  {string}   event   The event to unbind the handler from.\n   * @param  {function} handler The function to unbind.\n   * @return {Emitter}          Returns this.\n   *\n   * Variant 2:\n   * **********\n   * > myEmitter.off(['myEvent1', 'myEvent2'], myHandler);\n   *\n   * @param  {array}    events  The events to unbind the handler from.\n   * @param  {function} handler The function to unbind.\n   * @return {Emitter}          Returns this.\n   *\n   * Variant 3:\n   * **********\n   * > myEmitter.off({\n   * >   myEvent1: myHandler1,\n   * >   myEvent2: myHandler2\n   * > });\n   *\n   * @param  {object} bindings An object containing pairs event / function.\n   * @return {Emitter}         Returns this.\n   *\n   * Variant 4:\n   * **********\n   * > myEmitter.off(myHandler);\n   *\n   * @param  {function} handler The function to unbind from every events.\n   * @return {Emitter}          Returns this.\n   *\n   * Variant 5:\n   * **********\n   * > myEmitter.off(event);\n   *\n   * @param  {string} event     The event we should unbind.\n   * @return {Emitter}          Returns this.\n   */\n  function filter(target, fn) {\n    target = target || [];\n\n    var a = [],\n        l,\n        i;\n\n    for (i = 0, l = target.length; i < l; i++)\n      if (target[i].fn !== fn)\n        a.push(target[i]);\n\n    return a;\n  }\n\n  Emitter.prototype.off = function(events, fn) {\n    var i,\n        n,\n        k,\n        event;\n\n    // Variant 4:\n    if (arguments.length === 1 && typeof events === 'function') {\n      fn = arguments[0];\n\n      // Handlers bound to events:\n      for (k in this._handlers) {\n        this._handlers[k] = filter(this._handlers[k], fn);\n\n        if (this._handlers[k].length === 0)\n          delete this._handlers[k];\n      }\n\n      // Generic Handlers\n      this._handlersAll = filter(this._handlersAll, fn);\n\n      // Complex handlers\n      this._handlersComplex = filter(this._handlersComplex, fn);\n    }\n\n    // Variant 5\n    else if (arguments.length === 1 &&\n             (typeof events === 'string' || typeof events === 'symbol')) {\n      delete this._handlers[events];\n    }\n\n    // Variant 1 and 2:\n    else if (arguments.length === 2) {\n      var eArray = [].concat(events);\n\n      for (i = 0, n = eArray.length; i < n; i++) {\n        event = eArray[i];\n\n        this._handlers[event] = filter(this._handlers[event], fn);\n\n        if ((this._handlers[event] || []).length === 0)\n          delete this._handlers[event];\n      }\n    }\n\n    // Variant 3\n    else if (isPlainObject(events)) {\n      forIn(events, this.off, this);\n    }\n\n    return this;\n  };\n\n  /**\n   * This method retrieve the listeners attached to a particular event.\n   *\n   * @param  {?string}    Name of the event.\n   * @return {array}      Array of handler functions.\n   */\n  Emitter.prototype.listeners = function(event) {\n    var handlers = this._handlersAll || [],\n        complex = false,\n        h,\n        i,\n        l;\n\n    if (!event)\n      throw Error('Emitter.listeners: no event provided.');\n\n    handlers = handlers.concat(this._handlers[event] || []);\n\n    for (i = 0, l = this._handlersComplex.length; i < l; i++) {\n      h = this._handlersComplex[i];\n\n      if (~event.search(h.pattern)) {\n        complex = true;\n        handlers.push(h);\n      }\n    }\n\n    // If we have any complex handlers, we need to sort\n    if (this._handlersAll.length || complex)\n      return handlers.sort(function(a, b) {\n        return a.order - b.order;\n      });\n    else\n      return handlers.slice(0);\n  };\n\n  /**\n   * This method emits the specified event(s), and executes every handlers bound\n   * to the event(s).\n   *\n   * Use cases:\n   * **********\n   * > myEmitter.emit('myEvent');\n   * > myEmitter.emit('myEvent', myData);\n   * > myEmitter.emit(['myEvent1', 'myEvent2']);\n   * > myEmitter.emit(['myEvent1', 'myEvent2'], myData);\n   * > myEmitter.emit({myEvent1: myData1, myEvent2: myData2});\n   *\n   * @param  {string|array} events The event(s) to emit.\n   * @param  {object?}      data   The data.\n   * @return {Emitter}             Returns this.\n   */\n  Emitter.prototype.emit = function(events, data) {\n\n    // Short exit if the emitter is disabled\n    if (!this._enabled)\n      return this;\n\n    // Object variant\n    if (isPlainObject(events)) {\n      forIn(events, this.emit, this);\n      return this;\n    }\n\n    var eArray = [].concat(events),\n        onces = [],\n        event,\n        parent,\n        handlers,\n        handler,\n        i,\n        j,\n        l,\n        m;\n\n    for (i = 0, l = eArray.length; i < l; i++) {\n      handlers = this.listeners(eArray[i]);\n\n      for (j = 0, m = handlers.length; j < m; j++) {\n        handler = handlers[j];\n        event = {\n          type: eArray[i],\n          target: this\n        };\n\n        if (arguments.length > 1)\n          event.data = data;\n\n        handler.fn.call('scope' in handler ? handler.scope : this, event);\n\n        if (handler.once)\n          onces.push(handler);\n      }\n\n      // Cleaning onces\n      for (j = onces.length - 1; j >= 0; j--) {\n        parent = onces[j].type ?\n          this._handlers[onces[j].type] :\n          onces[j].pattern ?\n            this._handlersComplex :\n            this._handlersAll;\n\n        parent.splice(parent.indexOf(onces[j]), 1);\n      }\n    }\n\n    return this;\n  };\n\n\n  /**\n   * This method will unbind all listeners and make it impossible to ever\n   * rebind any listener to any event.\n   */\n  Emitter.prototype.kill = function() {\n\n    this.unbindAll();\n    this._handlers = null;\n    this._handlersAll = null;\n    this._handlersComplex = null;\n    this._enabled = false;\n\n    // Nooping methods\n    this.unbindAll =\n    this.on =\n    this.once =\n    this.off =\n    this.emit =\n    this.listeners = Function.prototype;\n  };\n\n\n  /**\n   * This method disabled the emitter, which means its emit method will do\n   * nothing.\n   *\n   * @return {Emitter} Returns this.\n   */\n  Emitter.prototype.disable = function() {\n    this._enabled = false;\n\n    return this;\n  };\n\n\n  /**\n   * This method enables the emitter.\n   *\n   * @return {Emitter} Returns this.\n   */\n  Emitter.prototype.enable = function() {\n    this._enabled = true;\n\n    return this;\n  };\n\n\n  /**\n   * Version:\n   */\n  Emitter.version = '3.1.1';\n\n\n  // Export:\n  if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports)\n      exports = module.exports = Emitter;\n    exports.Emitter = Emitter;\n  } else if (typeof define === 'function' && define.amd)\n    define('emmett', [], function() {\n      return Emitter;\n    });\n  else\n    this.Emitter = Emitter;\n}).call(this);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/emmett/emmett.js\n ** module id = 12\n ** module chunks = 0\n **/","/**\n * Baobab Cursors\n * ===============\n *\n * Cursors created by selecting some data within a Baobab tree.\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nvar _get = function get(_x3, _x4, _x5) { var _again = true; _function: while (_again) { var object = _x3, property = _x4, receiver = _x5; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x3 = parent; _x4 = property; _x5 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _emmett = require('emmett');\n\nvar _emmett2 = _interopRequireDefault(_emmett);\n\nvar _monkey = require('./monkey');\n\nvar _type = require('./type');\n\nvar _type2 = _interopRequireDefault(_type);\n\nvar _helpers = require('./helpers');\n\n/**\n * Traversal helper function for dynamic cursors. Will throw a legible error\n * if traversal is not possible.\n *\n * @param {string} method     - The method name, to create a correct error msg.\n * @param {array}  solvedPath - The cursor's solved path.\n */\nfunction checkPossibilityOfDynamicTraversal(method, solvedPath) {\n  if (!solvedPath) throw (0, _helpers.makeError)('Baobab.Cursor.' + method + ': ' + ('cannot use ' + method + ' on an unresolved dynamic path.'), { path: solvedPath });\n}\n\n/**\n * Cursor class\n *\n * @constructor\n * @param {Baobab} tree   - The cursor's root.\n * @param {array}  path   - The cursor's path in the tree.\n * @param {string} hash   - The path's hash computed ahead by the tree.\n */\n\nvar Cursor = (function (_Emitter) {\n  _inherits(Cursor, _Emitter);\n\n  function Cursor(tree, path, hash) {\n    var _this = this;\n\n    _classCallCheck(this, Cursor);\n\n    _get(Object.getPrototypeOf(Cursor.prototype), 'constructor', this).call(this);\n\n    // If no path were to be provided, we fallback to an empty path (root)\n    path = path || [];\n\n    // Privates\n    this._identity = '[object Cursor]';\n    this._archive = null;\n\n    // Properties\n    this.tree = tree;\n    this.path = path;\n    this.hash = hash;\n\n    // State\n    this.state = {\n      killed: false,\n      recording: false,\n      undoing: false\n    };\n\n    // Checking whether the given path is dynamic or not\n    this._dynamicPath = _type2['default'].dynamicPath(this.path);\n\n    // Checking whether the given path will meet a monkey\n    this._monkeyPath = _type2['default'].monkeyPath(this.tree._monkeys, this.path);\n\n    if (!this._dynamicPath) this.solvedPath = this.path;else this.solvedPath = (0, _helpers.getIn)(this.tree._data, this.path).solvedPath;\n\n    /**\n     * Listener bound to the tree's writes so that cursors with dynamic paths\n     * may update their solved path correctly.\n     *\n     * @param {object} event - The event fired by the tree.\n     */\n    this._writeHandler = function (_ref) {\n      var data = _ref.data;\n\n      if (_this.state.killed || !(0, _helpers.solveUpdate)([data.path], _this._getComparedPaths())) return;\n\n      _this.solvedPath = (0, _helpers.getIn)(_this.tree._data, _this.path).solvedPath;\n    };\n\n    /**\n     * Function in charge of actually trigger the cursor's updates and\n     * deal with the archived records.\n     *\n     * @note: probably should wrap the current solvedPath in closure to avoid\n     * for tricky cases where it would fail.\n     *\n     * @param {mixed} previousData - the tree's previous data.\n     */\n    var fireUpdate = function fireUpdate(previousData) {\n      var self = _this;\n\n      var eventData = Object.defineProperties({}, {\n        previousData: {\n          get: function get() {\n            return (0, _helpers.getIn)(previousData, self.solvedPath).data;\n          },\n          configurable: true,\n          enumerable: true\n        },\n        currentData: {\n          get: function get() {\n            return self.get();\n          },\n          configurable: true,\n          enumerable: true\n        }\n      });\n\n      if (_this.state.recording && !_this.state.undoing) _this.archive.add(eventData.previousData);\n\n      _this.state.undoing = false;\n\n      return _this.emit('update', eventData);\n    };\n\n    /**\n     * Listener bound to the tree's updates and determining whether the\n     * cursor is affected and should react accordingly.\n     *\n     * Note that this listener is lazily bound to the tree to be sure\n     * one wouldn't leak listeners when only creating cursors for convenience\n     * and not to listen to updates specifically.\n     *\n     * @param {object} event - The event fired by the tree.\n     */\n    this._updateHandler = function (event) {\n      if (_this.state.killed) return;\n\n      var _event$data = event.data;\n      var paths = _event$data.paths;\n      var previousData = _event$data.previousData;\n      var update = fireUpdate.bind(_this, previousData);\n      var comparedPaths = _this._getComparedPaths();\n\n      if ((0, _helpers.solveUpdate)(paths, comparedPaths)) return update();\n    };\n\n    // Lazy binding\n    var bound = false;\n    this._lazyBind = function () {\n      if (bound) return;\n\n      bound = true;\n\n      if (_this._dynamicPath) _this.tree.on('write', _this._writeHandler);\n\n      return _this.tree.on('update', _this._updateHandler);\n    };\n\n    // If the path is dynamic, we actually need to listen to the tree\n    if (this._dynamicPath) {\n      this._lazyBind();\n    } else {\n\n      // Overriding the emitter `on` and `once` methods\n      this.on = (0, _helpers.before)(this._lazyBind, this.on.bind(this));\n      this.once = (0, _helpers.before)(this._lazyBind, this.once.bind(this));\n    }\n  }\n\n  /**\n   * Method used to allow iterating over cursors containing list-type data.\n   *\n   * e.g. for(let i of cursor) { ... }\n   *\n   * @returns {object} -  Each item sequentially.\n   */\n\n  /**\n   * Internal helpers\n   * -----------------\n   */\n\n  /**\n   * Method returning the paths of the tree watched over by the cursor and that\n   * should be taken into account when solving a potential update.\n   *\n   * @return {array} - Array of paths to compare with a given update.\n   */\n\n  _createClass(Cursor, [{\n    key: '_getComparedPaths',\n    value: function _getComparedPaths() {\n\n      // Checking whether we should keep track of some dependencies\n      var additionalPaths = this._monkeyPath ? (0, _helpers.getIn)(this.tree._monkeys, this._monkeyPath).data.relatedPaths() : [];\n\n      return [this.solvedPath].concat(additionalPaths);\n    }\n\n    /**\n     * Predicates\n     * -----------\n     */\n\n    /**\n     * Method returning whether the cursor is at root level.\n     *\n     * @return {boolean} - Is the cursor the root?\n     */\n  }, {\n    key: 'isRoot',\n    value: function isRoot() {\n      return !this.path.length;\n    }\n\n    /**\n     * Method returning whether the cursor is at leaf level.\n     *\n     * @return {boolean} - Is the cursor a leaf?\n     */\n  }, {\n    key: 'isLeaf',\n    value: function isLeaf() {\n      return _type2['default'].primitive(this._get().data);\n    }\n\n    /**\n     * Method returning whether the cursor is at branch level.\n     *\n     * @return {boolean} - Is the cursor a branch?\n     */\n  }, {\n    key: 'isBranch',\n    value: function isBranch() {\n      return !this.isRoot() && !this.isLeaf();\n    }\n\n    /**\n     * Traversal Methods\n     * ------------------\n     */\n\n    /**\n     * Method returning the root cursor.\n     *\n     * @return {Baobab} - The root cursor.\n     */\n  }, {\n    key: 'root',\n    value: function root() {\n      return this.tree.select();\n    }\n\n    /**\n     * Method selecting a subpath as a new cursor.\n     *\n     * Arity (1):\n     * @param  {path} path    - The path to select.\n     *\n     * Arity (*):\n     * @param  {...step} path - The path to select.\n     *\n     * @return {Cursor}       - The created cursor.\n     */\n  }, {\n    key: 'select',\n    value: function select(path) {\n      if (arguments.length > 1) path = (0, _helpers.arrayFrom)(arguments);\n\n      return this.tree.select(this.path.concat(path));\n    }\n\n    /**\n     * Method returning the parent node of the cursor or else `null` if the\n     * cursor is already at root level.\n     *\n     * @return {Baobab} - The parent cursor.\n     */\n  }, {\n    key: 'up',\n    value: function up() {\n      if (!this.isRoot()) return this.tree.select(this.path.slice(0, -1));\n\n      return null;\n    }\n\n    /**\n     * Method returning the child node of the cursor.\n     *\n     * @return {Baobab} - The child cursor.\n     */\n  }, {\n    key: 'down',\n    value: function down() {\n      checkPossibilityOfDynamicTraversal('down', this.solvedPath);\n\n      if (!(this._get().data instanceof Array)) throw Error('Baobab.Cursor.down: cannot go down on a non-list type.');\n\n      return this.tree.select(this.solvedPath.concat(0));\n    }\n\n    /**\n     * Method returning the left sibling node of the cursor if this one is\n     * pointing at a list. Returns `null` if this cursor is already leftmost.\n     *\n     * @return {Baobab} - The left sibling cursor.\n     */\n  }, {\n    key: 'left',\n    value: function left() {\n      checkPossibilityOfDynamicTraversal('left', this.solvedPath);\n\n      var last = +this.solvedPath[this.solvedPath.length - 1];\n\n      if (isNaN(last)) throw Error('Baobab.Cursor.left: cannot go left on a non-list type.');\n\n      return last ? this.tree.select(this.solvedPath.slice(0, -1).concat(last - 1)) : null;\n    }\n\n    /**\n     * Method returning the right sibling node of the cursor if this one is\n     * pointing at a list. Returns `null` if this cursor is already rightmost.\n     *\n     * @return {Baobab} - The right sibling cursor.\n     */\n  }, {\n    key: 'right',\n    value: function right() {\n      checkPossibilityOfDynamicTraversal('right', this.solvedPath);\n\n      var last = +this.solvedPath[this.solvedPath.length - 1];\n\n      if (isNaN(last)) throw Error('Baobab.Cursor.right: cannot go right on a non-list type.');\n\n      if (last + 1 === this.up()._get().data.length) return null;\n\n      return this.tree.select(this.solvedPath.slice(0, -1).concat(last + 1));\n    }\n\n    /**\n     * Method returning the leftmost sibling node of the cursor if this one is\n     * pointing at a list.\n     *\n     * @return {Baobab} - The leftmost sibling cursor.\n     */\n  }, {\n    key: 'leftmost',\n    value: function leftmost() {\n      checkPossibilityOfDynamicTraversal('leftmost', this.solvedPath);\n\n      var last = +this.solvedPath[this.solvedPath.length - 1];\n\n      if (isNaN(last)) throw Error('Baobab.Cursor.leftmost: cannot go left on a non-list type.');\n\n      return this.tree.select(this.solvedPath.slice(0, -1).concat(0));\n    }\n\n    /**\n     * Method returning the rightmost sibling node of the cursor if this one is\n     * pointing at a list.\n     *\n     * @return {Baobab} - The rightmost sibling cursor.\n     */\n  }, {\n    key: 'rightmost',\n    value: function rightmost() {\n      checkPossibilityOfDynamicTraversal('rightmost', this.solvedPath);\n\n      var last = +this.solvedPath[this.solvedPath.length - 1];\n\n      if (isNaN(last)) throw Error('Baobab.Cursor.rightmost: cannot go right on a non-list type.');\n\n      var list = this.up()._get().data;\n\n      return this.tree.select(this.solvedPath.slice(0, -1).concat(list.length - 1));\n    }\n\n    /**\n     * Method mapping the children nodes of the cursor.\n     *\n     * @param  {function} fn      - The function to map.\n     * @param  {object}   [scope] - An optional scope.\n     * @return {array}            - The resultant array.\n     */\n  }, {\n    key: 'map',\n    value: function map(fn, scope) {\n      checkPossibilityOfDynamicTraversal('map', this.solvedPath);\n\n      var array = this._get().data,\n          l = arguments.length;\n\n      if (!_type2['default'].array(array)) throw Error('baobab.Cursor.map: cannot map a non-list type.');\n\n      return array.map(function (item, i) {\n        return fn.call(l > 1 ? scope : this, this.select(i), i, array);\n      }, this);\n    }\n\n    /**\n     * Getter Methods\n     * ---------------\n     */\n\n    /**\n     * Internal get method. Basically contains the main body of the `get` method\n     * without the event emitting. This is sometimes needed not to fire useless\n     * events.\n     *\n     * @param  {path}   [path=[]]       - Path to get in the tree.\n     * @return {object} info            - The resultant information.\n     * @return {mixed}  info.data       - Data at path.\n     * @return {array}  info.solvedPath - The path solved when getting.\n     */\n  }, {\n    key: '_get',\n    value: function _get() {\n      var path = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];\n\n      if (!_type2['default'].path(path)) throw (0, _helpers.makeError)('Baobab.Cursor.getters: invalid path.', { path: path });\n\n      if (!this.solvedPath) return { data: undefined, solvedPath: null, exists: false };\n\n      return (0, _helpers.getIn)(this.tree._data, this.solvedPath.concat(path));\n    }\n\n    /**\n     * Method used to check whether a certain path exists in the tree starting\n     * from the current cursor.\n     *\n     * Arity (1):\n     * @param  {path}   path           - Path to check in the tree.\n     *\n     * Arity (2):\n     * @param {..step}  path           - Path to check in the tree.\n     *\n     * @return {boolean}               - Does the given path exists?\n     */\n  }, {\n    key: 'exists',\n    value: function exists(path) {\n      path = (0, _helpers.coercePath)(path);\n\n      if (arguments.length > 1) path = (0, _helpers.arrayFrom)(arguments);\n\n      return this._get(path).exists;\n    }\n\n    /**\n     * Method used to get data from the tree. Will fire a `get` event from the\n     * tree so that the user may sometimes react upon it to fetch data, for\n     * instance.\n     *\n     * Arity (1):\n     * @param  {path}   path           - Path to get in the tree.\n     *\n     * Arity (2):\n     * @param  {..step} path           - Path to get in the tree.\n     *\n     * @return {mixed}                 - Data at path.\n     */\n  }, {\n    key: 'get',\n    value: function get(path) {\n      path = (0, _helpers.coercePath)(path);\n\n      if (arguments.length > 1) path = (0, _helpers.arrayFrom)(arguments);\n\n      var _get2 = this._get(path);\n\n      var data = _get2.data;\n      var solvedPath = _get2.solvedPath;\n\n      // Emitting the event\n      this.tree.emit('get', { data: data, solvedPath: solvedPath, path: this.path.concat(path) });\n\n      return data;\n    }\n\n    /**\n     * Method used to shallow clone data from the tree.\n     *\n     * Arity (1):\n     * @param  {path}   path           - Path to get in the tree.\n     *\n     * Arity (2):\n     * @param  {..step} path           - Path to get in the tree.\n     *\n     * @return {mixed}                 - Cloned data at path.\n     */\n  }, {\n    key: 'clone',\n    value: function clone() {\n      var data = this.get.apply(this, arguments);\n\n      return (0, _helpers.shallowClone)(data);\n    }\n\n    /**\n     * Method used to deep clone data from the tree.\n     *\n     * Arity (1):\n     * @param  {path}   path           - Path to get in the tree.\n     *\n     * Arity (2):\n     * @param  {..step} path           - Path to get in the tree.\n     *\n     * @return {mixed}                 - Cloned data at path.\n     */\n  }, {\n    key: 'deepClone',\n    value: function deepClone() {\n      var data = this.get.apply(this, arguments);\n\n      return (0, _helpers.deepClone)(data);\n    }\n\n    /**\n     * Method used to return raw data from the tree, by carefully avoiding\n     * computed one.\n     *\n     * @todo: should be more performant as the cloning should happen as well as\n     * when dropping computed data.\n     *\n     * Arity (1):\n     * @param  {path}   path           - Path to serialize in the tree.\n     *\n     * Arity (2):\n     * @param  {..step} path           - Path to serialize in the tree.\n     *\n     * @return {mixed}                 - The retrieved raw data.\n     */\n  }, {\n    key: 'serialize',\n    value: function serialize(path) {\n      path = (0, _helpers.coercePath)(path);\n\n      if (arguments.length > 1) path = (0, _helpers.arrayFrom)(arguments);\n\n      if (!_type2['default'].path(path)) throw (0, _helpers.makeError)('Baobab.Cursor.getters: invalid path.', { path: path });\n\n      if (!this.solvedPath) return undefined;\n\n      var fullPath = this.solvedPath.concat(path);\n\n      var data = (0, _helpers.deepClone)((0, _helpers.getIn)(this.tree._data, fullPath).data),\n          monkeys = (0, _helpers.getIn)(this.tree._monkeys, fullPath).data;\n\n      var dropComputedData = function dropComputedData(d, m) {\n        if (!_type2['default'].object(m) || !_type2['default'].object(d)) return;\n\n        for (var k in m) {\n          if (m[k] instanceof _monkey.Monkey) delete d[k];else dropComputedData(d[k], m[k]);\n        }\n      };\n\n      dropComputedData(data, monkeys);\n      return data;\n    }\n\n    /**\n     * Method used to project some of the data at cursor onto a map or a list.\n     *\n     * @param  {object|array} projection - The projection's formal definition.\n     * @return {object|array}            - The resultant map/list.\n     */\n  }, {\n    key: 'project',\n    value: function project(projection) {\n      if (_type2['default'].object(projection)) {\n        var data = {};\n\n        for (var k in projection) {\n          data[k] = this.get(projection[k]);\n        }return data;\n      } else if (_type2['default'].array(projection)) {\n        var data = [];\n\n        for (var i = 0, l = projection.length; i < l; i++) {\n          data.push(this.get(projection[i]));\n        }return data;\n      }\n\n      throw (0, _helpers.makeError)('Baobab.Cursor.project: wrong projection.', { projection: projection });\n    }\n\n    /**\n     * History Methods\n     * ----------------\n     */\n\n    /**\n     * Methods starting to record the cursor's successive states.\n     *\n     * @param  {integer} [maxRecords] - Maximum records to keep in memory. Note\n     *                                  that if no number is provided, the cursor\n     *                                  will keep everything.\n     * @return {Cursor}               - The cursor instance for chaining purposes.\n     */\n  }, {\n    key: 'startRecording',\n    value: function startRecording(maxRecords) {\n      maxRecords = maxRecords || Infinity;\n\n      if (maxRecords < 1) throw (0, _helpers.makeError)('Baobab.Cursor.startRecording: invalid max records.', {\n        value: maxRecords\n      });\n\n      this.state.recording = true;\n\n      if (this.archive) return this;\n\n      // Lazy binding\n      this._lazyBind();\n\n      this.archive = new _helpers.Archive(maxRecords);\n      return this;\n    }\n\n    /**\n     * Methods stopping to record the cursor's successive states.\n     *\n     * @return {Cursor} - The cursor instance for chaining purposes.\n     */\n  }, {\n    key: 'stopRecording',\n    value: function stopRecording() {\n      this.state.recording = false;\n      return this;\n    }\n\n    /**\n     * Methods undoing n steps of the cursor's recorded states.\n     *\n     * @param  {integer} [steps=1] - The number of steps to rollback.\n     * @return {Cursor}            - The cursor instance for chaining purposes.\n     */\n  }, {\n    key: 'undo',\n    value: function undo() {\n      var steps = arguments.length <= 0 || arguments[0] === undefined ? 1 : arguments[0];\n\n      if (!this.state.recording) throw new Error('Baobab.Cursor.undo: cursor is not recording.');\n\n      var record = this.archive.back(steps);\n\n      if (!record) throw Error('Baobab.Cursor.undo: cannot find a relevant record.');\n\n      this.state.undoing = true;\n      this.set(record);\n\n      return this;\n    }\n\n    /**\n     * Methods returning whether the cursor has a recorded history.\n     *\n     * @return {boolean} - `true` if the cursor has a recorded history?\n     */\n  }, {\n    key: 'hasHistory',\n    value: function hasHistory() {\n      return !!(this.archive && this.archive.get().length);\n    }\n\n    /**\n     * Methods returning the cursor's history.\n     *\n     * @return {array} - The cursor's history.\n     */\n  }, {\n    key: 'getHistory',\n    value: function getHistory() {\n      return this.archive ? this.archive.get() : [];\n    }\n\n    /**\n     * Methods clearing the cursor's history.\n     *\n     * @return {Cursor} - The cursor instance for chaining purposes.\n     */\n  }, {\n    key: 'clearHistory',\n    value: function clearHistory() {\n      if (this.archive) this.archive.clear();\n      return this;\n    }\n\n    /**\n     * Releasing\n     * ----------\n     */\n\n    /**\n     * Methods releasing the cursor from memory.\n     */\n  }, {\n    key: 'release',\n    value: function release() {\n\n      // Removing listeners on parent\n      if (this._dynamicPath) this.tree.off('write', this._writeHandler);\n\n      this.tree.off('update', this._updateHandler);\n\n      // Unsubscribe from the parent\n      if (this.hash) delete this.tree._cursors[this.hash];\n\n      // Dereferencing\n      delete this.tree;\n      delete this.path;\n      delete this.solvedPath;\n      delete this.archive;\n\n      // Killing emitter\n      this.kill();\n      this.state.killed = true;\n    }\n\n    /**\n     * Output\n     * -------\n     */\n\n    /**\n     * Overriding the `toJSON` method for convenient use with JSON.stringify.\n     *\n     * @return {mixed} - Data at cursor.\n     */\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return this.serialize();\n    }\n\n    /**\n     * Overriding the `toString` method for debugging purposes.\n     *\n     * @return {string} - The cursor's identity.\n     */\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return this._identity;\n    }\n  }]);\n\n  return Cursor;\n})(_emmett2['default']);\n\nexports['default'] = Cursor;\nif (typeof Symbol === 'function' && typeof Symbol.iterator !== 'undefined') {\n  Cursor.prototype[Symbol.iterator] = function () {\n    var array = this._get().data;\n\n    if (!_type2['default'].array(array)) throw Error('baobab.Cursor.@@iterate: cannot iterate a non-list type.');\n\n    var i = 0;\n\n    var cursor = this,\n        length = array.length;\n\n    return {\n      next: function next() {\n        if (i < length) {\n          return {\n            value: cursor.select(i++)\n          };\n        }\n\n        return {\n          done: true\n        };\n      }\n    };\n  };\n}\n\n/**\n * Setter Methods\n * ---------------\n *\n * Those methods are dynamically assigned to the class for DRY reasons.\n */\n\n// Not using a Set so that ES5 consumers don't pay a bundle size price\nvar INTRANSITIVE_SETTERS = {\n  unset: true,\n  pop: true,\n  shift: true\n};\n\n/**\n * Function creating a setter method for the Cursor class.\n *\n * @param {string}   name          - the method's name.\n * @param {function} [typeChecker] - a function checking that the given value is\n *                                   valid for the given operation.\n */\nfunction makeSetter(name, typeChecker) {\n\n  /**\n   * Binding a setter method to the Cursor class and having the following\n   * definition.\n   *\n   * Note: this is not really possible to make those setters variadic because\n   * it would create an impossible polymorphism with path.\n   *\n   * @todo: perform value validation elsewhere so that tree.update can\n   * beneficiate from it.\n   *\n   * Arity (1):\n   * @param  {mixed} value - New value to set at cursor's path.\n   *\n   * Arity (2):\n   * @param  {path}  path  - Subpath to update starting from cursor's.\n   * @param  {mixed} value - New value to set.\n   *\n   * @return {mixed}       - Data at path.\n   */\n  Cursor.prototype[name] = function (path, value) {\n\n    // We should warn the user if he applies to many arguments to the function\n    if (arguments.length > 2) throw (0, _helpers.makeError)('Baobab.Cursor.' + name + ': too many arguments.');\n\n    // Handling arities\n    if (arguments.length === 1 && !INTRANSITIVE_SETTERS[name]) {\n      value = path;\n      path = [];\n    }\n\n    // Coerce path\n    path = (0, _helpers.coercePath)(path);\n\n    // Checking the path's validity\n    if (!_type2['default'].path(path)) throw (0, _helpers.makeError)('Baobab.Cursor.' + name + ': invalid path.', { path: path });\n\n    // Checking the value's validity\n    if (typeChecker && !typeChecker(value)) throw (0, _helpers.makeError)('Baobab.Cursor.' + name + ': invalid value.', { path: path, value: value });\n\n    // Checking the solvability of the cursor's dynamic path\n    if (!this.solvedPath) throw (0, _helpers.makeError)('Baobab.Cursor.' + name + ': the dynamic path of the cursor cannot be solved.', { path: this.path });\n\n    var fullPath = this.solvedPath.concat(path);\n\n    // Filing the update to the tree\n    return this.tree.update(fullPath, {\n      type: name,\n      value: value\n    });\n  };\n}\n\n/**\n * Making the necessary setters.\n */\nmakeSetter('set');\nmakeSetter('unset');\nmakeSetter('apply', _type2['default']['function']);\nmakeSetter('push');\nmakeSetter('concat', _type2['default'].array);\nmakeSetter('unshift');\nmakeSetter('pop');\nmakeSetter('shift');\nmakeSetter('splice', _type2['default'].splicer);\nmakeSetter('merge', _type2['default'].object);\nmakeSetter('deepMerge', _type2['default'].object);\nmodule.exports = exports['default'];\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/baobab/dist/cursor.js\n ** module id = 13\n ** module chunks = 0\n **/","/**\n * Baobab Monkeys\n * ===============\n *\n * Exposing both handy monkey definitions and the underlying working class.\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nvar _type = require('./type');\n\nvar _type2 = _interopRequireDefault(_type);\n\nvar _update2 = require('./update');\n\nvar _update3 = _interopRequireDefault(_update2);\n\nvar _helpers = require('./helpers');\n\n/**\n * Monkey Definition class\n * Note: The only reason why this is a class is to be able to spot it within\n * otherwise ordinary data.\n *\n * @constructor\n * @param {array|object} definition - The formal definition of the monkey.\n */\n\nvar MonkeyDefinition = function MonkeyDefinition(definition) {\n  var _this = this;\n\n  _classCallCheck(this, MonkeyDefinition);\n\n  var monkeyType = _type2['default'].monkeyDefinition(definition);\n\n  if (!monkeyType) throw (0, _helpers.makeError)('Baobab.monkey: invalid definition.', { definition: definition });\n\n  this.type = monkeyType;\n\n  if (this.type === 'object') {\n    this.getter = definition.get;\n    this.projection = definition.cursors || {};\n    this.paths = Object.keys(this.projection).map(function (k) {\n      return _this.projection[k];\n    });\n    this.options = definition.options || {};\n  } else {\n    var offset = 1,\n        options = {};\n\n    if (_type2['default'].object(definition[definition.length - 1])) {\n      offset++;\n      options = definition[definition.length - 1];\n    }\n\n    this.getter = definition[definition.length - offset];\n    this.projection = definition.slice(0, -offset);\n    this.paths = this.projection;\n    this.options = options;\n  }\n\n  // Coercing paths for convenience\n  this.paths = this.paths.map(function (p) {\n    return [].concat(p);\n  });\n\n  // Does the definition contain dynamic paths\n  this.hasDynamicPaths = this.paths.some(_type2['default'].dynamicPath);\n}\n\n/**\n * Monkey core class\n *\n * @constructor\n * @param {Baobab}           tree       - The bound tree.\n * @param {MonkeyDefinition} definition - A definition instance.\n */\n;\n\nexports.MonkeyDefinition = MonkeyDefinition;\n\nvar Monkey = (function () {\n  function Monkey(tree, pathInTree, definition) {\n    var _this2 = this;\n\n    _classCallCheck(this, Monkey);\n\n    // Properties\n    this.tree = tree;\n    this.path = pathInTree;\n    this.definition = definition;\n\n    // Adapting the definition's paths & projection to this monkey's case\n    var projection = definition.projection,\n        relative = _helpers.solveRelativePath.bind(null, pathInTree.slice(0, -1));\n\n    if (definition.type === 'object') {\n      this.projection = Object.keys(projection).reduce(function (acc, k) {\n        acc[k] = relative(projection[k]);\n        return acc;\n      }, {});\n      this.depPaths = Object.keys(this.projection).map(function (k) {\n        return _this2.projection[k];\n      });\n    } else {\n      this.projection = projection.map(relative);\n      this.depPaths = this.projection;\n    }\n\n    // Internal state\n    this.state = {\n      killed: false\n    };\n\n    /**\n     * Listener on the tree's `write` event.\n     *\n     * When the tree writes, this listener will check whether the updated paths\n     * are of any use to the monkey and, if so, will update the tree's node\n     * where the monkey sits.\n     */\n    this.writeListener = function (_ref) {\n      var path = _ref.data.path;\n\n      if (_this2.state.killed) return;\n\n      // Is the monkey affected by the current write event?\n      var concerned = (0, _helpers.solveUpdate)([path], _this2.relatedPaths());\n\n      if (concerned) _this2.update();\n    };\n\n    /**\n     * Listener on the tree's `monkey` event.\n     *\n     * When another monkey updates, this listener will check whether the\n     * updated paths are of any use to the monkey and, if so, will update the\n     * tree's node where the monkey sits.\n     */\n    this.recursiveListener = function (_ref2) {\n      var _ref2$data = _ref2.data;\n      var monkey = _ref2$data.monkey;\n      var path = _ref2$data.path;\n\n      if (_this2.state.killed) return;\n\n      // Breaking if this is the same monkey\n      if (_this2 === monkey) return;\n\n      // Is the monkey affected by the current monkey event?\n      var concerned = (0, _helpers.solveUpdate)([path], _this2.relatedPaths(false));\n\n      if (concerned) _this2.update();\n    };\n\n    // Binding listeners\n    this.tree.on('write', this.writeListener);\n    this.tree.on('_monkey', this.recursiveListener);\n\n    // Updating relevant node\n    this.update();\n  }\n\n  /**\n   * Method returning solved paths related to the monkey.\n   *\n   * @param  {boolean} recursive - Should we compute recursive paths?\n   * @return {array}             - An array of related paths.\n   */\n\n  _createClass(Monkey, [{\n    key: 'relatedPaths',\n    value: function relatedPaths() {\n      var _this3 = this;\n\n      var recursive = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];\n\n      var paths = undefined;\n\n      if (this.definition.hasDynamicPaths) paths = this.depPaths.map(function (p) {\n        return (0, _helpers.getIn)(_this3.tree._data, p).solvedPath;\n      });else paths = this.depPaths;\n\n      var isRecursive = recursive && this.depPaths.some(function (p) {\n        return !!_type2['default'].monkeyPath(_this3.tree._monkeys, p);\n      });\n\n      if (!isRecursive) return paths;\n\n      return paths.reduce(function (accumulatedPaths, path) {\n        var monkeyPath = _type2['default'].monkeyPath(_this3.tree._monkeys, path);\n\n        if (!monkeyPath) return accumulatedPaths.concat([path]);\n\n        // Solving recursive path\n        var relatedMonkey = (0, _helpers.getIn)(_this3.tree._monkeys, monkeyPath).data;\n\n        return accumulatedPaths.concat(relatedMonkey.relatedPaths());\n      }, []);\n    }\n\n    /**\n     * Method used to update the tree's internal data with a lazy getter holding\n     * the computed data.\n     *\n     * @return {Monkey} - Returns itself for chaining purposes.\n     */\n  }, {\n    key: 'update',\n    value: function update() {\n      var deps = this.tree.project(this.projection);\n\n      var lazyGetter = (function (tree, def, data) {\n        var cache = null,\n            alreadyComputed = false;\n\n        return function () {\n\n          if (!alreadyComputed) {\n            cache = def.getter.apply(tree, def.type === 'object' ? [data] : data);\n\n            if (tree.options.immutable && def.options.immutable !== false) (0, _helpers.deepFreeze)(cache);\n\n            alreadyComputed = true;\n          }\n\n          return cache;\n        };\n      })(this.tree, this.definition, deps);\n\n      lazyGetter.isLazyGetter = true;\n\n      // Should we write the lazy getter in the tree or solve it right now?\n      if (this.tree.options.lazyMonkeys) {\n        this.tree._data = (0, _update3['default'])(this.tree._data, this.path, {\n          type: 'monkey',\n          value: lazyGetter\n        }, this.tree.options).data;\n      } else {\n        var result = (0, _update3['default'])(this.tree._data, this.path, {\n          type: 'set',\n          value: lazyGetter(),\n          options: {\n            mutableLeaf: !this.definition.options.immutable\n          }\n        }, this.tree.options);\n\n        if ('data' in result) this.tree._data = result.data;\n      }\n\n      // Notifying the monkey's update so we can handle recursivity\n      this.tree.emit('_monkey', { monkey: this, path: this.path });\n\n      return this;\n    }\n\n    /**\n     * Method releasing the monkey from memory.\n     */\n  }, {\n    key: 'release',\n    value: function release() {\n\n      // Unbinding events\n      this.tree.off('write', this.writeListener);\n      this.tree.off('_monkey', this.monkeyListener);\n      this.state.killed = true;\n\n      // Deleting properties\n      // NOTE: not deleting this.definition because some strange things happen\n      // in the _refreshMonkeys method. See #372.\n      delete this.projection;\n      delete this.depPaths;\n      delete this.tree;\n    }\n  }]);\n\n  return Monkey;\n})();\n\nexports.Monkey = Monkey;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/baobab/dist/monkey.js\n ** module id = 14\n ** module chunks = 0\n **/","/**\n * Baobab Type Checking\n * =====================\n *\n * Helpers functions used throughout the library to perform some type\n * tests at runtime.\n *\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _monkey = require('./monkey');\n\nvar type = {};\n\n/**\n * Helpers\n * --------\n */\n\n/**\n * Checking whether the given variable is of any of the given types.\n *\n * @todo   Optimize this function by dropping `some`.\n *\n * @param  {mixed} target  - Variable to test.\n * @param  {array} allowed - Array of allowed types.\n * @return {boolean}\n */\nfunction anyOf(target, allowed) {\n  return allowed.some(function (t) {\n    return type[t](target);\n  });\n}\n\n/**\n * Simple types\n * -------------\n */\n\n/**\n * Checking whether the given variable is an array.\n *\n * @param  {mixed} target - Variable to test.\n * @return {boolean}\n */\ntype.array = function (target) {\n  return Array.isArray(target);\n};\n\n/**\n * Checking whether the given variable is an object.\n *\n * @param  {mixed} target - Variable to test.\n * @return {boolean}\n */\ntype.object = function (target) {\n  return target && typeof target === 'object' && !Array.isArray(target) && !(target instanceof Date) && !(target instanceof RegExp) && !(typeof Map === 'function' && target instanceof Map) && !(typeof Set === 'function' && target instanceof Set);\n};\n\n/**\n * Checking whether the given variable is a string.\n *\n * @param  {mixed} target - Variable to test.\n * @return {boolean}\n */\ntype.string = function (target) {\n  return typeof target === 'string';\n};\n\n/**\n * Checking whether the given variable is a number.\n *\n * @param  {mixed} target - Variable to test.\n * @return {boolean}\n */\ntype.number = function (target) {\n  return typeof target === 'number';\n};\n\n/**\n * Checking whether the given variable is a function.\n *\n * @param  {mixed} target - Variable to test.\n * @return {boolean}\n */\ntype['function'] = function (target) {\n  return typeof target === 'function';\n};\n\n/**\n * Checking whether the given variable is a JavaScript primitive.\n *\n * @param  {mixed} target - Variable to test.\n * @return {boolean}\n */\ntype.primitive = function (target) {\n  return target !== Object(target);\n};\n\n/**\n * Complex types\n * --------------\n */\n\n/**\n * Checking whether the given variable is a valid splicer.\n *\n * @param  {mixed} target    - Variable to test.\n * @param  {array} [allowed] - Optional valid types in path.\n * @return {boolean}\n */\ntype.splicer = function (target) {\n  if (!type.array(target) || target.length < 2) return false;\n\n  return anyOf(target[0], ['number', 'function', 'object']) && type.number(target[1]);\n};\n\n/**\n * Checking whether the given variable is a valid cursor path.\n *\n * @param  {mixed} target    - Variable to test.\n * @param  {array} [allowed] - Optional valid types in path.\n * @return {boolean}\n */\n\n// Order is important for performance reasons\nvar ALLOWED_FOR_PATH = ['string', 'number', 'function', 'object'];\n\ntype.path = function (target) {\n  if (!target && target !== 0 && target !== '') return false;\n\n  return [].concat(target).every(function (step) {\n    return anyOf(step, ALLOWED_FOR_PATH);\n  });\n};\n\n/**\n * Checking whether the given path is a dynamic one.\n *\n * @param  {mixed} path - The path to test.\n * @return {boolean}\n */\ntype.dynamicPath = function (path) {\n  return path.some(function (step) {\n    return type['function'](step) || type.object(step);\n  });\n};\n\n/**\n * Retrieve any monkey subpath in the given path or null if the path never comes\n * across computed data.\n *\n * @param  {mixed} data - The data to test.\n * @param  {array} path - The path to test.\n * @return {boolean}\n */\ntype.monkeyPath = function (data, path) {\n  var subpath = [];\n\n  var c = data,\n      i = undefined,\n      l = undefined;\n\n  for (i = 0, l = path.length; i < l; i++) {\n    subpath.push(path[i]);\n\n    if (typeof c !== 'object') return null;\n\n    c = c[path[i]];\n\n    if (c instanceof _monkey.Monkey) return subpath;\n  }\n\n  return null;\n};\n\n/**\n * Check if the given object property is a lazy getter used by a monkey.\n *\n * @param  {mixed}   o           - The target object.\n * @param  {string}  propertyKey - The property to test.\n * @return {boolean}\n */\ntype.lazyGetter = function (o, propertyKey) {\n  var descriptor = Object.getOwnPropertyDescriptor(o, propertyKey);\n\n  return descriptor && descriptor.get && descriptor.get.isLazyGetter === true;\n};\n\n/**\n * Returns the type of the given monkey definition or `null` if invalid.\n *\n * @param  {mixed} definition - The definition to check.\n * @return {string|null}\n */\ntype.monkeyDefinition = function (definition) {\n\n  if (type.object(definition)) {\n    if (!type['function'](definition.get) || definition.cursors && (!type.object(definition.cursors) || !Object.keys(definition.cursors).every(function (k) {\n      return type.path(definition.cursors[k]);\n    }))) return null;\n\n    return 'object';\n  } else if (type.array(definition)) {\n    var offset = 1;\n\n    if (type.object(definition[definition.length - 1])) offset++;\n\n    if (!type['function'](definition[definition.length - offset]) || !definition.slice(0, -offset).every(function (p) {\n      return type.path(p);\n    })) return null;\n\n    return 'array';\n  }\n\n  return null;\n};\n\n/**\n * Checking whether the given watcher definition is valid.\n *\n * @param  {mixed}   definition - The definition to check.\n * @return {boolean}\n */\ntype.watcherMapping = function (definition) {\n  return type.object(definition) && Object.keys(definition).every(function (k) {\n    return type.path(definition[k]);\n  });\n};\n\n/**\n * Checking whether the given string is a valid operation type.\n *\n * @param  {mixed} string - The string to test.\n * @return {boolean}\n */\n\n// Ordered by likeliness\nvar VALID_OPERATIONS = ['set', 'apply', 'push', 'unshift', 'concat', 'pop', 'shift', 'deepMerge', 'merge', 'splice', 'unset'];\n\ntype.operationType = function (string) {\n  return typeof string === 'string' && !! ~VALID_OPERATIONS.indexOf(string);\n};\n\nexports['default'] = type;\nmodule.exports = exports['default'];\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/baobab/dist/type.js\n ** module id = 15\n ** module chunks = 0\n **/","/**\n * Baobab Update\n * ==============\n *\n * The tree's update scheme.\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports['default'] = update;\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }\n\nvar _type = require('./type');\n\nvar _type2 = _interopRequireDefault(_type);\n\nvar _helpers = require('./helpers');\n\nfunction err(operation, expectedTarget, path) {\n  return (0, _helpers.makeError)('Baobab.update: cannot apply the \"' + operation + '\" on ' + ('a non ' + expectedTarget + ' (path: /' + path.join('/') + ').'), { path: path });\n}\n\n/**\n * Function aiming at applying a single update operation on the given tree's\n * data.\n *\n * @param  {mixed}  data      - The tree's data.\n * @param  {path}   path      - Path of the update.\n * @param  {object} operation - The operation to apply.\n * @param  {object} [opts]    - Optional options.\n * @return {mixed}            - Both the new tree's data and the updated node.\n */\n\nfunction update(data, path, operation) {\n  var opts = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];\n  var operationType = operation.type;\n  var value = operation.value;\n  var _operation$options = operation.options;\n  var operationOptions = _operation$options === undefined ? {} : _operation$options;\n\n  // Dummy root, so we can shift and alter the root\n  var dummy = { root: data },\n      dummyPath = ['root'].concat(_toConsumableArray(path)),\n      currentPath = [];\n\n  // Walking the path\n  var p = dummy,\n      i = undefined,\n      l = undefined,\n      s = undefined;\n\n  for (i = 0, l = dummyPath.length; i < l; i++) {\n\n    // Current item's reference is therefore p[s]\n    // The reason why we don't create a variable here for convenience\n    // is because we actually need to mutate the reference.\n    s = dummyPath[i];\n\n    // Updating the path\n    if (i > 0) currentPath.push(s);\n\n    // If we reached the end of the path, we apply the operation\n    if (i === l - 1) {\n\n      /**\n       * Set\n       */\n      if (operationType === 'set') {\n\n        // Purity check\n        if (opts.pure && p[s] === value) return { node: p[s] };\n\n        if (_type2['default'].lazyGetter(p, s)) {\n          Object.defineProperty(p, s, {\n            value: value,\n            enumerable: true,\n            configurable: true\n          });\n        } else if (opts.persistent && !operationOptions.mutableLeaf) {\n          p[s] = (0, _helpers.shallowClone)(value);\n        } else {\n          p[s] = value;\n        }\n      }\n\n      /**\n       * Monkey\n       */\n      else if (operationType === 'monkey') {\n          Object.defineProperty(p, s, {\n            get: value,\n            enumerable: true,\n            configurable: true\n          });\n        }\n\n        /**\n         * Apply\n         */\n        else if (operationType === 'apply') {\n            var result = value(p[s]);\n\n            // Purity check\n            if (opts.pure && p[s] === result) return { node: p[s] };\n\n            if (_type2['default'].lazyGetter(p, s)) {\n              Object.defineProperty(p, s, {\n                value: result,\n                enumerable: true,\n                configurable: true\n              });\n            } else if (opts.persistent) {\n              p[s] = (0, _helpers.shallowClone)(result);\n            } else {\n              p[s] = result;\n            }\n          }\n\n          /**\n           * Push\n           */\n          else if (operationType === 'push') {\n              if (!_type2['default'].array(p[s])) throw err('push', 'array', currentPath);\n\n              if (opts.persistent) p[s] = p[s].concat([value]);else p[s].push(value);\n            }\n\n            /**\n             * Unshift\n             */\n            else if (operationType === 'unshift') {\n                if (!_type2['default'].array(p[s])) throw err('unshift', 'array', currentPath);\n\n                if (opts.persistent) p[s] = [value].concat(p[s]);else p[s].unshift(value);\n              }\n\n              /**\n               * Concat\n               */\n              else if (operationType === 'concat') {\n                  if (!_type2['default'].array(p[s])) throw err('concat', 'array', currentPath);\n\n                  if (opts.persistent) p[s] = p[s].concat(value);else p[s].push.apply(p[s], value);\n                }\n\n                /**\n                 * Splice\n                 */\n                else if (operationType === 'splice') {\n                    if (!_type2['default'].array(p[s])) throw err('splice', 'array', currentPath);\n\n                    if (opts.persistent) p[s] = _helpers.splice.apply(null, [p[s]].concat(value));else p[s].splice.apply(p[s], value);\n                  }\n\n                  /**\n                   * Pop\n                   */\n                  else if (operationType === 'pop') {\n                      if (!_type2['default'].array(p[s])) throw err('pop', 'array', currentPath);\n\n                      if (opts.persistent) p[s] = (0, _helpers.splice)(p[s], -1, 1);else p[s].pop();\n                    }\n\n                    /**\n                     * Shift\n                     */\n                    else if (operationType === 'shift') {\n                        if (!_type2['default'].array(p[s])) throw err('shift', 'array', currentPath);\n\n                        if (opts.persistent) p[s] = (0, _helpers.splice)(p[s], 0, 1);else p[s].shift();\n                      }\n\n                      /**\n                       * Unset\n                       */\n                      else if (operationType === 'unset') {\n                          if (_type2['default'].object(p)) delete p[s];else if (_type2['default'].array(p)) p.splice(s, 1);\n                        }\n\n                        /**\n                         * Merge\n                         */\n                        else if (operationType === 'merge') {\n                            if (!_type2['default'].object(p[s])) throw err('merge', 'object', currentPath);\n\n                            if (opts.persistent) p[s] = (0, _helpers.shallowMerge)({}, p[s], value);else p[s] = (0, _helpers.shallowMerge)(p[s], value);\n                          }\n\n                          /**\n                           * Deep merge\n                           */\n                          else if (operationType === 'deepMerge') {\n                              if (!_type2['default'].object(p[s])) throw err('deepMerge', 'object', currentPath);\n\n                              if (opts.persistent) p[s] = (0, _helpers.deepMerge)({}, p[s], value);else p[s] = (0, _helpers.deepMerge)(p[s], value);\n                            }\n\n      // Deep freezing the resulting value\n      if (opts.immutable && !operationOptions.mutableLeaf) (0, _helpers.deepFreeze)(p);\n\n      break;\n    }\n\n    // If we reached a leaf, we override by setting an empty object\n    else if (_type2['default'].primitive(p[s])) {\n        p[s] = {};\n      }\n\n      // Else, we shift the reference and continue the path\n      else if (opts.persistent) {\n          p[s] = (0, _helpers.shallowClone)(p[s]);\n        }\n\n    // Should we freeze the current step before continuing?\n    if (opts.immutable && l > 0) (0, _helpers.freeze)(p);\n\n    p = p[s];\n  }\n\n  // If we are updating a dynamic node, we need not return the affected node\n  if (_type2['default'].lazyGetter(p, s)) return { data: dummy.root };\n\n  // Returning new data object\n  return { data: dummy.root, node: p[s] };\n}\n\nmodule.exports = exports['default'];\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/baobab/dist/update.js\n ** module id = 16\n ** module chunks = 0\n **/","/* eslint eqeqeq: 0 */\n\n/**\n * Baobab Helpers\n * ===============\n *\n * Miscellaneous helper functions.\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nexports.arrayFrom = arrayFrom;\nexports.before = before;\nexports.coercePath = coercePath;\nexports.getIn = getIn;\nexports.makeError = makeError;\nexports.solveRelativePath = solveRelativePath;\nexports.solveUpdate = solveUpdate;\nexports.splice = splice;\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nvar _monkey = require('./monkey');\n\nvar _type = require('./type');\n\nvar _type2 = _interopRequireDefault(_type);\n\n/**\n * Noop function\n */\nvar noop = Function.prototype;\n\n/**\n * Function returning the index of the first element of a list matching the\n * given predicate.\n *\n * @param  {array}     a  - The target array.\n * @param  {function}  fn - The predicate function.\n * @return {mixed}        - The index of the first matching item or -1.\n */\nfunction index(a, fn) {\n  var i = undefined,\n      l = undefined;\n  for (i = 0, l = a.length; i < l; i++) {\n    if (fn(a[i])) return i;\n  }\n  return -1;\n}\n\n/**\n * Efficient slice function used to clone arrays or parts of them.\n *\n * @param  {array} array - The array to slice.\n * @return {array}       - The sliced array.\n */\nfunction slice(array) {\n  var newArray = new Array(array.length);\n\n  var i = undefined,\n      l = undefined;\n\n  for (i = 0, l = array.length; i < l; i++) newArray[i] = array[i];\n\n  return newArray;\n}\n\n/**\n * Archive abstraction\n *\n * @constructor\n * @param {integer} size - Maximum number of records to store.\n */\n\nvar Archive = (function () {\n  function Archive(size) {\n    _classCallCheck(this, Archive);\n\n    this.size = size;\n    this.records = [];\n  }\n\n  /**\n   * Function creating a real array from what should be an array but is not.\n   * I'm looking at you nasty `arguments`...\n   *\n   * @param  {mixed} culprit - The culprit to convert.\n   * @return {array}         - The real array.\n   */\n\n  /**\n   * Method retrieving the records.\n   *\n   * @return {array} - The records.\n   */\n\n  _createClass(Archive, [{\n    key: 'get',\n    value: function get() {\n      return this.records;\n    }\n\n    /**\n     * Method adding a record to the archive\n     *\n     * @param {object}  record - The record to store.\n     * @return {Archive}       - The archive itself for chaining purposes.\n     */\n  }, {\n    key: 'add',\n    value: function add(record) {\n      this.records.unshift(record);\n\n      // If the number of records is exceeded, we truncate the records\n      if (this.records.length > this.size) this.records.length = this.size;\n\n      return this;\n    }\n\n    /**\n     * Method clearing the records.\n     *\n     * @return {Archive} - The archive itself for chaining purposes.\n     */\n  }, {\n    key: 'clear',\n    value: function clear() {\n      this.records = [];\n      return this;\n    }\n\n    /**\n     * Method to go back in time.\n     *\n     * @param {integer} steps - Number of steps we should go back by.\n     * @return {number}       - The last record.\n     */\n  }, {\n    key: 'back',\n    value: function back(steps) {\n      var record = this.records[steps - 1];\n\n      if (record) this.records = this.records.slice(steps);\n      return record;\n    }\n  }]);\n\n  return Archive;\n})();\n\nexports.Archive = Archive;\n\nfunction arrayFrom(culprit) {\n  return slice(culprit);\n}\n\n/**\n * Function decorating one function with another that will be called before the\n * decorated one.\n *\n * @param  {function} decorator - The decorating function.\n * @param  {function} fn        - The function to decorate.\n * @return {function}           - The decorated function.\n */\n\nfunction before(decorator, fn) {\n  return function () {\n    decorator.apply(null, arguments);\n    fn.apply(null, arguments);\n  };\n}\n\n/**\n * Function cloning the given regular expression. Supports `y` and `u` flags\n * already.\n *\n * @param  {RegExp} re - The target regular expression.\n * @return {RegExp}    - The cloned regular expression.\n */\nfunction cloneRegexp(re) {\n  var pattern = re.source;\n\n  var flags = '';\n\n  if (re.global) flags += 'g';\n  if (re.multiline) flags += 'm';\n  if (re.ignoreCase) flags += 'i';\n  if (re.sticky) flags += 'y';\n  if (re.unicode) flags += 'u';\n\n  return new RegExp(pattern, flags);\n}\n\n/**\n * Function cloning the given variable.\n *\n * @todo: implement a faster way to clone an array.\n *\n * @param  {boolean} deep - Should we deep clone the variable.\n * @param  {mixed}   item - The variable to clone\n * @return {mixed}        - The cloned variable.\n */\nfunction cloner(deep, item) {\n  if (!item || typeof item !== 'object' || item instanceof Error || item instanceof _monkey.MonkeyDefinition || item instanceof _monkey.Monkey || 'ArrayBuffer' in global && item instanceof ArrayBuffer) return item;\n\n  // Array\n  if (_type2['default'].array(item)) {\n    if (deep) {\n      var a = [];\n\n      var i = undefined,\n          l = undefined;\n\n      for (i = 0, l = item.length; i < l; i++) a.push(cloner(true, item[i]));\n      return a;\n    }\n\n    return slice(item);\n  }\n\n  // Date\n  if (item instanceof Date) return new Date(item.getTime());\n\n  // RegExp\n  if (item instanceof RegExp) return cloneRegexp(item);\n\n  // Object\n  if (_type2['default'].object(item)) {\n    var o = {};\n\n    var k = undefined;\n\n    // NOTE: could be possible to erase computed properties through `null`.\n    for (k in item) {\n      if (_type2['default'].lazyGetter(item, k)) {\n        Object.defineProperty(o, k, {\n          get: Object.getOwnPropertyDescriptor(item, k).get,\n          enumerable: true,\n          configurable: true\n        });\n      } else if (item.hasOwnProperty(k)) {\n        o[k] = deep ? cloner(true, item[k]) : item[k];\n      }\n    }\n    return o;\n  }\n\n  return item;\n}\n\n/**\n * Exporting shallow and deep cloning functions.\n */\nvar shallowClone = cloner.bind(null, false),\n    deepClone = cloner.bind(null, true);\n\nexports.shallowClone = shallowClone;\nexports.deepClone = deepClone;\n\n/**\n * Coerce the given variable into a full-fledged path.\n *\n * @param  {mixed} target - The variable to coerce.\n * @return {array}        - The array path.\n */\n\nfunction coercePath(target) {\n  if (target || target === 0 || target === '') return target;\n  return [];\n}\n\n/**\n * Function comparing an object's properties to a given descriptive\n * object.\n *\n * @param  {object} object      - The object to compare.\n * @param  {object} description - The description's mapping.\n * @return {boolean}            - Whether the object matches the description.\n */\nfunction compare(object, description) {\n  var ok = true,\n      k = undefined;\n\n  // If we reached here via a recursive call, object may be undefined because\n  // not all items in a collection will have the same deep nesting structure.\n  if (!object) return false;\n\n  for (k in description) {\n    if (_type2['default'].object(description[k])) {\n      ok = ok && compare(object[k], description[k]);\n    } else if (_type2['default'].array(description[k])) {\n      ok = ok && !! ~description[k].indexOf(object[k]);\n    } else {\n      if (object[k] !== description[k]) return false;\n    }\n  }\n\n  return ok;\n}\n\n/**\n * Function freezing the given variable if possible.\n *\n * @param  {boolean} deep - Should we recursively freeze the given objects?\n * @param  {object}  o    - The variable to freeze.\n * @return {object}    - The merged object.\n */\nfunction freezer(deep, o) {\n  if (typeof o !== 'object' || o === null || o instanceof _monkey.Monkey) return;\n\n  Object.freeze(o);\n\n  if (!deep) return;\n\n  if (Array.isArray(o)) {\n\n    // Iterating through the elements\n    var i = undefined,\n        l = undefined;\n\n    for (i = 0, l = o.length; i < l; i++) freezer(true, o[i]);\n  } else {\n    var p = undefined,\n        k = undefined;\n\n    for (k in o) {\n      if (_type2['default'].lazyGetter(o, k)) continue;\n\n      p = o[k];\n\n      if (!p || !o.hasOwnProperty(k) || typeof p !== 'object' || Object.isFrozen(p)) continue;\n\n      freezer(true, p);\n    }\n  }\n}\n\n/**\n * Exporting both `freeze` and `deepFreeze` functions.\n * Note that if the engine does not support `Object.freeze` then this will\n * export noop functions instead.\n */\nvar isFreezeSupported = typeof Object.freeze === 'function';\n\nvar freeze = isFreezeSupported ? freezer.bind(null, false) : noop,\n    deepFreeze = isFreezeSupported ? freezer.bind(null, true) : noop;\n\nexports.freeze = freeze;\nexports.deepFreeze = deepFreeze;\n\n/**\n * Function retrieving nested data within the given object and according to\n * the given path.\n *\n * @todo: work if dynamic path hit objects also.\n * @todo: memoized perfgetters.\n *\n * @param  {object}  object - The object we need to get data from.\n * @param  {array}   path   - The path to follow.\n * @return {object}  result            - The result.\n * @return {mixed}   result.data       - The data at path, or `undefined`.\n * @return {array}   result.solvedPath - The solved path or `null`.\n * @return {boolean} result.exists     - Does the path exists in the tree?\n */\nvar NOT_FOUND_OBJECT = { data: undefined, solvedPath: null, exists: false };\n\nfunction getIn(object, path) {\n  if (!path) return NOT_FOUND_OBJECT;\n\n  var solvedPath = [];\n\n  var exists = true,\n      c = object,\n      idx = undefined,\n      i = undefined,\n      l = undefined;\n\n  for (i = 0, l = path.length; i < l; i++) {\n    if (!c) return {\n      data: undefined,\n      solvedPath: solvedPath.concat(path.slice(i)),\n      exists: false\n    };\n\n    if (typeof path[i] === 'function') {\n      if (!_type2['default'].array(c)) return NOT_FOUND_OBJECT;\n\n      idx = index(c, path[i]);\n      if (! ~idx) return NOT_FOUND_OBJECT;\n\n      solvedPath.push(idx);\n      c = c[idx];\n    } else if (typeof path[i] === 'object') {\n      if (!_type2['default'].array(c)) return NOT_FOUND_OBJECT;\n\n      idx = index(c, function (e) {\n        return compare(e, path[i]);\n      });\n      if (! ~idx) return NOT_FOUND_OBJECT;\n\n      solvedPath.push(idx);\n      c = c[idx];\n    } else {\n      solvedPath.push(path[i]);\n      exists = typeof c === 'object' && path[i] in c;\n      c = c[path[i]];\n    }\n  }\n\n  return { data: c, solvedPath: solvedPath, exists: exists };\n}\n\n/**\n * Little helper returning a JavaScript error carrying some data with it.\n *\n * @param  {string} message - The error message.\n * @param  {object} [data]  - Optional data to assign to the error.\n * @return {Error}          - The created error.\n */\n\nfunction makeError(message, data) {\n  var err = new Error(message);\n\n  for (var k in data) {\n    err[k] = data[k];\n  }return err;\n}\n\n/**\n * Function taking n objects to merge them together.\n * Note 1): the latter object will take precedence over the first one.\n * Note 2): the first object will be mutated to allow for perf scenarios.\n * Note 3): this function will consider monkeys as leaves.\n *\n * @param  {boolean}   deep    - Whether the merge should be deep or not.\n * @param  {...object} objects - Objects to merge.\n * @return {object}            - The merged object.\n */\nfunction merger(deep) {\n  for (var _len = arguments.length, objects = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    objects[_key - 1] = arguments[_key];\n  }\n\n  var o = objects[0];\n\n  var t = undefined,\n      i = undefined,\n      l = undefined,\n      k = undefined;\n\n  for (i = 1, l = objects.length; i < l; i++) {\n    t = objects[i];\n\n    for (k in t) {\n      if (deep && _type2['default'].object(t[k]) && !(t[k] instanceof _monkey.Monkey)) {\n        o[k] = merger(true, o[k] || {}, t[k]);\n      } else {\n        o[k] = t[k];\n      }\n    }\n  }\n\n  return o;\n}\n\n/**\n * Exporting both `shallowMerge` and `deepMerge` functions.\n */\nvar shallowMerge = merger.bind(null, false),\n    deepMerge = merger.bind(null, true);\n\nexports.shallowMerge = shallowMerge;\nexports.deepMerge = deepMerge;\n\n/**\n * Solving a potentially relative path.\n *\n * @param  {array} base - The base path from which to solve the path.\n * @param  {array} to   - The subpath to reach.\n * @param  {array}      - The solved absolute path.\n */\n\nfunction solveRelativePath(base, to) {\n  var solvedPath = [];\n\n  // Coercing to array\n  to = [].concat(to);\n\n  for (var i = 0, l = to.length; i < l; i++) {\n    var step = to[i];\n\n    if (step === '.') {\n      if (!i) solvedPath = base.slice(0);\n    } else if (step === '..') {\n      solvedPath = (!i ? base : solvedPath).slice(0, -1);\n    } else {\n      solvedPath.push(step);\n    }\n  }\n\n  return solvedPath;\n}\n\n/**\n * Function determining whether some paths in the tree were affected by some\n * updates that occurred at the given paths. This helper is mainly used at\n * cursor level to determine whether the cursor is concerned by the updates\n * fired at tree level.\n *\n * NOTES: 1) If performance become an issue, the following threefold loop\n *           can be simplified to a complex twofold one.\n *        2) A regex version could also work but I am not confident it would\n *           be faster.\n *        3) Another solution would be to keep a register of cursors like with\n *           the monkeys and update along this tree.\n *\n * @param  {array} affectedPaths - The paths that were updated.\n * @param  {array} comparedPaths - The paths that we are actually interested in.\n * @return {boolean}             - Is the update relevant to the compared\n *                                 paths?\n */\n\nfunction solveUpdate(affectedPaths, comparedPaths) {\n  var i = undefined,\n      j = undefined,\n      k = undefined,\n      l = undefined,\n      m = undefined,\n      n = undefined,\n      p = undefined,\n      c = undefined,\n      s = undefined;\n\n  // Looping through possible paths\n  for (i = 0, l = affectedPaths.length; i < l; i++) {\n    p = affectedPaths[i];\n\n    if (!p.length) return true;\n\n    // Looping through logged paths\n    for (j = 0, m = comparedPaths.length; j < m; j++) {\n      c = comparedPaths[j];\n\n      if (!c || !c.length) return true;\n\n      // Looping through steps\n      for (k = 0, n = c.length; k < n; k++) {\n        s = c[k];\n\n        // If path is not relevant, we break\n        // NOTE: the '!=' instead of '!==' is required here!\n        if (s != p[k]) break;\n\n        // If we reached last item and we are relevant\n        if (k + 1 === n || k + 1 === p.length) return true;\n      }\n    }\n  }\n\n  return false;\n}\n\n/**\n * Non-mutative version of the splice array method.\n *\n * @param  {array}    array        - The array to splice.\n * @param  {integer}  startIndex   - The start index.\n * @param  {integer}  nb           - Number of elements to remove.\n * @param  {...mixed} elements     - Elements to append after splicing.\n * @return {array}                 - The spliced array.\n */\n\nfunction splice(array, startIndex, nb) {\n  nb = Math.max(0, nb);\n\n  // Solving startIndex\n  if (_type2['default']['function'](startIndex)) startIndex = index(array, startIndex);\n  if (_type2['default'].object(startIndex)) startIndex = index(array, function (e) {\n    return compare(e, startIndex);\n  });\n\n  // Positive index\n\n  for (var _len2 = arguments.length, elements = Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {\n    elements[_key2 - 3] = arguments[_key2];\n  }\n\n  if (startIndex >= 0) return array.slice(0, startIndex).concat(elements).concat(array.slice(startIndex + nb));\n\n  // Negative index\n  return array.slice(0, array.length + startIndex).concat(elements).concat(array.slice(array.length + startIndex + nb));\n}\n\n/**\n * Function returning a unique incremental id each time it is called.\n *\n * @return {integer} - The latest unique id.\n */\nvar uniqid = (function () {\n  var i = 0;\n\n  return function () {\n    return i++;\n  };\n})();\n\nexports.uniqid = uniqid;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/baobab/dist/helpers.js\n ** module id = 17\n ** module chunks = 0\n **/","/**\n * Baobab Watchers\n * ================\n *\n * Abstraction used to listen and retrieve data from multiple parts of a\n * Baobab tree at once.\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nvar _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _emmett = require('emmett');\n\nvar _emmett2 = _interopRequireDefault(_emmett);\n\nvar _cursor = require('./cursor');\n\nvar _cursor2 = _interopRequireDefault(_cursor);\n\nvar _type = require('./type');\n\nvar _type2 = _interopRequireDefault(_type);\n\nvar _helpers = require('./helpers');\n\n/**\n * Watcher class.\n *\n * @constructor\n * @param {Baobab} tree     - The watched tree.\n * @param {object} mapping  - A mapping of the paths to watch in the tree.\n */\n\nvar Watcher = (function (_Emitter) {\n  _inherits(Watcher, _Emitter);\n\n  function Watcher(tree, mapping) {\n    var _this = this;\n\n    _classCallCheck(this, Watcher);\n\n    _get(Object.getPrototypeOf(Watcher.prototype), 'constructor', this).call(this);\n\n    // Properties\n    this.tree = tree;\n    this.mapping = null;\n\n    this.state = {\n      killed: false\n    };\n\n    // Initializing\n    this.refresh(mapping);\n\n    // Listening\n    this.handler = function (e) {\n      if (_this.state.killed) return;\n\n      var watchedPaths = _this.getWatchedPaths();\n\n      if ((0, _helpers.solveUpdate)(e.data.paths, watchedPaths)) return _this.emit('update');\n    };\n\n    this.tree.on('update', this.handler);\n  }\n\n  /**\n   * Method used to get the current watched paths.\n   *\n   * @return {array} - The array of watched paths.\n   */\n\n  _createClass(Watcher, [{\n    key: 'getWatchedPaths',\n    value: function getWatchedPaths() {\n      var _this2 = this;\n\n      var rawPaths = Object.keys(this.mapping).map(function (k) {\n        var v = _this2.mapping[k];\n\n        // Watcher mappings can accept a cursor\n        if (v instanceof _cursor2['default']) return v.solvedPath;\n\n        return _this2.mapping[k];\n      });\n\n      return rawPaths.reduce(function (cp, p) {\n\n        // Handling path polymorphisms\n        p = [].concat(p);\n\n        // Dynamic path?\n        if (_type2['default'].dynamicPath(p)) p = (0, _helpers.getIn)(_this2.tree._data, p).solvedPath;\n\n        if (!p) return cp;\n\n        // Facet path?\n        var monkeyPath = _type2['default'].monkeyPath(_this2.tree._monkeys, p);\n\n        if (monkeyPath) return cp.concat((0, _helpers.getIn)(_this2.tree._monkeys, monkeyPath).data.relatedPaths());\n\n        return cp.concat([p]);\n      }, []);\n    }\n\n    /**\n     * Method used to return a map of the watcher's cursors.\n     *\n     * @return {object} - TMap of relevant cursors.\n     */\n  }, {\n    key: 'getCursors',\n    value: function getCursors() {\n      var _this3 = this;\n\n      var cursors = {};\n\n      Object.keys(this.mapping).forEach(function (k) {\n        var path = _this3.mapping[k];\n\n        if (path instanceof _cursor2['default']) cursors[k] = path;else cursors[k] = _this3.tree.select(path);\n      });\n\n      return cursors;\n    }\n\n    /**\n     * Method used to refresh the watcher's mapping.\n     *\n     * @param  {object}  mapping  - The new mapping to apply.\n     * @return {Watcher}          - Itself for chaining purposes.\n     */\n  }, {\n    key: 'refresh',\n    value: function refresh(mapping) {\n\n      if (!_type2['default'].watcherMapping(mapping)) throw (0, _helpers.makeError)('Baobab.watch: invalid mapping.', { mapping: mapping });\n\n      this.mapping = mapping;\n\n      // Creating the get method\n      var projection = {};\n\n      for (var k in mapping) {\n        projection[k] = mapping[k] instanceof _cursor2['default'] ? mapping[k].path : mapping[k];\n      }this.get = this.tree.project.bind(this.tree, projection);\n    }\n\n    /**\n     * Methods releasing the watcher from memory.\n     */\n  }, {\n    key: 'release',\n    value: function release() {\n\n      this.tree.off('update', this.handler);\n      this.state.killed = true;\n      this.kill();\n    }\n  }]);\n\n  return Watcher;\n})(_emmett2['default']);\n\nexports['default'] = Watcher;\nmodule.exports = exports['default'];\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/baobab/dist/watcher.js\n ** module id = 18\n ** module chunks = 0\n **/","module.exports = \"<ion-modal-view> <ion-header-bar> <h1 class=title>Modal Title</h1> </ion-header-bar> <ion-content> <button class=\\\"button icon icon-left ion-ios-close-outline\\\" ng-click=closeModal()>Close Modal</button> </ion-content> </ion-modal-view>\";\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/components/tabs/dashboard/locationModal.html\n ** module id = 19\n ** module chunks = 0\n **/","module.exports = \"<ion-view view-title=Dashboard> <ion-nav-title> WEATHER GONG </ion-nav-title> <ion-content class=padding id=dashboard-page-container> <div class=current-weather-container> <div class=\\\"row header\\\"> <div class=col> </div> <div class=col></div> <div class=col></div> <div class=col> </div> <div class=col></div> <div class=col>'</div> <div class=col> </div> <div class=col></div> <div class=col></div> </div> <div class=row ng-repeat=\\\"row in currentData\\\"> <div class=col> <button class=\\\"icon ion-ios-minus-outline\\\"></button> </div> <div class=col>{{ row.location }}</div> <div class=col>{{ row.time }}</div> <div class=col>{{ row.wind }}</div> <div class=col>{{ row.windDirection }}</div> <div class=col>{{ row.temperature }}</div> <div class=col>{{ row.wave }}</div> <div class=col>{{ row.waveDirection }}</div> <div class=col> <button class=\\\"icon ion-ios-camera-outline\\\"/></div> </div> <div class=row> <div class=col> <button class=\\\"button icon ion-ios-plus-outline\\\" ng-click=addLocation()></button> </div> </div> </div> <div class=forecast-container> <h3> ( )</h3> <div class=\\\"row header\\\"> <div class=col> </div> <div class=col></div> <div class=col></div> <div class=col></div> <div class=col></div> <div class=col>'</div> <div class=col> </div> <div class=col></div> <div class=col></div> </div> <div class=row ng-repeat=\\\"row in forecastData\\\"> <div class=col> <button class=\\\"icon ion-ios-minus-outline\\\"></button> </div> <div class=col>{{ row.location }}</div> <div class=col>{{ row.time }}</div> <div class=col>{{ row.wind }}</div> <div class=col>{{ row.windDirection }}</div> <div class=col>{{ row.temperature }}</div> <div class=col>{{ row.wave }}</div> <div class=col>{{ row.waveDirection }}</div> </div> <div class=row> <div class=col> <button class=\\\"button icon ion-ios-plus-outline\\\" ng-click=addLocation()></button> </div> </div> </div> </ion-content> </ion-view>\";\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/components/tabs/dashboard/dashboard.html\n ** module id = 20\n ** module chunks = 0\n **/","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!./../../../../node_modules/css-loader/index.js!./../../../../node_modules/sass-loader/index.js!./dashboard.scss\");\nif(typeof content === 'string') content = [[module.id, content, '']];\n// add the styles to the DOM\nvar update = require(\"!./../../../../node_modules/style-loader/addStyles.js\")(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(module.hot) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!./../../../../node_modules/css-loader/index.js!./../../../../node_modules/sass-loader/index.js!./dashboard.scss\", function() {\n\t\t\tvar newContent = require(\"!!./../../../../node_modules/css-loader/index.js!./../../../../node_modules/sass-loader/index.js!./dashboard.scss\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/components/tabs/dashboard/dashboard.scss\n ** module id = 21\n ** module chunks = 0\n **/","exports = module.exports = require(\"./../../../../node_modules/css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \"#dashboard-page-container .scroll>div{margin-bottom:60px}#dashboard-page-container .scroll>div .col{text-align:right}#dashboard-page-container .scroll>div .col button.icon{font-size:21px;line-height:0;background:none;padding:0;margin:0;outline:0;border:none}\", \"\"]);\n\n// exports\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/css-loader!./~/sass-loader!./app/components/tabs/dashboard/dashboard.scss\n ** module id = 22\n ** module chunks = 0\n **/","/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n// css base code, injected by the css-loader\r\nmodule.exports = function() {\r\n\tvar list = [];\r\n\r\n\t// return the list of modules as css string\r\n\tlist.toString = function toString() {\r\n\t\tvar result = [];\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar item = this[i];\r\n\t\t\tif(item[2]) {\r\n\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\r\n\t\t\t} else {\r\n\t\t\t\tresult.push(item[1]);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result.join(\"\");\r\n\t};\r\n\r\n\t// import a list of modules into the list\r\n\tlist.i = function(modules, mediaQuery) {\r\n\t\tif(typeof modules === \"string\")\r\n\t\t\tmodules = [[null, modules, \"\"]];\r\n\t\tvar alreadyImportedModules = {};\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar id = this[i][0];\r\n\t\t\tif(typeof id === \"number\")\r\n\t\t\t\talreadyImportedModules[id] = true;\r\n\t\t}\r\n\t\tfor(i = 0; i < modules.length; i++) {\r\n\t\t\tvar item = modules[i];\r\n\t\t\t// skip already imported module\r\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\r\n\t\t\t//  when a module is imported multiple times with different media queries.\r\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\r\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\r\n\t\t\t\tif(mediaQuery && !item[2]) {\r\n\t\t\t\t\titem[2] = mediaQuery;\r\n\t\t\t\t} else if(mediaQuery) {\r\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\r\n\t\t\t\t}\r\n\t\t\t\tlist.push(item);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\treturn list;\r\n};\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/css-loader/lib/css-base.js\n ** module id = 23\n ** module chunks = 0\n **/","/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\nvar stylesInDom = {},\r\n\tmemoize = function(fn) {\r\n\t\tvar memo;\r\n\t\treturn function () {\r\n\t\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\r\n\t\t\treturn memo;\r\n\t\t};\r\n\t},\r\n\tisOldIE = memoize(function() {\r\n\t\treturn /msie [6-9]\\b/.test(window.navigator.userAgent.toLowerCase());\r\n\t}),\r\n\tgetHeadElement = memoize(function () {\r\n\t\treturn document.head || document.getElementsByTagName(\"head\")[0];\r\n\t}),\r\n\tsingletonElement = null,\r\n\tsingletonCounter = 0,\r\n\tstyleElementsInsertedAtTop = [];\r\n\r\nmodule.exports = function(list, options) {\r\n\tif(typeof DEBUG !== \"undefined\" && DEBUG) {\r\n\t\tif(typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\r\n\t}\r\n\r\n\toptions = options || {};\r\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\r\n\t// tags it will allow on a page\r\n\tif (typeof options.singleton === \"undefined\") options.singleton = isOldIE();\r\n\r\n\t// By default, add <style> tags to the bottom of <head>.\r\n\tif (typeof options.insertAt === \"undefined\") options.insertAt = \"bottom\";\r\n\r\n\tvar styles = listToStyles(list);\r\n\taddStylesToDom(styles, options);\r\n\r\n\treturn function update(newList) {\r\n\t\tvar mayRemove = [];\r\n\t\tfor(var i = 0; i < styles.length; i++) {\r\n\t\t\tvar item = styles[i];\r\n\t\t\tvar domStyle = stylesInDom[item.id];\r\n\t\t\tdomStyle.refs--;\r\n\t\t\tmayRemove.push(domStyle);\r\n\t\t}\r\n\t\tif(newList) {\r\n\t\t\tvar newStyles = listToStyles(newList);\r\n\t\t\taddStylesToDom(newStyles, options);\r\n\t\t}\r\n\t\tfor(var i = 0; i < mayRemove.length; i++) {\r\n\t\t\tvar domStyle = mayRemove[i];\r\n\t\t\tif(domStyle.refs === 0) {\r\n\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++)\r\n\t\t\t\t\tdomStyle.parts[j]();\r\n\t\t\t\tdelete stylesInDom[domStyle.id];\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n}\r\n\r\nfunction addStylesToDom(styles, options) {\r\n\tfor(var i = 0; i < styles.length; i++) {\r\n\t\tvar item = styles[i];\r\n\t\tvar domStyle = stylesInDom[item.id];\r\n\t\tif(domStyle) {\r\n\t\t\tdomStyle.refs++;\r\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\r\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\r\n\t\t\t}\r\n\t\t\tfor(; j < item.parts.length; j++) {\r\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tvar parts = [];\r\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\r\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\r\n\t\t\t}\r\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction listToStyles(list) {\r\n\tvar styles = [];\r\n\tvar newStyles = {};\r\n\tfor(var i = 0; i < list.length; i++) {\r\n\t\tvar item = list[i];\r\n\t\tvar id = item[0];\r\n\t\tvar css = item[1];\r\n\t\tvar media = item[2];\r\n\t\tvar sourceMap = item[3];\r\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\r\n\t\tif(!newStyles[id])\r\n\t\t\tstyles.push(newStyles[id] = {id: id, parts: [part]});\r\n\t\telse\r\n\t\t\tnewStyles[id].parts.push(part);\r\n\t}\r\n\treturn styles;\r\n}\r\n\r\nfunction insertStyleElement(options, styleElement) {\r\n\tvar head = getHeadElement();\r\n\tvar lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];\r\n\tif (options.insertAt === \"top\") {\r\n\t\tif(!lastStyleElementInsertedAtTop) {\r\n\t\t\thead.insertBefore(styleElement, head.firstChild);\r\n\t\t} else if(lastStyleElementInsertedAtTop.nextSibling) {\r\n\t\t\thead.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);\r\n\t\t} else {\r\n\t\t\thead.appendChild(styleElement);\r\n\t\t}\r\n\t\tstyleElementsInsertedAtTop.push(styleElement);\r\n\t} else if (options.insertAt === \"bottom\") {\r\n\t\thead.appendChild(styleElement);\r\n\t} else {\r\n\t\tthrow new Error(\"Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.\");\r\n\t}\r\n}\r\n\r\nfunction removeStyleElement(styleElement) {\r\n\tstyleElement.parentNode.removeChild(styleElement);\r\n\tvar idx = styleElementsInsertedAtTop.indexOf(styleElement);\r\n\tif(idx >= 0) {\r\n\t\tstyleElementsInsertedAtTop.splice(idx, 1);\r\n\t}\r\n}\r\n\r\nfunction createStyleElement(options) {\r\n\tvar styleElement = document.createElement(\"style\");\r\n\tstyleElement.type = \"text/css\";\r\n\tinsertStyleElement(options, styleElement);\r\n\treturn styleElement;\r\n}\r\n\r\nfunction createLinkElement(options) {\r\n\tvar linkElement = document.createElement(\"link\");\r\n\tlinkElement.rel = \"stylesheet\";\r\n\tinsertStyleElement(options, linkElement);\r\n\treturn linkElement;\r\n}\r\n\r\nfunction addStyle(obj, options) {\r\n\tvar styleElement, update, remove;\r\n\r\n\tif (options.singleton) {\r\n\t\tvar styleIndex = singletonCounter++;\r\n\t\tstyleElement = singletonElement || (singletonElement = createStyleElement(options));\r\n\t\tupdate = applyToSingletonTag.bind(null, styleElement, styleIndex, false);\r\n\t\tremove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);\r\n\t} else if(obj.sourceMap &&\r\n\t\ttypeof URL === \"function\" &&\r\n\t\ttypeof URL.createObjectURL === \"function\" &&\r\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\r\n\t\ttypeof Blob === \"function\" &&\r\n\t\ttypeof btoa === \"function\") {\r\n\t\tstyleElement = createLinkElement(options);\r\n\t\tupdate = updateLink.bind(null, styleElement);\r\n\t\tremove = function() {\r\n\t\t\tremoveStyleElement(styleElement);\r\n\t\t\tif(styleElement.href)\r\n\t\t\t\tURL.revokeObjectURL(styleElement.href);\r\n\t\t};\r\n\t} else {\r\n\t\tstyleElement = createStyleElement(options);\r\n\t\tupdate = applyToTag.bind(null, styleElement);\r\n\t\tremove = function() {\r\n\t\t\tremoveStyleElement(styleElement);\r\n\t\t};\r\n\t}\r\n\r\n\tupdate(obj);\r\n\r\n\treturn function updateStyle(newObj) {\r\n\t\tif(newObj) {\r\n\t\t\tif(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)\r\n\t\t\t\treturn;\r\n\t\t\tupdate(obj = newObj);\r\n\t\t} else {\r\n\t\t\tremove();\r\n\t\t}\r\n\t};\r\n}\r\n\r\nvar replaceText = (function () {\r\n\tvar textStore = [];\r\n\r\n\treturn function (index, replacement) {\r\n\t\ttextStore[index] = replacement;\r\n\t\treturn textStore.filter(Boolean).join('\\n');\r\n\t};\r\n})();\r\n\r\nfunction applyToSingletonTag(styleElement, index, remove, obj) {\r\n\tvar css = remove ? \"\" : obj.css;\r\n\r\n\tif (styleElement.styleSheet) {\r\n\t\tstyleElement.styleSheet.cssText = replaceText(index, css);\r\n\t} else {\r\n\t\tvar cssNode = document.createTextNode(css);\r\n\t\tvar childNodes = styleElement.childNodes;\r\n\t\tif (childNodes[index]) styleElement.removeChild(childNodes[index]);\r\n\t\tif (childNodes.length) {\r\n\t\t\tstyleElement.insertBefore(cssNode, childNodes[index]);\r\n\t\t} else {\r\n\t\t\tstyleElement.appendChild(cssNode);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction applyToTag(styleElement, obj) {\r\n\tvar css = obj.css;\r\n\tvar media = obj.media;\r\n\r\n\tif(media) {\r\n\t\tstyleElement.setAttribute(\"media\", media)\r\n\t}\r\n\r\n\tif(styleElement.styleSheet) {\r\n\t\tstyleElement.styleSheet.cssText = css;\r\n\t} else {\r\n\t\twhile(styleElement.firstChild) {\r\n\t\t\tstyleElement.removeChild(styleElement.firstChild);\r\n\t\t}\r\n\t\tstyleElement.appendChild(document.createTextNode(css));\r\n\t}\r\n}\r\n\r\nfunction updateLink(linkElement, obj) {\r\n\tvar css = obj.css;\r\n\tvar sourceMap = obj.sourceMap;\r\n\r\n\tif(sourceMap) {\r\n\t\t// http://stackoverflow.com/a/26603875\r\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\r\n\t}\r\n\r\n\tvar blob = new Blob([css], { type: \"text/css\" });\r\n\r\n\tvar oldSrc = linkElement.href;\r\n\r\n\tlinkElement.href = URL.createObjectURL(blob);\r\n\r\n\tif(oldSrc)\r\n\t\tURL.revokeObjectURL(oldSrc);\r\n}\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/style-loader/addStyles.js\n ** module id = 24\n ** module chunks = 0\n **/","export default ($stateProvider, $urlRouterProvider) => {\r\n    $stateProvider\r\n\r\n        // setup an abstract state for the tabs directive\r\n        .state('tab', {\r\n            url: '/tab',\r\n            abstract: true,\r\n            template: require('./tabs.html')\r\n        })\r\n}\n\n\n/** WEBPACK FOOTER **\n ** ./app/components/tabs/tabs.route.js\n **/","module.exports = \"<ion-tabs class=\\\"tabs-icon-top tabs-color-active-positive\\\"> <ion-tab icon-off=ion-ios-home icon-on=ion-ios-home href=#/tab/dash> <ion-nav-view name=tab-dash></ion-nav-view> </ion-tab> <ion-tab title= href=#/tab/chats> <ion-nav-view name=tab-chats></ion-nav-view> </ion-tab> <ion-tab title=\\\" \\\" href=#/tab/account> <ion-nav-view name=tab-account></ion-nav-view> </ion-tab> <ion-tab title=\\\" \\\" href=#/tab/account> <ion-nav-view name=tab-account></ion-nav-view> </ion-tab> </ion-tabs>\";\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/components/tabs/tabs.html\n ** module id = 26\n ** module chunks = 0\n **/","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!./../../../node_modules/css-loader/index.js!./../../../node_modules/sass-loader/index.js!./tabs.scss\");\nif(typeof content === 'string') content = [[module.id, content, '']];\n// add the styles to the DOM\nvar update = require(\"!./../../../node_modules/style-loader/addStyles.js\")(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(module.hot) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!./../../../node_modules/css-loader/index.js!./../../../node_modules/sass-loader/index.js!./tabs.scss\", function() {\n\t\t\tvar newContent = require(\"!!./../../../node_modules/css-loader/index.js!./../../../node_modules/sass-loader/index.js!./tabs.scss\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/components/tabs/tabs.scss\n ** module id = 27\n ** module chunks = 0\n **/","exports = module.exports = require(\"./../../../node_modules/css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \".tabs-icon-top>.tabs .tab-item{line-height:40px;font-size:15px}\", \"\"]);\n\n// exports\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/css-loader!./~/sass-loader!./app/components/tabs/tabs.scss\n ** module id = 28\n ** module chunks = 0\n **/","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!./../../node_modules/css-loader/index.js!./../../node_modules/sass-loader/index.js!./index.scss\");\nif(typeof content === 'string') content = [[module.id, content, '']];\n// add the styles to the DOM\nvar update = require(\"!./../../node_modules/style-loader/addStyles.js\")(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(module.hot) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!./../../node_modules/css-loader/index.js!./../../node_modules/sass-loader/index.js!./index.scss\", function() {\n\t\t\tvar newContent = require(\"!!./../../node_modules/css-loader/index.js!./../../node_modules/sass-loader/index.js!./index.scss\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/scss/index.scss\n ** module id = 29\n ** module chunks = 0\n **/","exports = module.exports = require(\"./../../node_modules/css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \"body{direction:rtl}\", \"\"]);\n\n// exports\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/css-loader!./~/sass-loader!./app/scss/index.scss\n ** module id = 30\n ** module chunks = 0\n **/"],"sourceRoot":""}